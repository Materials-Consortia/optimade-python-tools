{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OPTIMADE Python tools \u00b6 Latest release Build status Activity The aim of OPTIMADE is to develop a common API, compliant with the JSON API 1.0 specification. This is to enable interoperability among databases that contain calculated properties of existing and hypothetical materials. This repository contains a library of tools for implementing and consuming OPTIMADE APIs using Python. It also contains a server validator tool, which may be called from the shell or used as a GitHub Action from optimade-validator-action . Disclaimer : While the package supports elasticsearch-dsl v6 & v7 and django v2 & v3, all tests are performed with the latest supported version. If you experience any issues with the older versions, you are most welcome to contribute to the repository (see below under Contributing ). Status \u00b6 Whilst v1.0 of the OPTIMADE specification has been released, this repository is under development . Outstanding features required for compliance with OPTIMADE v1.0 can be tracked with the OPTIMADE v1.0 label on GitHub , which can be further filtered by backend. The release history and changelog can be found in the changelog . Documentation \u00b6 This document, guides, and the full module API documentation can be found online at https://optimade.org/optimade-python-tools . Installation \u00b6 Detailed instructions for installing and running the index meta-database and the main API can be found in the installation documentation . The latest stable version of this package can be obtained from PyPI pip install optimade . The latest development version of this package can be installed from the master branch of this repository git clone https://github.com/Materials-Consortia/optimade-python-tools . Supported OPTIMADE versions \u00b6 Each release of the optimade package from this repository only targets one version of the OPTIMADE specification, summarised in the table below. OPTIMADE API version optimade version v1.0.0 v0.12.9 v1.0.1 \u2020 v0.13.1 \u2020 Whilst both the specification and this package follow semantic versioning, a potentially backwards incompatible change was introduced in v1.0.1 of the specification. Contributing \u00b6 Contribution tips and guidelines can be found in the contributing guidelines . Links \u00b6 OPTIMADE Specification , the human-readable specification that this library is based on. optimade-validator-action , a GitHub action that can be used to validate implementations from a URL (using the validator from this repo). OpenAPI , the machine-readable format used to specify the OPTIMADE API in openapi.json and index_openapi.json . Interactive documentation generated from openapi.json (see also interactive JSON editor ). pydantic , the library used for generating the OpenAPI schema from Python models . FastAPI , the framework used for generating the reference implementation expressed by the openapi.json specification. lark , the library used to parse the filter language in OPTIMADE queries.","title":"Home"},{"location":"#optimade-python-tools","text":"Latest release Build status Activity The aim of OPTIMADE is to develop a common API, compliant with the JSON API 1.0 specification. This is to enable interoperability among databases that contain calculated properties of existing and hypothetical materials. This repository contains a library of tools for implementing and consuming OPTIMADE APIs using Python. It also contains a server validator tool, which may be called from the shell or used as a GitHub Action from optimade-validator-action . Disclaimer : While the package supports elasticsearch-dsl v6 & v7 and django v2 & v3, all tests are performed with the latest supported version. If you experience any issues with the older versions, you are most welcome to contribute to the repository (see below under Contributing ).","title":"OPTIMADE Python tools"},{"location":"#status","text":"Whilst v1.0 of the OPTIMADE specification has been released, this repository is under development . Outstanding features required for compliance with OPTIMADE v1.0 can be tracked with the OPTIMADE v1.0 label on GitHub , which can be further filtered by backend. The release history and changelog can be found in the changelog .","title":"Status"},{"location":"#documentation","text":"This document, guides, and the full module API documentation can be found online at https://optimade.org/optimade-python-tools .","title":"Documentation"},{"location":"#installation","text":"Detailed instructions for installing and running the index meta-database and the main API can be found in the installation documentation . The latest stable version of this package can be obtained from PyPI pip install optimade . The latest development version of this package can be installed from the master branch of this repository git clone https://github.com/Materials-Consortia/optimade-python-tools .","title":"Installation"},{"location":"#supported-optimade-versions","text":"Each release of the optimade package from this repository only targets one version of the OPTIMADE specification, summarised in the table below. OPTIMADE API version optimade version v1.0.0 v0.12.9 v1.0.1 \u2020 v0.13.1 \u2020 Whilst both the specification and this package follow semantic versioning, a potentially backwards incompatible change was introduced in v1.0.1 of the specification.","title":"Supported OPTIMADE versions"},{"location":"#contributing","text":"Contribution tips and guidelines can be found in the contributing guidelines .","title":"Contributing"},{"location":"#links","text":"OPTIMADE Specification , the human-readable specification that this library is based on. optimade-validator-action , a GitHub action that can be used to validate implementations from a URL (using the validator from this repo). OpenAPI , the machine-readable format used to specify the OPTIMADE API in openapi.json and index_openapi.json . Interactive documentation generated from openapi.json (see also interactive JSON editor ). pydantic , the library used for generating the OpenAPI schema from Python models . FastAPI , the framework used for generating the reference implementation expressed by the openapi.json specification. lark , the library used to parse the filter language in OPTIMADE queries.","title":"Links"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v0.13.3 (2021-03-05) \u00b6 Full Changelog Fixed bugs: Support anyOf , allOf , etc. standard OpenAPI fields #730 Python 3.9 support invalid #728 Merged pull requests: Update dependencies #734 ( CasperWA ) Update pydantic to ~=1.8 #731 ( CasperWA ) Bump providers from da74513 to e2074e8 #727 ( dependabot[bot] ) v0.13.2 (2021-03-01) \u00b6 Full Changelog Implemented enhancements: Improve validation of providers #723 Merged pull requests: Update dependencies #725 ( CasperWA ) v0.13.1 (2021-02-23) \u00b6 Full Changelog Fixed bugs: Supported OPTIMADE __api_version__ is incorrect in latest release #712 Merged pull requests: Bump OPTIMADE version #713 ( ml-evs ) v0.13.0 (2021-02-20) \u00b6 Full Changelog Closed issues: Update species.mass model #630 Merged pull requests: Update species->mass field following specification change #631 ( ml-evs ) v0.12.9 (2021-02-10) \u00b6 Full Changelog Implemented enhancements: Improve support for timestamp queries in MongoTransformer #590 ( ml-evs ) Fixed bugs: Use Enums for pydantic model defaults instead of strings #683 Closed issues: When using --as-type in validator, one does not get a summary ( --json doesn't work) #699 Extension/import issue with mongo collection #682 Merged pull requests: Update dependencies #707 ( CasperWA ) Always print summary as last thing in validation #700 ( CasperWA ) Bump django from 3.1.5 to 3.1.6 #698 ( dependabot[bot] ) Fixes for new gateway implementation #684 ( CasperWA ) v0.12.8 (2021-01-18) \u00b6 Full Changelog Implemented enhancements: Validate mandatory query field structure\\_features #678 Fixed bugs: Validator should not rely on meta-\\>data\\_available #677 Validator should not rely on SHOULD \"meta\" field \"data_returned\" #675 Validator: remove reliance on meta fields and check mandatory queries #676 ( ml-evs ) Merged pull requests: Update dependencies #697 ( CasperWA ) Bump providers from 542ac0a to da74513 #679 ( dependabot[bot] ) v0.12.7 (2021-01-15) \u00b6 Full Changelog Implemented enhancements: Make content-type response checks on '/versions` endpoint optional #670 ( ml-evs ) Fixed bugs: Publish workflow fails when no changes to api docs between versions #673 /versions header Content-Type value should be granularized according to RFC requirements in validator #669 Misleading error message from validator on failure from '/versions' #668 Fix publishing workflow #674 ( ml-evs ) Merged pull requests: Update codecov coverage config file #672 ( CasperWA ) Bump providers from fe5048b to 542ac0a #671 ( dependabot[bot] ) v0.12.6 (2021-01-08) \u00b6 Full Changelog Implemented enhancements: Create base transformer #286 Fixed bugs: Our models and validator are too strict #399 Validator changes: always check unversioned '/versions' and handle rich HTML pages #665 ( ml-evs ) Closed issues: Add more prominent link to rendered docs #628 Review the required properties of StructureResourceAttributes in openapi.json #198 Merged pull requests: Added GitHub CODEOWNERS #664 ( ml-evs ) Robustness improvements to validator #659 ( ml-evs ) Update dependencies #655 ( CasperWA ) Bugfixes for elasticsearch filtertransformer comparision operators. #648 ( markus1978 ) Update dependencies #647 ( ml-evs ) Added \"root_path\" config parameter for FastAPI apps #634 ( markus1978 ) Bump providers from 2673be6 to fe5048b #633 ( dependabot[bot] ) Updated README and moved some files to top-level #629 ( ml-evs ) insert reading of default optimade_config.json in example run script run.sh #627 ( rartino ) Create template filtertransformer BaseTransformer #287 ( ml-evs ) v0.12.5 (2020-12-05) \u00b6 Full Changelog Closed issues: PyPI publishing build is broken by latest pip #624 Empty endpoints raise errors on validation #622 Frequency of updating online docs #452 Merged pull requests: Fix PyPI publishing in CI #623 ( ml-evs ) Change validation error to warning on empty endpoints #621 ( ml-evs ) Update dependencies #620 ( CasperWA ) Upstream fixes from specification #611 ( ml-evs ) Minor fixes for the validator #610 ( ml-evs ) Dependency updates #607 ( ml-evs ) include LICENSE in pip Package #594 ( jan-janssen ) Relax models to allow for all SHOULD fields to be None #560 ( ml-evs ) Python 3.9 support #558 ( ml-evs ) ReadTheDocs configuration file (v2) #485 ( CasperWA ) v0.12.4 (2020-11-16) \u00b6 Full Changelog Merged pull requests: Minor fixes for versions endpoint validation #591 ( ml-evs ) Add --minimal/--page_limit validator options and remove old code #571 ( ml-evs ) v0.12.3 (2020-11-04) \u00b6 Full Changelog Fixed bugs: GITHUB_TOKEN not useful for changelog action #587 Hill notation wrong (still) #585 Hill notation validation turning around C and H #581 Closed issues: Make structure \"deformity\" tests more robust #583 Incomplete output of optimade-validator #568 Merged pull requests: Use special release PAT for CHANGELOG generation action #588 ( CasperWA ) Check for carbon in elements for Hill #586 ( CasperWA ) Added better expected error messages to deformity tests #584 ( ml-evs ) Fix Hill ordering validation #582 ( CasperWA ) Bump mkdocs-material from 6.1.0 to 6.1.2 #580 ( dependabot[bot] ) Moved CONFIG import so it does not get triggered when just importing mapper #569 ( ml-evs ) v0.12.2 (2020-10-31) \u00b6 Full Changelog Implemented enhancements: Add convenience method for adding all required middleware #536 Add model validators and regexp for chemical formulae fields #547 ( ml-evs ) Validator improvements #515 ( ml-evs ) Fixed bugs: 'Chosen entry had no value for ...' when property is not requested #514 Fix Species validators and error messages #561 ( ml-evs ) Closed issues: Chemical symbols D and T #570 Push back dependabot to monthly updates #567 Spurious validation errors in Structure->Species #559 Chemical formulae are not properly validated on model creation #546 Merged pull requests: Update dependencies #578 ( CasperWA ) Bump CasperWA/push-protected from v1 to v2.1.0 #573 ( dependabot[bot] ) Update deps #566 ( ml-evs ) Improve handling of MongoDB ObjectID #557 ( ml-evs ) Update deps #556 ( ml-evs ) Updated dependencies #551 ( ml-evs ) Update dependencies - remove black as direct dependency #545 ( CasperWA ) Added convenience variables for middleware and exception handlers #537 ( ml-evs ) Update dependencies #531 ( ml-evs ) v0.12.1 (2020-09-24) \u00b6 Full Changelog Implemented enhancements: Move entry schemas to separate submodule #511 ( ml-evs ) Closed issues: Validator should allow implementations to return \"501 Not Implemented\" for unsupported filters #518 Landing page wrong URL #371 Merged pull requests: This should ensure requirements*.txt are tested #527 ( CasperWA ) Update dependencies #526 ( CasperWA ) Fix landing page URL #519 ( shyamd ) Update dependencies #510 ( ml-evs ) Fixing typo validatated -> validated #506 ( merkys ) Make validator respond to KeyboardInterrupts #505 ( ml-evs ) Add support levels to validator config #503 ( ml-evs ) Enable JSON response from the validator #502 ( ml-evs ) Update dependencies #501 ( CasperWA ) v0.12.0 (2020-09-11) \u00b6 Full Changelog Fixed bugs: Missing field descriptions in schema for Species->name and Person->name #492 \"type\" field not marked as required for derived entry resource models #479 OpenAPI validations fails due to incorrect type of \"dimension_types\" #478 Have fallbacks for retrieving providers list #450 Commit only when necessary #495 ( CasperWA ) Fix field optonality inconsistency in schema #482 ( ml-evs ) Closed issues: Validator message for wrong version #493 Validator should validate versions endpoint #491 List of providers not included in /links endpoint for index meta-database #454 Validate bad version URLs responding with 553 Version Not Supported #427 Nonexistent property 'list' in validator tests #423 Test data\\_returned #402 AiiDA tests only run on Python 3.8 in CI #401 Links under top-level 'links' may be objects #394 Suggestion: use absolute imports in app code to allow re-use #298 Update mongomock requirement when next released #207 error when browsing OpenAPI docs #192 Merged pull requests: Don't report untracked and ignored files #496 ( CasperWA ) Improved error message for bad version returning 553 #494 ( ml-evs ) Update dependencies #490 ( CasperWA ) Allow Link objects for pagination #484 ( ml-evs ) Absolute imports #483 ( CasperWA ) Validate OpenAPI specification in CI #481 ( ml-evs ) Update types to align with OpenAPI #480 ( CasperWA ) Update dependencies and pre-commit #477 ( CasperWA ) Unpin CI Python version for AiiDA tests #472 ( ml-evs ) Update dependencies #471 ( CasperWA ) Update dependencies #466 ( CasperWA ) Provider list fallback and list of providers in both servers' /links -endpoints #455 ( CasperWA ) SHOULD/MUST/OPTIONAL fields in models #453 ( ml-evs ) Validator overhaul #417 ( ml-evs ) v0.11.0 (2020-08-05) \u00b6 Full Changelog Implemented enhancements: Use logging more thoroughly throughout the code base #242 Implement warnings #105 Fixed bugs: Heroku is failing - raising OSError when making LOGS_DIR #448 /versions endpoint content-type parameter \"header=present\" is provided in the wrong place #418 Publish workflow cannot push to protected branch #341 Fix circular dep and extra permission error in logs #436 ( ml-evs ) Closed issues: log_dir option in config is unused #435 Allow all types of JSON API relationships #429 OPTIMADE version badge was not bumped on 1.0 release #415 Add api\\_hint query parameter #392 Return 553 for wrongly versioned base URLs #391 Private/dunder methods incorrectly documented in mkdocs #365 Configuration documentation #310 Improve handling of sorting in MongoDB backend #276 Merged pull requests: Catch OSError instead of PermissionError when making log dir #449 ( CasperWA ) Update dependencies #447 ( CasperWA ) Bump mkdocstrings from 0.12.1 to 0.12.2 and mkdocs-material from 5.5.0 to 5.5.2 #440 ( dependabot[bot] ) Bump uvicorn from 0.11.5 to 0.11.7 #433 ( dependabot[bot] ) Introduce logging #432 ( CasperWA ) New middleware to catch any OptimadeWarning s #431 ( CasperWA ) Auto-generate API reference in docs and an overhaul #430 ( CasperWA ) Bump providers from 52027b1 to 9712dd8 #428 ( dependabot[bot] ) Cleanup config files #426 ( CasperWA ) Update more unittest tests to pytest #425 ( CasperWA ) Sorting on unknown properties: returning Bad Request when appropriate #424 ( ml-evs ) Minor CI updates #422 ( CasperWA ) Add api\\_hint query parameter #421 ( CasperWA ) Implement 553 Version Not Supported #420 ( CasperWA ) Fix incorrect placement of header=present in versions endpoint #419 ( ml-evs ) Bump optimade-version.json to 1.0.0 #416 ( ml-evs ) Use optimade-validator-action v2 #413 ( CasperWA ) Bump providers from a96d424 to 52027b1 #389 ( dependabot[bot] ) v0.10.0 (2020-07-17) \u00b6 Full Changelog Implemented enhancements: Move tests to pytest system from unittest #270 Fixed bugs: Fix /vMAJOR/info in index server #414 ( CasperWA ) Closed issues: Validation of 'structures' type crashes #397 Validator verbosity levels need more detailed description #396 Validator treats top-level 'included' array as mandatory #393 (Un)versioned URLs #379 Merged pull requests: Update dependencies #412 ( CasperWA ) Bump pydantic from 1.5.1 to 1.6.1 #405 ( dependabot[bot] ) Temporarily run AiiDA tests on Python 3.8 only #400 ( ml-evs ) Make the example for --as_type more similar to a real use case #398 ( merkys ) Fix some validator-specific crashes #395 ( ml-evs ) Use pytest instead of unittest #390 ( CasperWA ) Update dependencies #388 ( CasperWA ) v0.9.8 (2020-07-03) \u00b6 Full Changelog Implemented enhancements: Set implementation version in config by default #385 ( CasperWA ) Merged pull requests: Update models, endpoints and responses to 1.0.0 #380 ( ml-evs ) v0.9.7 (2020-06-28) \u00b6 Full Changelog v0.9.6 (2020-06-28) \u00b6 Full Changelog Fixed bugs: Fix publish workflow - final(TM) fix #378 ( CasperWA ) v0.9.5 (2020-06-26) \u00b6 Full Changelog Implemented enhancements: Use new action for publishing #377 ( CasperWA ) v0.9.4 (2020-06-26) \u00b6 Full Changelog v0.9.3 (2020-06-26) \u00b6 Full Changelog Merged pull requests: Fix version issues in the publish workflow #376 ( shyamd ) Bump providers from 732593a to a96d424 #368 ( dependabot[bot] ) v0.9.2 (2020-06-25) \u00b6 Full Changelog Fixed bugs: Heroku cannot handle submodules when deploying via GitHub #373 Closed issues: Updates to models (new OPTIONAL type field under properties ) #345 Add aggregatation fields to links model #344 Updates to models (nperiodic_dimensions) #343 Updates to models (changing unknown atoms) #342 Improvements/fixes for openapi.json #332 Update to v1.0.0-rc.1 #329 Decouple updates in providers repo #311 RST not rendering with mkdocs #307 Merged pull requests: Retrieve providers list if no submodule is found #374 ( CasperWA ) Update default implementation information #372 ( shyamd ) Bump spec version to 1.0.0-rc.2 #367 ( ml-evs ) Dependabot updates: numpy, mkdocs-material, mkdocstrings, requests #364 ( ml-evs ) Merge all Dependabot updates #353 ( shyamd ) Update model descriptions and openapi.json for 1.0.0-rc2 #351 ( ml-evs ) Update models according to changes during CECAM 2020 meeting #350 ( ml-evs ) Decouple changes in providers repo #312 ( shyamd ) v0.9.1 (2020-06-17) \u00b6 Full Changelog v0.9.0 (2020-06-17) \u00b6 Full Changelog Implemented enhancements: Breaking up the python tools into seperable packages #255 Run both servers as standard #238 Fixed bugs: Non-running CI job #331 Special species \"X\" not tested for non-disordered structures #304 Standardize timezone of datetime responses #288 Queries on aliased/provider fields are broken for nested properties #282 General exceptions not being put into response #281 Issue with CIF export #271 Type-cast inputs for general Error #280 ( CasperWA ) Security fixes: [Security] Bump django from 3.0.4 to 3.0.7 in /.github/workflows #291 ( dependabot-preview[bot] ) Closed issues: Update links resources #299 Need to set up mkdocs #289 Need to add custom schema entries for unit/sortable (and eventually type) #278 /info/\\<entry-endpoint> missing sortable key under each property #273 Make CI linting more useful #269 [PR SPECIFIC] Reminder: Validator test pinned to specific commit #268 Validator does not check that pagination links work #265 available_api_versions is not correctly validated #261 Implementation model should allow for any URL type in source\\_url #260 Extra structure endpoints in the api specification @ odbx #259 Wrong response structure at info endpoint @ cod #258 Missing base url for api's docs @ materialscloud #257 Handling of KNOWN in mongo backend #254 None values in lattice\\_vectors #170 Make sure that the PyPI distribution works #143 Move run.sh to a python file to be environment-agnostic #81 Merged pull requests: Another fix for release pipeline #355 ( shyamd ) Fix publish workflow #354 ( CasperWA ) Fix publish workflow #352 ( CasperWA ) Update publish workflow #340 ( shyamd ) Remove test publish action #338 ( shyamd ) Fix 'publish_TestPyPI' CI job #337 ( CasperWA ) Specify versions for all setup.py deps #336 ( CasperWA ) Represent the datetime objects as UTC in RFC3339 format #333 ( fekad ) dependamat: Bump \\<package_name> v x.y.z to vx.y.(z+1) #330 ( ml-evs ) Bump fastapi from 0.53.1 to 0.56.0 #324 ( dependabot[bot] ) Update links resources #306 ( CasperWA ) Add special species for adapters testing #305 ( CasperWA ) Clean Up Build Environment #301 ( shyamd ) Enable CI failures for linting #300 ( ml-evs ) Adding jarvis-tools structures #297 ( knc6 ) Update Docs #295 ( shyamd ) Setup MKDocs for Documentation #294 ( shyamd ) Fix filters on nested provider/aliased fields #285 ( ml-evs ) Use heroku-shields instead of heroku-badge #284 ( CasperWA ) Add OPTIMADE logo to badge by extending JSON #283 ( CasperWA ) Add null check to mongo filtertransformer for KNOWN/UNKNOWN filters #279 ( ml-evs ) Add sortable=True to all properties #274 ( CasperWA ) Make _atom_site_label unique in CIF generation #272 ( CasperWA ) Not so quick fix to allow \"/\" at end of validator URL, plus fixes and tests for --as_type #267 ( ml-evs ) Check pagination links->next with validator #266 ( ml-evs ) Relax HTTP URL constraints on meta->implementation->source_url field. #262 ( ml-evs ) Validate lattice_vectors for all null or all float #171 ( CasperWA ) v0.8.1 (2020-04-25) \u00b6 Full Changelog Fixed bugs: Pip install missing some files #252 Merged pull requests: v0.8.1 hotfix #256 ( ml-evs ) Fix 252 missing landing page #253 ( shyamd ) v0.8.0 (2020-04-22) \u00b6 Full Changelog Implemented enhancements: Switch to pydantic's BaseSettings for the config file? #152 Use services for testing/updating dependencies? #96 Remove query constraints for /links-endpoint #244 ( CasperWA ) Add adapters - Base design + 'structures' (+ 'references'... sort of) #241 ( CasperWA ) Add dependabot and last commit date badges #237 ( CasperWA ) Add mongo length operator functionality with length aliases #222 ( ml-evs ) Fixed bugs: Use Path.home() instead of ~ in default config path values #245 Closed issues: Have Dependabot take care of various requirements.txt files as well #249 Remove commented out GH Action job deps\\_clean-install #247 Local testing fails without default config #239 Release only when pushing to master #229 Do we need server.cfg ? #134 Implement LENGTH in query #86 Merged pull requests: Up to v0.8.0 #251 ( CasperWA ) Remove old commented GH Action job #250 ( CasperWA ) Use Path.home() instead of ~ #246 ( CasperWA ) Fix path in default config #243 ( ml-evs ) Fixes Local Tests #240 ( shyamd ) Revert \"Fix github actions for non-release tags\" #236 ( shyamd ) Enable filtering on relationships with mongo #234 ( ml-evs ) Update filter examples and validate optional cases #227 ( ml-evs ) Switch from config init to BaseSettings #226 ( shyamd ) v0.7.1 (2020-03-16) \u00b6 Full Changelog Closed issues: Fix all capitalisation of OPTIMADE #232 Remove validator action from README #230 Merged pull requests: Fix github actions for non-release tags #235 ( shyamd ) Update OPTIMADE capitalisation #233 ( ml-evs ) Update mentions of action in readme #231 ( ml-evs ) v0.7.0 (2020-03-13) \u00b6 Full Changelog Implemented enhancements: Validate all non-optional :filter: examples from the spec #213 ( ml-evs ) Fixed bugs: Some mandatory filter examples from spec do not work #217 Add txt-files in optimade.validator.data to MANIFEST #225 ( CasperWA ) Handle arbitrary nested NOT/AND/OR in queries #221 ( ml-evs ) Closed issues: Validator only validates what we have working, not what is required by the spec #182 Merged pull requests: v0.7.0 release #228 ( ml-evs ) Remove GH Action to validate OPTiMaDe instances #224 ( CasperWA ) Codecov-action supports token-less uploads #220 ( CasperWA ) Update django requirement from >=2.2.9,~=2.2 to >=2.2,\\<4.0 #219 ( dependabot-preview[bot] ) Update elasticsearch-dsl requirement from ~=6.4 to >=6.4,\\<8.0 #218 ( dependabot-preview[bot] ) v0.6.0 (2020-03-06) \u00b6 Full Changelog Implemented enhancements: Possibly add CORS middleware #159 Add debug flag to server #130 Make validator GitHub Action #191 ( CasperWA ) Fixed bugs: meta/query/representation value not cutting off version properly #199 URL for providers.json from Materials-Consortia has changed #186 Relationships don't work when \"/\" present in id #181 Redirect middleware not hitting single-entry endpoints #174 Closed issues: /info/ reports wrong url under available_api_versions #215 Query parameters not handled correctly #208 Test for AvailableApiVersion is correct for the wrong reasons #204 Drop '/optimade' from paths in openapi.json #197 heroku is failing #185 List properties and HAS _ operators missing #98 Checklist for OPTiMaDe v0.10.1 #29 Merged pull requests: Removed /optimade/ prefix in info response #216 ( ml-evs ) Self load data #212 ( shyamd ) Update tests for available_api_versions #211 ( CasperWA ) Up to v0.6.0 #210 ( CasperWA ) Update handling of include parameter (and other query parameters) #209 ( CasperWA ) Skip HAS ONLY test if mongomock version \\<= 3.19.0 #206 ( ml-evs ) Test mandatory queries in validator #205 ( ml-evs ) Fix include query parameter #202 ( CasperWA ) Fix meta.query.representation and remove /optimade in base URLs #201 ( CasperWA ) Use mongo for CI #196 ( ml-evs ) (Cosmetic) updates to models #195 ( CasperWA ) Add CORSMiddleware #194 ( CasperWA ) Add \"debug mode\" #190 ( CasperWA ) Use https://provider.optimade.org/providers.json #187 ( CasperWA ) Fix errors parsing IDs that contain slashes #183 ( ml-evs ) Added default mongo implementations for HAS ALL/ANY/ONLY #173 ( ml-evs ) v0.5.0 (2020-02-13) \u00b6 Full Changelog Implemented enhancements: Implement a landing page for requests to the base URL #169 Fixed bugs: 'minor' and 'patch' versioned base URL prefixes are wrong #177 Closed issues: Handle include standard JSON API query parameter #94 Merged pull requests: Bump to v0.5.0 #179 ( CasperWA ) Correctly create optional versioned base URLs #178 ( CasperWA ) Make mapper aliases configurable #175 ( ml-evs ) Add landing page at base URL #172 ( ml-evs ) Implement include query parameter #163 ( CasperWA ) Add docker for index meta-database #140 ( CasperWA ) v0.4.0 (2020-02-06) \u00b6 Full Changelog Implemented enhancements: switch to pipenv? #37 Reorder tests #162 ( CasperWA ) Fixed bugs: Server app intermingles #161 response\\_fields not working #154 Closed issues: Change page\\_page to page\\_number #165 Add schema-relevant parameters to query parameters #164 Alias optimade/structures/ to optimade/structure #128 Minor changes to specification v0.10.1-develop #115 Update models with new levels of REQUIRED response properties #114 Constraining list/array types in the schema #55 Merged pull requests: Bump to v0.4.0 #168 ( CasperWA ) Describe query parameters in OpenAPI schema #166 ( CasperWA ) Redirect slashed URLs #160 ( CasperWA ) New REQUIRED level properties #153 ( CasperWA ) v0.3.4 (2020-02-04) \u00b6 Full Changelog Implemented enhancements: Include develop or not? Default branch? - Create INSTALL.md #136 Fixed bugs: Excepting non-existent exception #129 Closed issues: disable serving API under /v0.10 and /v0.10.0 by default? #122 PyPI release checklist #67 Merged pull requests: Bump to v0.3.4 #158 ( CasperWA ) Fix heroku badge #157 ( ml-evs ) Move installation instructions #156 ( ml-evs ) Update base URLs #155 ( CasperWA ) Extend OpenAPI/spec description #151 ( CasperWA ) Non Local Mongo #150 ( shyamd ) v0.3.3 (2020-01-24) \u00b6 Full Changelog Fixed bugs: Lark files not being distributed #141 Closed issues: Tests fail with lark-parser>=0.8 #146 Merged pull requests: Updated lark-parser to 0.8.1 #149 ( ml-evs ) Split eager and standard tests to avoid unnecessary badge of shame #148 ( ml-evs ) Bump to v0.3.3 #147 ( CasperWA ) Fix root_validator issues with optional fields and made meta optional #145 ( ml-evs ) Handle JSONDecodeError s in validator #144 ( ml-evs ) v0.3.2 (2020-01-20) \u00b6 Full Changelog Implemented enhancements: Add base URL to configuration file #135 ( CasperWA ) Fixed bugs: Fix load\\_from\\_json #137 ( CasperWA ) Merged pull requests: Make sure relevant package data is included in distributions #142 ( CasperWA ) Add database page limit #139 ( CasperWA ) v0.3.1 (2020-01-17) \u00b6 Full Changelog Merged pull requests: Update requirements #138 ( CasperWA ) v0.3.0 (2020-01-14) \u00b6 Full Changelog Implemented enhancements: Implement optional implementation in top-level meta response #117 Create \"special\" index meta-database server #100 Implement relationships in server #71 Add missing /references endpoint to server #69 Automatically publish version tags to PyPI via GH Actions #107 ( CasperWA ) Using routers #99 ( CasperWA ) Add relationships functionality #91 ( ml-evs ) Added external API validator based on our pydantic models #74 ( ml-evs ) Fixed bugs: The invoke task update-openapijson is incomplete #123 Django vulnerability #108 Closed issues: info endpoint duplicated? #120 Commented-out validator #111 FastAPI v0.44.0 supports pydantic > 1.0.0 #101 Server is missing /links endpoint #89 Make sure all validators are tested #87 The sortable field must be added to models #84 Package structure #72 Possibly make /info/{endpoint} dynamic #70 setuptools package with server as \"extra\" #62 use examples from specs as resources #57 httptools dependency has build issues on GCC/Linux #54 Lark grammar file for v0.9.8 #50 type is missing in response #43 Enforce use of autoformatter #33 switch license to MIT #28 write a lark JSONTransformer / JSONdecoder #26 server.jsonapi has no additionalProperties=false #23 server.jsonapi has no patternProperties #22 Developer-friendly pre-commit openapi.json visual diff #21 add JSON schema API #12 generate static documentation on github from openapi.json #9 test how to generate a client from the openapi.json #8 come up with suggested toolchain for validating existing optimade API against openapi.json #7 add travis test that checks openapi.json is valid OpenAPI spec #6 add 2 examples of how to include documentation in python classes #5 add one-line command to update openapi.json #4 Merged pull requests: Fixed CI readme badge #133 ( ml-evs ) Add meta.description to BaseRelationshipResource #131 ( CasperWA ) Added homepage attribute to LinksResource #127 ( ml-evs ) Updated structure models and validators #126 ( ml-evs ) Minor change to fallback server.cfg #125 ( ml-evs ) Update local OpenAPI schemes prior to copying #124 ( CasperWA ) Update OpenAPI tags #121 ( CasperWA ) A few fixes related to usage as a library #119 ( ml-evs ) Add implementation to top-level meta response #118 ( CasperWA ) Add heroku deployment scripts #116 ( ltalirz ) Reorganize package #113 ( CasperWA ) Introduce grammar v0.10.1 #112 ( CasperWA ) Update to pydantic v1 #110 ( CasperWA ) Minimum requirement of django v2.2.8 #109 ( CasperWA ) Index meta-database #103 ( CasperWA ) restrict pydantic version #97 ( ltalirz ) Add /links #95 ( CasperWA ) Fix data_returned and data_available #93 ( CasperWA ) Use GitHub Actions for CI #92 ( ml-evs ) Remove inappropriate lint messages #90 ( CasperWA ) Fix dependencies #88 ( CasperWA ) Add sortable field to EntryInfoProperty model #85 ( CasperWA ) Validate illegal fields are not present under attributes and relationships #83 ( CasperWA ) Add references endpoint #78 ( CasperWA ) fix travis build #77 ( ltalirz ) Fix manual verification of elements_ratios #76 ( CasperWA ) add automatic PyPI deployment #75 ( ltalirz ) Updates to README and docs for v0.10.0 #68 ( ml-evs ) Adding grammar for v0.10.0 #66 ( fekad ) v0.1.2 (2018-06-14) \u00b6 Full Changelog v0.1.1 (2018-06-13) \u00b6 Full Changelog v0.1.0 (2018-06-05) \u00b6 Full Changelog * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v0133-2021-03-05","text":"Full Changelog Fixed bugs: Support anyOf , allOf , etc. standard OpenAPI fields #730 Python 3.9 support invalid #728 Merged pull requests: Update dependencies #734 ( CasperWA ) Update pydantic to ~=1.8 #731 ( CasperWA ) Bump providers from da74513 to e2074e8 #727 ( dependabot[bot] )","title":"v0.13.3 (2021-03-05)"},{"location":"CHANGELOG/#v0132-2021-03-01","text":"Full Changelog Implemented enhancements: Improve validation of providers #723 Merged pull requests: Update dependencies #725 ( CasperWA )","title":"v0.13.2 (2021-03-01)"},{"location":"CHANGELOG/#v0131-2021-02-23","text":"Full Changelog Fixed bugs: Supported OPTIMADE __api_version__ is incorrect in latest release #712 Merged pull requests: Bump OPTIMADE version #713 ( ml-evs )","title":"v0.13.1 (2021-02-23)"},{"location":"CHANGELOG/#v0130-2021-02-20","text":"Full Changelog Closed issues: Update species.mass model #630 Merged pull requests: Update species->mass field following specification change #631 ( ml-evs )","title":"v0.13.0 (2021-02-20)"},{"location":"CHANGELOG/#v0129-2021-02-10","text":"Full Changelog Implemented enhancements: Improve support for timestamp queries in MongoTransformer #590 ( ml-evs ) Fixed bugs: Use Enums for pydantic model defaults instead of strings #683 Closed issues: When using --as-type in validator, one does not get a summary ( --json doesn't work) #699 Extension/import issue with mongo collection #682 Merged pull requests: Update dependencies #707 ( CasperWA ) Always print summary as last thing in validation #700 ( CasperWA ) Bump django from 3.1.5 to 3.1.6 #698 ( dependabot[bot] ) Fixes for new gateway implementation #684 ( CasperWA )","title":"v0.12.9 (2021-02-10)"},{"location":"CHANGELOG/#v0128-2021-01-18","text":"Full Changelog Implemented enhancements: Validate mandatory query field structure\\_features #678 Fixed bugs: Validator should not rely on meta-\\>data\\_available #677 Validator should not rely on SHOULD \"meta\" field \"data_returned\" #675 Validator: remove reliance on meta fields and check mandatory queries #676 ( ml-evs ) Merged pull requests: Update dependencies #697 ( CasperWA ) Bump providers from 542ac0a to da74513 #679 ( dependabot[bot] )","title":"v0.12.8 (2021-01-18)"},{"location":"CHANGELOG/#v0127-2021-01-15","text":"Full Changelog Implemented enhancements: Make content-type response checks on '/versions` endpoint optional #670 ( ml-evs ) Fixed bugs: Publish workflow fails when no changes to api docs between versions #673 /versions header Content-Type value should be granularized according to RFC requirements in validator #669 Misleading error message from validator on failure from '/versions' #668 Fix publishing workflow #674 ( ml-evs ) Merged pull requests: Update codecov coverage config file #672 ( CasperWA ) Bump providers from fe5048b to 542ac0a #671 ( dependabot[bot] )","title":"v0.12.7 (2021-01-15)"},{"location":"CHANGELOG/#v0126-2021-01-08","text":"Full Changelog Implemented enhancements: Create base transformer #286 Fixed bugs: Our models and validator are too strict #399 Validator changes: always check unversioned '/versions' and handle rich HTML pages #665 ( ml-evs ) Closed issues: Add more prominent link to rendered docs #628 Review the required properties of StructureResourceAttributes in openapi.json #198 Merged pull requests: Added GitHub CODEOWNERS #664 ( ml-evs ) Robustness improvements to validator #659 ( ml-evs ) Update dependencies #655 ( CasperWA ) Bugfixes for elasticsearch filtertransformer comparision operators. #648 ( markus1978 ) Update dependencies #647 ( ml-evs ) Added \"root_path\" config parameter for FastAPI apps #634 ( markus1978 ) Bump providers from 2673be6 to fe5048b #633 ( dependabot[bot] ) Updated README and moved some files to top-level #629 ( ml-evs ) insert reading of default optimade_config.json in example run script run.sh #627 ( rartino ) Create template filtertransformer BaseTransformer #287 ( ml-evs )","title":"v0.12.6 (2021-01-08)"},{"location":"CHANGELOG/#v0125-2020-12-05","text":"Full Changelog Closed issues: PyPI publishing build is broken by latest pip #624 Empty endpoints raise errors on validation #622 Frequency of updating online docs #452 Merged pull requests: Fix PyPI publishing in CI #623 ( ml-evs ) Change validation error to warning on empty endpoints #621 ( ml-evs ) Update dependencies #620 ( CasperWA ) Upstream fixes from specification #611 ( ml-evs ) Minor fixes for the validator #610 ( ml-evs ) Dependency updates #607 ( ml-evs ) include LICENSE in pip Package #594 ( jan-janssen ) Relax models to allow for all SHOULD fields to be None #560 ( ml-evs ) Python 3.9 support #558 ( ml-evs ) ReadTheDocs configuration file (v2) #485 ( CasperWA )","title":"v0.12.5 (2020-12-05)"},{"location":"CHANGELOG/#v0124-2020-11-16","text":"Full Changelog Merged pull requests: Minor fixes for versions endpoint validation #591 ( ml-evs ) Add --minimal/--page_limit validator options and remove old code #571 ( ml-evs )","title":"v0.12.4 (2020-11-16)"},{"location":"CHANGELOG/#v0123-2020-11-04","text":"Full Changelog Fixed bugs: GITHUB_TOKEN not useful for changelog action #587 Hill notation wrong (still) #585 Hill notation validation turning around C and H #581 Closed issues: Make structure \"deformity\" tests more robust #583 Incomplete output of optimade-validator #568 Merged pull requests: Use special release PAT for CHANGELOG generation action #588 ( CasperWA ) Check for carbon in elements for Hill #586 ( CasperWA ) Added better expected error messages to deformity tests #584 ( ml-evs ) Fix Hill ordering validation #582 ( CasperWA ) Bump mkdocs-material from 6.1.0 to 6.1.2 #580 ( dependabot[bot] ) Moved CONFIG import so it does not get triggered when just importing mapper #569 ( ml-evs )","title":"v0.12.3 (2020-11-04)"},{"location":"CHANGELOG/#v0122-2020-10-31","text":"Full Changelog Implemented enhancements: Add convenience method for adding all required middleware #536 Add model validators and regexp for chemical formulae fields #547 ( ml-evs ) Validator improvements #515 ( ml-evs ) Fixed bugs: 'Chosen entry had no value for ...' when property is not requested #514 Fix Species validators and error messages #561 ( ml-evs ) Closed issues: Chemical symbols D and T #570 Push back dependabot to monthly updates #567 Spurious validation errors in Structure->Species #559 Chemical formulae are not properly validated on model creation #546 Merged pull requests: Update dependencies #578 ( CasperWA ) Bump CasperWA/push-protected from v1 to v2.1.0 #573 ( dependabot[bot] ) Update deps #566 ( ml-evs ) Improve handling of MongoDB ObjectID #557 ( ml-evs ) Update deps #556 ( ml-evs ) Updated dependencies #551 ( ml-evs ) Update dependencies - remove black as direct dependency #545 ( CasperWA ) Added convenience variables for middleware and exception handlers #537 ( ml-evs ) Update dependencies #531 ( ml-evs )","title":"v0.12.2 (2020-10-31)"},{"location":"CHANGELOG/#v0121-2020-09-24","text":"Full Changelog Implemented enhancements: Move entry schemas to separate submodule #511 ( ml-evs ) Closed issues: Validator should allow implementations to return \"501 Not Implemented\" for unsupported filters #518 Landing page wrong URL #371 Merged pull requests: This should ensure requirements*.txt are tested #527 ( CasperWA ) Update dependencies #526 ( CasperWA ) Fix landing page URL #519 ( shyamd ) Update dependencies #510 ( ml-evs ) Fixing typo validatated -> validated #506 ( merkys ) Make validator respond to KeyboardInterrupts #505 ( ml-evs ) Add support levels to validator config #503 ( ml-evs ) Enable JSON response from the validator #502 ( ml-evs ) Update dependencies #501 ( CasperWA )","title":"v0.12.1 (2020-09-24)"},{"location":"CHANGELOG/#v0120-2020-09-11","text":"Full Changelog Fixed bugs: Missing field descriptions in schema for Species->name and Person->name #492 \"type\" field not marked as required for derived entry resource models #479 OpenAPI validations fails due to incorrect type of \"dimension_types\" #478 Have fallbacks for retrieving providers list #450 Commit only when necessary #495 ( CasperWA ) Fix field optonality inconsistency in schema #482 ( ml-evs ) Closed issues: Validator message for wrong version #493 Validator should validate versions endpoint #491 List of providers not included in /links endpoint for index meta-database #454 Validate bad version URLs responding with 553 Version Not Supported #427 Nonexistent property 'list' in validator tests #423 Test data\\_returned #402 AiiDA tests only run on Python 3.8 in CI #401 Links under top-level 'links' may be objects #394 Suggestion: use absolute imports in app code to allow re-use #298 Update mongomock requirement when next released #207 error when browsing OpenAPI docs #192 Merged pull requests: Don't report untracked and ignored files #496 ( CasperWA ) Improved error message for bad version returning 553 #494 ( ml-evs ) Update dependencies #490 ( CasperWA ) Allow Link objects for pagination #484 ( ml-evs ) Absolute imports #483 ( CasperWA ) Validate OpenAPI specification in CI #481 ( ml-evs ) Update types to align with OpenAPI #480 ( CasperWA ) Update dependencies and pre-commit #477 ( CasperWA ) Unpin CI Python version for AiiDA tests #472 ( ml-evs ) Update dependencies #471 ( CasperWA ) Update dependencies #466 ( CasperWA ) Provider list fallback and list of providers in both servers' /links -endpoints #455 ( CasperWA ) SHOULD/MUST/OPTIONAL fields in models #453 ( ml-evs ) Validator overhaul #417 ( ml-evs )","title":"v0.12.0 (2020-09-11)"},{"location":"CHANGELOG/#v0110-2020-08-05","text":"Full Changelog Implemented enhancements: Use logging more thoroughly throughout the code base #242 Implement warnings #105 Fixed bugs: Heroku is failing - raising OSError when making LOGS_DIR #448 /versions endpoint content-type parameter \"header=present\" is provided in the wrong place #418 Publish workflow cannot push to protected branch #341 Fix circular dep and extra permission error in logs #436 ( ml-evs ) Closed issues: log_dir option in config is unused #435 Allow all types of JSON API relationships #429 OPTIMADE version badge was not bumped on 1.0 release #415 Add api\\_hint query parameter #392 Return 553 for wrongly versioned base URLs #391 Private/dunder methods incorrectly documented in mkdocs #365 Configuration documentation #310 Improve handling of sorting in MongoDB backend #276 Merged pull requests: Catch OSError instead of PermissionError when making log dir #449 ( CasperWA ) Update dependencies #447 ( CasperWA ) Bump mkdocstrings from 0.12.1 to 0.12.2 and mkdocs-material from 5.5.0 to 5.5.2 #440 ( dependabot[bot] ) Bump uvicorn from 0.11.5 to 0.11.7 #433 ( dependabot[bot] ) Introduce logging #432 ( CasperWA ) New middleware to catch any OptimadeWarning s #431 ( CasperWA ) Auto-generate API reference in docs and an overhaul #430 ( CasperWA ) Bump providers from 52027b1 to 9712dd8 #428 ( dependabot[bot] ) Cleanup config files #426 ( CasperWA ) Update more unittest tests to pytest #425 ( CasperWA ) Sorting on unknown properties: returning Bad Request when appropriate #424 ( ml-evs ) Minor CI updates #422 ( CasperWA ) Add api\\_hint query parameter #421 ( CasperWA ) Implement 553 Version Not Supported #420 ( CasperWA ) Fix incorrect placement of header=present in versions endpoint #419 ( ml-evs ) Bump optimade-version.json to 1.0.0 #416 ( ml-evs ) Use optimade-validator-action v2 #413 ( CasperWA ) Bump providers from a96d424 to 52027b1 #389 ( dependabot[bot] )","title":"v0.11.0 (2020-08-05)"},{"location":"CHANGELOG/#v0100-2020-07-17","text":"Full Changelog Implemented enhancements: Move tests to pytest system from unittest #270 Fixed bugs: Fix /vMAJOR/info in index server #414 ( CasperWA ) Closed issues: Validation of 'structures' type crashes #397 Validator verbosity levels need more detailed description #396 Validator treats top-level 'included' array as mandatory #393 (Un)versioned URLs #379 Merged pull requests: Update dependencies #412 ( CasperWA ) Bump pydantic from 1.5.1 to 1.6.1 #405 ( dependabot[bot] ) Temporarily run AiiDA tests on Python 3.8 only #400 ( ml-evs ) Make the example for --as_type more similar to a real use case #398 ( merkys ) Fix some validator-specific crashes #395 ( ml-evs ) Use pytest instead of unittest #390 ( CasperWA ) Update dependencies #388 ( CasperWA )","title":"v0.10.0 (2020-07-17)"},{"location":"CHANGELOG/#v098-2020-07-03","text":"Full Changelog Implemented enhancements: Set implementation version in config by default #385 ( CasperWA ) Merged pull requests: Update models, endpoints and responses to 1.0.0 #380 ( ml-evs )","title":"v0.9.8 (2020-07-03)"},{"location":"CHANGELOG/#v097-2020-06-28","text":"Full Changelog","title":"v0.9.7 (2020-06-28)"},{"location":"CHANGELOG/#v096-2020-06-28","text":"Full Changelog Fixed bugs: Fix publish workflow - final(TM) fix #378 ( CasperWA )","title":"v0.9.6 (2020-06-28)"},{"location":"CHANGELOG/#v095-2020-06-26","text":"Full Changelog Implemented enhancements: Use new action for publishing #377 ( CasperWA )","title":"v0.9.5 (2020-06-26)"},{"location":"CHANGELOG/#v094-2020-06-26","text":"Full Changelog","title":"v0.9.4 (2020-06-26)"},{"location":"CHANGELOG/#v093-2020-06-26","text":"Full Changelog Merged pull requests: Fix version issues in the publish workflow #376 ( shyamd ) Bump providers from 732593a to a96d424 #368 ( dependabot[bot] )","title":"v0.9.3 (2020-06-26)"},{"location":"CHANGELOG/#v092-2020-06-25","text":"Full Changelog Fixed bugs: Heroku cannot handle submodules when deploying via GitHub #373 Closed issues: Updates to models (new OPTIONAL type field under properties ) #345 Add aggregatation fields to links model #344 Updates to models (nperiodic_dimensions) #343 Updates to models (changing unknown atoms) #342 Improvements/fixes for openapi.json #332 Update to v1.0.0-rc.1 #329 Decouple updates in providers repo #311 RST not rendering with mkdocs #307 Merged pull requests: Retrieve providers list if no submodule is found #374 ( CasperWA ) Update default implementation information #372 ( shyamd ) Bump spec version to 1.0.0-rc.2 #367 ( ml-evs ) Dependabot updates: numpy, mkdocs-material, mkdocstrings, requests #364 ( ml-evs ) Merge all Dependabot updates #353 ( shyamd ) Update model descriptions and openapi.json for 1.0.0-rc2 #351 ( ml-evs ) Update models according to changes during CECAM 2020 meeting #350 ( ml-evs ) Decouple changes in providers repo #312 ( shyamd )","title":"v0.9.2 (2020-06-25)"},{"location":"CHANGELOG/#v091-2020-06-17","text":"Full Changelog","title":"v0.9.1 (2020-06-17)"},{"location":"CHANGELOG/#v090-2020-06-17","text":"Full Changelog Implemented enhancements: Breaking up the python tools into seperable packages #255 Run both servers as standard #238 Fixed bugs: Non-running CI job #331 Special species \"X\" not tested for non-disordered structures #304 Standardize timezone of datetime responses #288 Queries on aliased/provider fields are broken for nested properties #282 General exceptions not being put into response #281 Issue with CIF export #271 Type-cast inputs for general Error #280 ( CasperWA ) Security fixes: [Security] Bump django from 3.0.4 to 3.0.7 in /.github/workflows #291 ( dependabot-preview[bot] ) Closed issues: Update links resources #299 Need to set up mkdocs #289 Need to add custom schema entries for unit/sortable (and eventually type) #278 /info/\\<entry-endpoint> missing sortable key under each property #273 Make CI linting more useful #269 [PR SPECIFIC] Reminder: Validator test pinned to specific commit #268 Validator does not check that pagination links work #265 available_api_versions is not correctly validated #261 Implementation model should allow for any URL type in source\\_url #260 Extra structure endpoints in the api specification @ odbx #259 Wrong response structure at info endpoint @ cod #258 Missing base url for api's docs @ materialscloud #257 Handling of KNOWN in mongo backend #254 None values in lattice\\_vectors #170 Make sure that the PyPI distribution works #143 Move run.sh to a python file to be environment-agnostic #81 Merged pull requests: Another fix for release pipeline #355 ( shyamd ) Fix publish workflow #354 ( CasperWA ) Fix publish workflow #352 ( CasperWA ) Update publish workflow #340 ( shyamd ) Remove test publish action #338 ( shyamd ) Fix 'publish_TestPyPI' CI job #337 ( CasperWA ) Specify versions for all setup.py deps #336 ( CasperWA ) Represent the datetime objects as UTC in RFC3339 format #333 ( fekad ) dependamat: Bump \\<package_name> v x.y.z to vx.y.(z+1) #330 ( ml-evs ) Bump fastapi from 0.53.1 to 0.56.0 #324 ( dependabot[bot] ) Update links resources #306 ( CasperWA ) Add special species for adapters testing #305 ( CasperWA ) Clean Up Build Environment #301 ( shyamd ) Enable CI failures for linting #300 ( ml-evs ) Adding jarvis-tools structures #297 ( knc6 ) Update Docs #295 ( shyamd ) Setup MKDocs for Documentation #294 ( shyamd ) Fix filters on nested provider/aliased fields #285 ( ml-evs ) Use heroku-shields instead of heroku-badge #284 ( CasperWA ) Add OPTIMADE logo to badge by extending JSON #283 ( CasperWA ) Add null check to mongo filtertransformer for KNOWN/UNKNOWN filters #279 ( ml-evs ) Add sortable=True to all properties #274 ( CasperWA ) Make _atom_site_label unique in CIF generation #272 ( CasperWA ) Not so quick fix to allow \"/\" at end of validator URL, plus fixes and tests for --as_type #267 ( ml-evs ) Check pagination links->next with validator #266 ( ml-evs ) Relax HTTP URL constraints on meta->implementation->source_url field. #262 ( ml-evs ) Validate lattice_vectors for all null or all float #171 ( CasperWA )","title":"v0.9.0 (2020-06-17)"},{"location":"CHANGELOG/#v081-2020-04-25","text":"Full Changelog Fixed bugs: Pip install missing some files #252 Merged pull requests: v0.8.1 hotfix #256 ( ml-evs ) Fix 252 missing landing page #253 ( shyamd )","title":"v0.8.1 (2020-04-25)"},{"location":"CHANGELOG/#v080-2020-04-22","text":"Full Changelog Implemented enhancements: Switch to pydantic's BaseSettings for the config file? #152 Use services for testing/updating dependencies? #96 Remove query constraints for /links-endpoint #244 ( CasperWA ) Add adapters - Base design + 'structures' (+ 'references'... sort of) #241 ( CasperWA ) Add dependabot and last commit date badges #237 ( CasperWA ) Add mongo length operator functionality with length aliases #222 ( ml-evs ) Fixed bugs: Use Path.home() instead of ~ in default config path values #245 Closed issues: Have Dependabot take care of various requirements.txt files as well #249 Remove commented out GH Action job deps\\_clean-install #247 Local testing fails without default config #239 Release only when pushing to master #229 Do we need server.cfg ? #134 Implement LENGTH in query #86 Merged pull requests: Up to v0.8.0 #251 ( CasperWA ) Remove old commented GH Action job #250 ( CasperWA ) Use Path.home() instead of ~ #246 ( CasperWA ) Fix path in default config #243 ( ml-evs ) Fixes Local Tests #240 ( shyamd ) Revert \"Fix github actions for non-release tags\" #236 ( shyamd ) Enable filtering on relationships with mongo #234 ( ml-evs ) Update filter examples and validate optional cases #227 ( ml-evs ) Switch from config init to BaseSettings #226 ( shyamd )","title":"v0.8.0 (2020-04-22)"},{"location":"CHANGELOG/#v071-2020-03-16","text":"Full Changelog Closed issues: Fix all capitalisation of OPTIMADE #232 Remove validator action from README #230 Merged pull requests: Fix github actions for non-release tags #235 ( shyamd ) Update OPTIMADE capitalisation #233 ( ml-evs ) Update mentions of action in readme #231 ( ml-evs )","title":"v0.7.1 (2020-03-16)"},{"location":"CHANGELOG/#v070-2020-03-13","text":"Full Changelog Implemented enhancements: Validate all non-optional :filter: examples from the spec #213 ( ml-evs ) Fixed bugs: Some mandatory filter examples from spec do not work #217 Add txt-files in optimade.validator.data to MANIFEST #225 ( CasperWA ) Handle arbitrary nested NOT/AND/OR in queries #221 ( ml-evs ) Closed issues: Validator only validates what we have working, not what is required by the spec #182 Merged pull requests: v0.7.0 release #228 ( ml-evs ) Remove GH Action to validate OPTiMaDe instances #224 ( CasperWA ) Codecov-action supports token-less uploads #220 ( CasperWA ) Update django requirement from >=2.2.9,~=2.2 to >=2.2,\\<4.0 #219 ( dependabot-preview[bot] ) Update elasticsearch-dsl requirement from ~=6.4 to >=6.4,\\<8.0 #218 ( dependabot-preview[bot] )","title":"v0.7.0 (2020-03-13)"},{"location":"CHANGELOG/#v060-2020-03-06","text":"Full Changelog Implemented enhancements: Possibly add CORS middleware #159 Add debug flag to server #130 Make validator GitHub Action #191 ( CasperWA ) Fixed bugs: meta/query/representation value not cutting off version properly #199 URL for providers.json from Materials-Consortia has changed #186 Relationships don't work when \"/\" present in id #181 Redirect middleware not hitting single-entry endpoints #174 Closed issues: /info/ reports wrong url under available_api_versions #215 Query parameters not handled correctly #208 Test for AvailableApiVersion is correct for the wrong reasons #204 Drop '/optimade' from paths in openapi.json #197 heroku is failing #185 List properties and HAS _ operators missing #98 Checklist for OPTiMaDe v0.10.1 #29 Merged pull requests: Removed /optimade/ prefix in info response #216 ( ml-evs ) Self load data #212 ( shyamd ) Update tests for available_api_versions #211 ( CasperWA ) Up to v0.6.0 #210 ( CasperWA ) Update handling of include parameter (and other query parameters) #209 ( CasperWA ) Skip HAS ONLY test if mongomock version \\<= 3.19.0 #206 ( ml-evs ) Test mandatory queries in validator #205 ( ml-evs ) Fix include query parameter #202 ( CasperWA ) Fix meta.query.representation and remove /optimade in base URLs #201 ( CasperWA ) Use mongo for CI #196 ( ml-evs ) (Cosmetic) updates to models #195 ( CasperWA ) Add CORSMiddleware #194 ( CasperWA ) Add \"debug mode\" #190 ( CasperWA ) Use https://provider.optimade.org/providers.json #187 ( CasperWA ) Fix errors parsing IDs that contain slashes #183 ( ml-evs ) Added default mongo implementations for HAS ALL/ANY/ONLY #173 ( ml-evs )","title":"v0.6.0 (2020-03-06)"},{"location":"CHANGELOG/#v050-2020-02-13","text":"Full Changelog Implemented enhancements: Implement a landing page for requests to the base URL #169 Fixed bugs: 'minor' and 'patch' versioned base URL prefixes are wrong #177 Closed issues: Handle include standard JSON API query parameter #94 Merged pull requests: Bump to v0.5.0 #179 ( CasperWA ) Correctly create optional versioned base URLs #178 ( CasperWA ) Make mapper aliases configurable #175 ( ml-evs ) Add landing page at base URL #172 ( ml-evs ) Implement include query parameter #163 ( CasperWA ) Add docker for index meta-database #140 ( CasperWA )","title":"v0.5.0 (2020-02-13)"},{"location":"CHANGELOG/#v040-2020-02-06","text":"Full Changelog Implemented enhancements: switch to pipenv? #37 Reorder tests #162 ( CasperWA ) Fixed bugs: Server app intermingles #161 response\\_fields not working #154 Closed issues: Change page\\_page to page\\_number #165 Add schema-relevant parameters to query parameters #164 Alias optimade/structures/ to optimade/structure #128 Minor changes to specification v0.10.1-develop #115 Update models with new levels of REQUIRED response properties #114 Constraining list/array types in the schema #55 Merged pull requests: Bump to v0.4.0 #168 ( CasperWA ) Describe query parameters in OpenAPI schema #166 ( CasperWA ) Redirect slashed URLs #160 ( CasperWA ) New REQUIRED level properties #153 ( CasperWA )","title":"v0.4.0 (2020-02-06)"},{"location":"CHANGELOG/#v034-2020-02-04","text":"Full Changelog Implemented enhancements: Include develop or not? Default branch? - Create INSTALL.md #136 Fixed bugs: Excepting non-existent exception #129 Closed issues: disable serving API under /v0.10 and /v0.10.0 by default? #122 PyPI release checklist #67 Merged pull requests: Bump to v0.3.4 #158 ( CasperWA ) Fix heroku badge #157 ( ml-evs ) Move installation instructions #156 ( ml-evs ) Update base URLs #155 ( CasperWA ) Extend OpenAPI/spec description #151 ( CasperWA ) Non Local Mongo #150 ( shyamd )","title":"v0.3.4 (2020-02-04)"},{"location":"CHANGELOG/#v033-2020-01-24","text":"Full Changelog Fixed bugs: Lark files not being distributed #141 Closed issues: Tests fail with lark-parser>=0.8 #146 Merged pull requests: Updated lark-parser to 0.8.1 #149 ( ml-evs ) Split eager and standard tests to avoid unnecessary badge of shame #148 ( ml-evs ) Bump to v0.3.3 #147 ( CasperWA ) Fix root_validator issues with optional fields and made meta optional #145 ( ml-evs ) Handle JSONDecodeError s in validator #144 ( ml-evs )","title":"v0.3.3 (2020-01-24)"},{"location":"CHANGELOG/#v032-2020-01-20","text":"Full Changelog Implemented enhancements: Add base URL to configuration file #135 ( CasperWA ) Fixed bugs: Fix load\\_from\\_json #137 ( CasperWA ) Merged pull requests: Make sure relevant package data is included in distributions #142 ( CasperWA ) Add database page limit #139 ( CasperWA )","title":"v0.3.2 (2020-01-20)"},{"location":"CHANGELOG/#v031-2020-01-17","text":"Full Changelog Merged pull requests: Update requirements #138 ( CasperWA )","title":"v0.3.1 (2020-01-17)"},{"location":"CHANGELOG/#v030-2020-01-14","text":"Full Changelog Implemented enhancements: Implement optional implementation in top-level meta response #117 Create \"special\" index meta-database server #100 Implement relationships in server #71 Add missing /references endpoint to server #69 Automatically publish version tags to PyPI via GH Actions #107 ( CasperWA ) Using routers #99 ( CasperWA ) Add relationships functionality #91 ( ml-evs ) Added external API validator based on our pydantic models #74 ( ml-evs ) Fixed bugs: The invoke task update-openapijson is incomplete #123 Django vulnerability #108 Closed issues: info endpoint duplicated? #120 Commented-out validator #111 FastAPI v0.44.0 supports pydantic > 1.0.0 #101 Server is missing /links endpoint #89 Make sure all validators are tested #87 The sortable field must be added to models #84 Package structure #72 Possibly make /info/{endpoint} dynamic #70 setuptools package with server as \"extra\" #62 use examples from specs as resources #57 httptools dependency has build issues on GCC/Linux #54 Lark grammar file for v0.9.8 #50 type is missing in response #43 Enforce use of autoformatter #33 switch license to MIT #28 write a lark JSONTransformer / JSONdecoder #26 server.jsonapi has no additionalProperties=false #23 server.jsonapi has no patternProperties #22 Developer-friendly pre-commit openapi.json visual diff #21 add JSON schema API #12 generate static documentation on github from openapi.json #9 test how to generate a client from the openapi.json #8 come up with suggested toolchain for validating existing optimade API against openapi.json #7 add travis test that checks openapi.json is valid OpenAPI spec #6 add 2 examples of how to include documentation in python classes #5 add one-line command to update openapi.json #4 Merged pull requests: Fixed CI readme badge #133 ( ml-evs ) Add meta.description to BaseRelationshipResource #131 ( CasperWA ) Added homepage attribute to LinksResource #127 ( ml-evs ) Updated structure models and validators #126 ( ml-evs ) Minor change to fallback server.cfg #125 ( ml-evs ) Update local OpenAPI schemes prior to copying #124 ( CasperWA ) Update OpenAPI tags #121 ( CasperWA ) A few fixes related to usage as a library #119 ( ml-evs ) Add implementation to top-level meta response #118 ( CasperWA ) Add heroku deployment scripts #116 ( ltalirz ) Reorganize package #113 ( CasperWA ) Introduce grammar v0.10.1 #112 ( CasperWA ) Update to pydantic v1 #110 ( CasperWA ) Minimum requirement of django v2.2.8 #109 ( CasperWA ) Index meta-database #103 ( CasperWA ) restrict pydantic version #97 ( ltalirz ) Add /links #95 ( CasperWA ) Fix data_returned and data_available #93 ( CasperWA ) Use GitHub Actions for CI #92 ( ml-evs ) Remove inappropriate lint messages #90 ( CasperWA ) Fix dependencies #88 ( CasperWA ) Add sortable field to EntryInfoProperty model #85 ( CasperWA ) Validate illegal fields are not present under attributes and relationships #83 ( CasperWA ) Add references endpoint #78 ( CasperWA ) fix travis build #77 ( ltalirz ) Fix manual verification of elements_ratios #76 ( CasperWA ) add automatic PyPI deployment #75 ( ltalirz ) Updates to README and docs for v0.10.0 #68 ( ml-evs ) Adding grammar for v0.10.0 #66 ( fekad )","title":"v0.3.0 (2020-01-14)"},{"location":"CHANGELOG/#v012-2018-06-14","text":"Full Changelog","title":"v0.1.2 (2018-06-14)"},{"location":"CHANGELOG/#v011-2018-06-13","text":"Full Changelog","title":"v0.1.1 (2018-06-13)"},{"location":"CHANGELOG/#v010-2018-06-05","text":"Full Changelog * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.0 (2018-06-05)"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 The Materials Consortia is very open to contributions to this package. This may be anything from simple feedback and raising new issues to creating new PRs . Recommendations for setting up a development environment can be found in the Installation instructions . Getting Started with Filter Parsing and Transforming \u00b6 Example use: from optimade.filterparser import LarkParser p = LarkParser ( version = ( 1 , 0 , 0 )) tree = p . parse ( \"nelements<3\" ) print ( tree ) Tree ( 'filter' , [ Tree ( 'expression' , [ Tree ( 'expression_clause' , [ Tree ( 'expression_phrase' , [ Tree ( 'comparison' , [ Tree ( 'property_first_comparison' , [ Tree ( 'property' , [ Token ( 'IDENTIFIER' , 'nelements' )]) , Tree ( 'value_op_rhs' , [ Token ( 'OPERATOR' , '<' ) , Tree ( 'value' , [ Tree ( 'number' , [ Token ( 'SIGNED_INT' , '3' )])])])])])])])])]) print ( tree . pretty ()) filter expression expression_clause expression_phrase comparison property_first_comparison property nelements value_op_rhs < value number 3 tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) print ( tree . pretty ()) filter expression expression_clause expression_phrase comparison property_first_comparison property _mp_bandgap value_op_rhs > value number 5 .0 expression_phrase comparison property_first_comparison property _cod_molecular_weight value_op_rhs < value number 350 Flow for Parsing User-Supplied Filter and Converting to Backend Query \u00b6 optimade.filterparser.LarkParser will take user input to generate a lark.Tree and feed that to a lark.Transformer . E.g., optimade.filtertransformers.mongo.MongoTransformer will turn the tree into something useful for your MongoDB backend: # Example: Converting to MongoDB Query Syntax from optimade.filtertransformers.mongo import MongoTransformer transformer = MongoTransformer () tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) query = transformer . transform ( tree ) print ( query ) { \"$and\" : [ { \"_mp_bandgap\" : { \"$gt\" : 5.0 }}, { \"_cod_molecular_weight\" : { \"$lt\" : 350.0 }} ] } Developing New Filter Transformers \u00b6 If you would like to add a new transformer, please raise an issue to signal your intent (in case someone else is already working on this). Adding a transformer requires the following: A new submodule ( .py file) in the optimade/filtertransformers folder containing an implementation of the transformer object, preferably one that extends optimade.filtertransformers.base_transformer.BaseTransformer . Any additional Python requirements must be optional and provided as a separate \" extra_requires \" entry in setup.py and in the requirements.txt file. Tests in optimade/filtertransformers/tests that are skipped if the required packages fail to import. For examples, please check out existing filter transformers.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"The Materials Consortia is very open to contributions to this package. This may be anything from simple feedback and raising new issues to creating new PRs . Recommendations for setting up a development environment can be found in the Installation instructions .","title":"Contributing"},{"location":"CONTRIBUTING/#getting-started-with-filter-parsing-and-transforming","text":"Example use: from optimade.filterparser import LarkParser p = LarkParser ( version = ( 1 , 0 , 0 )) tree = p . parse ( \"nelements<3\" ) print ( tree ) Tree ( 'filter' , [ Tree ( 'expression' , [ Tree ( 'expression_clause' , [ Tree ( 'expression_phrase' , [ Tree ( 'comparison' , [ Tree ( 'property_first_comparison' , [ Tree ( 'property' , [ Token ( 'IDENTIFIER' , 'nelements' )]) , Tree ( 'value_op_rhs' , [ Token ( 'OPERATOR' , '<' ) , Tree ( 'value' , [ Tree ( 'number' , [ Token ( 'SIGNED_INT' , '3' )])])])])])])])])]) print ( tree . pretty ()) filter expression expression_clause expression_phrase comparison property_first_comparison property nelements value_op_rhs < value number 3 tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) print ( tree . pretty ()) filter expression expression_clause expression_phrase comparison property_first_comparison property _mp_bandgap value_op_rhs > value number 5 .0 expression_phrase comparison property_first_comparison property _cod_molecular_weight value_op_rhs < value number 350","title":"Getting Started with Filter Parsing and Transforming"},{"location":"CONTRIBUTING/#flow-for-parsing-user-supplied-filter-and-converting-to-backend-query","text":"optimade.filterparser.LarkParser will take user input to generate a lark.Tree and feed that to a lark.Transformer . E.g., optimade.filtertransformers.mongo.MongoTransformer will turn the tree into something useful for your MongoDB backend: # Example: Converting to MongoDB Query Syntax from optimade.filtertransformers.mongo import MongoTransformer transformer = MongoTransformer () tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) query = transformer . transform ( tree ) print ( query ) { \"$and\" : [ { \"_mp_bandgap\" : { \"$gt\" : 5.0 }}, { \"_cod_molecular_weight\" : { \"$lt\" : 350.0 }} ] }","title":"Flow for Parsing User-Supplied Filter and Converting to Backend Query"},{"location":"CONTRIBUTING/#developing-new-filter-transformers","text":"If you would like to add a new transformer, please raise an issue to signal your intent (in case someone else is already working on this). Adding a transformer requires the following: A new submodule ( .py file) in the optimade/filtertransformers folder containing an implementation of the transformer object, preferably one that extends optimade.filtertransformers.base_transformer.BaseTransformer . Any additional Python requirements must be optional and provided as a separate \" extra_requires \" entry in setup.py and in the requirements.txt file. Tests in optimade/filtertransformers/tests that are skipped if the required packages fail to import. For examples, please check out existing filter transformers.","title":"Developing New Filter Transformers"},{"location":"INSTALL/","text":"Installation \u00b6 The index meta-database \u00b6 This package may be used to setup and run an OPTIMADE index meta-database . Install the package via pip install optimade[server] . There is a built-in index meta-database set up to populate a mongomock in-memory database with resources from a static json file containing the child resources you, as a database provider, want to serve under this index meta-database. The location of that json file is controllable using the index_links_path property of the configuration or setting via the environment variable optimade_index_links_path . Running the index meta-database is then as simple as writing ./run.sh index in a terminal from the root of this package. You can find it at the base URL: http://localhost:5001/v1 . Here is an example of how it may look to start your server: :~$ export OPTIMADE_CONFIG_FILE = /home/optimade_server/config.json :~$ ./path/to/optimade/run.sh index Full development installation \u00b6 The dependencies of this package can be found in setup.py with their latest supported versions. By default, a minimal set of requirements are installed to work with the filter language and the pydantic models. The install mode server (i.e. pip install .[server] ) is sufficient to run a uvicorn server using the mongomock backend (or MongoDB with pymongo , if present). The suite of development and testing tools are installed with via the install modes dev and testing . There are additionally three backend-specific install modes, django , elastic and mongo , as well as the all mode, which installs all dependencies. All contributed Python code, must use the black code formatter, and must pass the flake8 linter that is run automatically on all PRs. # Clone this repository to your computer git clone git@github.com:Materials-Consortia/optimade-python-tools.git cd optimade-python-tools # Ensure a Python>=3.7 (virtual) environment (example below using Anaconda/Miniconda) conda create -n optimade python = 3 .7 conda activate optimade # Install package and dependencies in editable mode (including \"dev\" requirements). pip install -e \".[dev]\" # Run the tests with pytest py.test # Install pre-commit environment (e.g., auto-formats code on `git commit`) pre-commit install # Optional: Install MongoDB (and set `use_real_mongo = true`) # Below method installs in conda environment and # - starts server in background # - ensures and uses ~/dbdata directory to store data conda install -c anaconda mongodb mkdir -p ~/dbdata && mongod --dbpath ~/dbdata --syslog --fork # Start a development server (auto-reload on file changes at http://localhost:5000 # You can also execute ./run.sh uvicorn optimade.server.main:app --reload --port 5000 # View auto-generated docs open http://localhost:5000/docs # View Open API Schema open http://localhost:5000/openapi.json When developing, you can run both the server and an index meta-database server at the same time (from two separate terminals). Running the following: ./run.sh index # or uvicorn optimade.server.main_index:app --reload --port 5001 will run the index meta-database server at http://localhost:5001/v1 .","title":"Installation"},{"location":"INSTALL/#installation","text":"","title":"Installation"},{"location":"INSTALL/#the-index-meta-database","text":"This package may be used to setup and run an OPTIMADE index meta-database . Install the package via pip install optimade[server] . There is a built-in index meta-database set up to populate a mongomock in-memory database with resources from a static json file containing the child resources you, as a database provider, want to serve under this index meta-database. The location of that json file is controllable using the index_links_path property of the configuration or setting via the environment variable optimade_index_links_path . Running the index meta-database is then as simple as writing ./run.sh index in a terminal from the root of this package. You can find it at the base URL: http://localhost:5001/v1 . Here is an example of how it may look to start your server: :~$ export OPTIMADE_CONFIG_FILE = /home/optimade_server/config.json :~$ ./path/to/optimade/run.sh index","title":"The index meta-database"},{"location":"INSTALL/#full-development-installation","text":"The dependencies of this package can be found in setup.py with their latest supported versions. By default, a minimal set of requirements are installed to work with the filter language and the pydantic models. The install mode server (i.e. pip install .[server] ) is sufficient to run a uvicorn server using the mongomock backend (or MongoDB with pymongo , if present). The suite of development and testing tools are installed with via the install modes dev and testing . There are additionally three backend-specific install modes, django , elastic and mongo , as well as the all mode, which installs all dependencies. All contributed Python code, must use the black code formatter, and must pass the flake8 linter that is run automatically on all PRs. # Clone this repository to your computer git clone git@github.com:Materials-Consortia/optimade-python-tools.git cd optimade-python-tools # Ensure a Python>=3.7 (virtual) environment (example below using Anaconda/Miniconda) conda create -n optimade python = 3 .7 conda activate optimade # Install package and dependencies in editable mode (including \"dev\" requirements). pip install -e \".[dev]\" # Run the tests with pytest py.test # Install pre-commit environment (e.g., auto-formats code on `git commit`) pre-commit install # Optional: Install MongoDB (and set `use_real_mongo = true`) # Below method installs in conda environment and # - starts server in background # - ensures and uses ~/dbdata directory to store data conda install -c anaconda mongodb mkdir -p ~/dbdata && mongod --dbpath ~/dbdata --syslog --fork # Start a development server (auto-reload on file changes at http://localhost:5000 # You can also execute ./run.sh uvicorn optimade.server.main:app --reload --port 5000 # View auto-generated docs open http://localhost:5000/docs # View Open API Schema open http://localhost:5000/openapi.json When developing, you can run both the server and an index meta-database server at the same time (from two separate terminals). Running the following: ./run.sh index # or uvicorn optimade.server.main_index:app --reload --port 5001 will run the index meta-database server at http://localhost:5001/v1 .","title":"Full development installation"},{"location":"all_models/","text":"All models \u00b6 baseinfo \u00b6 AvailableApiVersion ( BaseModel ) pydantic-model \u00b6 A JSON object containing information about an available API version url : AnyHttpUrl pydantic-field required \u00b6 A string specifying a versioned base URL that MUST adhere to the rules in section Base URL version : SemanticVersion pydantic-field required \u00b6 A string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'. Examples: 1.0.0 , 1.0.0-rc.2 . crosscheck_url_and_version ( values ) classmethod \u00b6 Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) # as with version urls, we need to split any release tags or build metadata out of these URLs url_version = tuple ( int ( val ) for val in url_version . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values url_must_be_versioned_base_url ( v ) classmethod \u00b6 The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v BaseInfoAttributes ( BaseModel ) pydantic-model \u00b6 Attributes for Base URL Info endpoint api_version : SemanticVersion pydantic-field required \u00b6 Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 . available_api_versions : List [ optimade . models . baseinfo . AvailableApiVersion ] pydantic-field required \u00b6 A list of dictionaries of available API versions at other base URLs available_endpoints : List [ str ] pydantic-field required \u00b6 List of available endpoints (i.e., the string to be appended to the versioned base URL). entry_types_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 Available entry endpoints as a function of output formats. formats : List [ str ] pydantic-field \u00b6 List of available output formats. is_index : bool pydantic-field \u00b6 If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false ). entries \u00b6 EntryInfoProperty ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 A human-readable description of the entry property sortable : bool pydantic-field \u00b6 Defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true . type : DataType pydantic-field \u00b6 The type of the property's value. This MUST be any of the types defined in the Data types section. For the purpose of compatibility with future versions of this specification, a client MUST accept values that are not string values specifying any of the OPTIMADE Data types, but MUST then also disregard the type field. Note, if the value is a nested type, only the outermost type should be reported. E.g., for the entry resource structures , the species property is defined as a list of dictionaries, hence its type value would be list . unit : str pydantic-field \u00b6 The physical unit of the entry property. This MUST be a valid representation of units according to version 2.1 of The Unified Code for Units of Measure . It is RECOMMENDED that non-standard (non-SI) units are described in the description for the property. EntryInfoResource ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 Description of the entry. formats : List [ str ] pydantic-field required \u00b6 List of output formats available for this type of entry. output_fields_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 Dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary. properties : Dict [ str , optimade . models . entries . EntryInfoProperty ] pydantic-field required \u00b6 A dictionary describing queryable properties for this entry type, where each key is a property name. EntryRelationships ( Relationships ) pydantic-model \u00b6 This model wraps the JSON API Relationships to include type-specific top level keys. references : ReferenceRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the references type. structures : StructureRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the structures type. EntryResource ( Resource ) pydantic-model \u00b6 The base model for an entry resource. EntryResourceAttributes ( Attributes ) pydantic-model \u00b6 Contains key-value pairs representing the entry's properties. immutable_id : str pydantic-field \u00b6 The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. Type : string. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.) last_modified : datetime pydantic-field required \u00b6 Date and time representing when the entry was last modified. Type : timestamp. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter response_fields is present and does not include this property. Example : As part of JSON response format: \"2007-04-05T14:30:20Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format string.) index_metadb \u00b6 DefaultRelationship ( Enum ) \u00b6 Enumeration of key(s) for relationship dictionary in IndexInfoResource IndexInfoAttributes ( BaseInfoAttributes ) pydantic-model \u00b6 Attributes for Base URL Info endpoint for an Index Meta-Database IndexInfoResource ( BaseInfoResource ) pydantic-model \u00b6 Index Meta-Database Base URL Info endpoint resource IndexRelationship ( BaseModel ) pydantic-model \u00b6 Index Meta-Database relationship data : RelatedLinksResource pydantic-field required \u00b6 JSON API resource linkage . It MUST be either null or contain a single Links identifier object with the fields id and type RelatedLinksResource ( BaseResource ) pydantic-model \u00b6 A related Links resource object jsonapi \u00b6 This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/ Attributes ( BaseModel ) pydantic-model \u00b6 Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type BaseResource ( BaseModel ) pydantic-model \u00b6 Minimum requirements to represent a Resource id : str pydantic-field required \u00b6 Resource ID type : str pydantic-field required \u00b6 Resource type Config \u00b6 schema_extra ( schema , model ) staticmethod \u00b6 Ensure id and type are the first two entries in the list required properties. Note This requires that id and type are the first model fields defined for all sub-models of BaseResource . Source code in optimade/models/jsonapi.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"BaseResource\" ]) -> None : \"\"\"Ensure `id` and `type` are the first two entries in the list required properties. Note: This _requires_ that `id` and `type` are the _first_ model fields defined for all sub-models of `BaseResource`. \"\"\" if \"id\" not in schema . get ( \"required\" , []): schema [ \"required\" ] = [ \"id\" ] + schema . get ( \"required\" , []) if \"type\" not in schema . get ( \"required\" , []): required = [] for field in schema . get ( \"required\" , []): required . append ( field ) if field == \"id\" : # To make sure the property order match the listed properties, # this ensures \"type\" is added immediately after \"id\". required . append ( \"type\" ) schema [ \"required\" ] = required Error ( BaseModel ) pydantic-model \u00b6 An error response code : str pydantic-field \u00b6 an application-specific error code, expressed as a string value. detail : str pydantic-field \u00b6 A human-readable explanation specific to this occurrence of the problem. id : str pydantic-field \u00b6 A unique identifier for this particular occurrence of the problem. links : ErrorLinks pydantic-field \u00b6 A links object storing about meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the error. source : ErrorSource pydantic-field \u00b6 An object containing references to the source of the error status : str pydantic-field \u00b6 the HTTP status code applicable to this problem, expressed as a string value. title : str pydantic-field \u00b6 A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization. __hash__ ( self ) special \u00b6 Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ()) ErrorLinks ( BaseModel ) pydantic-model \u00b6 A Links object specific to Error objects about : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that leads to further details about this particular occurrence of the problem. ErrorSource ( BaseModel ) pydantic-model \u00b6 an object containing references to the source of the error parameter : str pydantic-field \u00b6 a string indicating which URI query parameter caused the error. pointer : str pydantic-field \u00b6 a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute]. JsonApi ( BaseModel ) pydantic-model \u00b6 An object describing the server's implementation meta : Meta pydantic-field \u00b6 Non-standard meta information version : str pydantic-field \u00b6 Version of the json API used Link ( BaseModel ) pydantic-model \u00b6 A link MUST be represented as either: a string containing the link's URL or a link object. href : AnyUrl pydantic-field required \u00b6 a string containing the link\u2019s URL. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the link. Meta ( BaseModel ) pydantic-model \u00b6 Non-standard meta-information that can not be represented as an attribute or relationship. Relationship ( BaseModel ) pydantic-model \u00b6 Representation references from the resource object in which it\u2019s defined to other resource objects. data : Union [ optimade . models . jsonapi . BaseResource , List [ optimade . models . jsonapi . BaseResource ]] pydantic-field \u00b6 Resource linkage links : RelationshipLinks pydantic-field \u00b6 a links object containing at least one of the following: self, related meta : Meta pydantic-field \u00b6 a meta object that contains non-standard meta-information about the relationship. RelationshipLinks ( BaseModel ) pydantic-model \u00b6 A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object. related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link . self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link for the relationship itself (a 'relationship link'). This link allows the client to directly manipulate the relationship. When fetched successfully, this link returns the linkage for the related resources as its primary data. (See Fetching Relationships .) Relationships ( BaseModel ) pydantic-model \u00b6 Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id Resource ( BaseResource ) pydantic-model \u00b6 Resource objects appear in a JSON API document to represent resources. attributes : Attributes pydantic-field \u00b6 an attributes object representing some of the resource\u2019s data. links : ResourceLinks pydantic-field \u00b6 a links object containing links related to the resource. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship. relationships : Relationships pydantic-field \u00b6 Relationships object describing relationships between the resource and other JSON API resources. ResourceLinks ( BaseModel ) pydantic-model \u00b6 A Resource Links object self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that identifies the resource represented by the resource object. Response ( BaseModel ) pydantic-model \u00b6 A top-level response data : Union [ NoneType , optimade . models . jsonapi . Resource , List [ optimade . models . jsonapi . Resource ]] pydantic-field \u00b6 Outputted Data errors : List [ optimade . models . jsonapi . Error ] pydantic-field \u00b6 A list of unique errors included : List [ optimade . models . jsonapi . Resource ] pydantic-field \u00b6 A list of unique included resources jsonapi : JsonApi pydantic-field \u00b6 Information about the JSON API used links : ToplevelLinks pydantic-field \u00b6 Links associated with the primary data or errors meta : Meta pydantic-field \u00b6 A meta object containing non-standard information related to the Success Config \u00b6 The specification mandates that datetimes must be encoded following RFC3339 , which does not support fractional seconds, thus they must be stripped in the response. This can cause issues when the underlying database contains fields that do include microseconds, as filters may return unexpected results. ToplevelLinks ( BaseModel ) pydantic-model \u00b6 A set of Links objects, possibly including pagination first : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The first page of data last : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The last page of data next : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The next page of data prev : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The previous page of data related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link to itself check_additional_keys_are_links ( values ) classmethod \u00b6 The ToplevelLinks class allows any additional keys, as long as they are also Links or Urls themselves. Source code in optimade/models/jsonapi.py @root_validator ( pre = False ) def check_additional_keys_are_links ( cls , values ): \"\"\"The `ToplevelLinks` class allows any additional keys, as long as they are also Links or Urls themselves. \"\"\" for key , value in values . items (): if key not in cls . schema ()[ \"properties\" ]: values [ key ] = parse_obj_as ( Optional [ Union [ AnyUrl , Link ]], value ) return values links \u00b6 Aggregate ( Enum ) \u00b6 Enumeration of aggregate values LinkType ( Enum ) \u00b6 Enumeration of link_type values LinksResource ( EntryResource ) pydantic-model \u00b6 A Links endpoint resource object LinksResourceAttributes ( Attributes ) pydantic-model \u00b6 Links endpoint resource object attributes aggregate : Aggregate pydantic-field \u00b6 A string indicating whether a client that is following links to aggregate results from different OPTIMADE implementations should follow this link or not. This flag SHOULD NOT be indicated for links where link_type is not child . If not specified, clients MAY assume that the value is ok . If specified, and the value is anything different than ok , the client MUST assume that the server is suggesting not to follow the link during aggregation by default (also if the value is not among the known ones, in case a future specification adds new accepted values). Specific values indicate the reason why the server is providing the suggestion. A client MAY follow the link anyway if it has reason to do so (e.g., if the client is looking for all test databases, it MAY follow the links marked with aggregate = test ). If specified, it MUST be one of the values listed in section Link Aggregate Options. base_url : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to the base URL for this implementation description : str pydantic-field required \u00b6 Human-readable description for the OPTIMADE API implementation, e.g., for use in clients to show a description to the end-user. homepage : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to a homepage URL for this implementation link_type : LinkType pydantic-field required \u00b6 The type of the linked relation. MUST be one of these values: 'child', 'root', 'external', 'providers'. name : str pydantic-field required \u00b6 Human-readable name for the OPTIMADE API implementation, e.g., for use in clients to show the name to the end-user. no_aggregate_reason : str pydantic-field \u00b6 An OPTIONAL human-readable string indicating the reason for suggesting not to aggregate results following the link. It SHOULD NOT be present if aggregate = ok . optimade_json \u00b6 Modified JSON API v1.0 for OPTIMADE API BaseRelationshipMeta ( Meta ) pydantic-model \u00b6 Specific meta field for base relationship resource description : str pydantic-field required \u00b6 OPTIONAL human-readable description of the relationship BaseRelationshipResource ( BaseResource ) pydantic-model \u00b6 Minimum requirements to represent a relationship resource meta : BaseRelationshipMeta pydantic-field \u00b6 Relationship meta field. MUST contain 'description' if supplied. DataType ( Enum ) \u00b6 Optimade Data Types See the section \"Data types\" in the OPTIMADE API specification for more information. Implementation ( BaseModel ) pydantic-model \u00b6 Information on the server implementation homepage : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A JSON API links object pointing to the homepage of the implementation. maintainer : ImplementationMaintainer pydantic-field \u00b6 A dictionary providing details about the maintainer of the implementation. name : str pydantic-field \u00b6 name of the implementation source_url : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A JSON API links object pointing to the implementation source, either downloadable archive or version control system. version : str pydantic-field \u00b6 version string of the current implementation ImplementationMaintainer ( BaseModel ) pydantic-model \u00b6 Details about the maintainer of the implementation email : EmailStr pydantic-field required \u00b6 the maintainer's email address OptimadeError ( Error ) pydantic-model \u00b6 detail MUST be present Provider ( BaseModel ) pydantic-model \u00b6 Information on the database provider of the implementation. description : str pydantic-field required \u00b6 a longer description of the database provider homepage : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object. name : str pydantic-field required \u00b6 a short name for the database provider prefix : ConstrainedStrValue pydantic-field required \u00b6 database-provider-specific prefix as found in section Database-Provider-Specific Namespace Prefixes. Relationship ( Relationship ) pydantic-model \u00b6 Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource ResponseMeta ( Meta ) pydantic-model \u00b6 A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix. api_version : SemanticVersion pydantic-field required \u00b6 Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 . data_available : int pydantic-field \u00b6 An integer containing the total number of data resource objects available in the database for the endpoint. data_returned : ConstrainedIntValue pydantic-field \u00b6 An integer containing the total number of data resource objects returned for the current filter query, independent of pagination. implementation : Implementation pydantic-field \u00b6 a dictionary describing the server implementation last_id : str pydantic-field \u00b6 a string containing the last ID returned more_data_available : bool pydantic-field required \u00b6 false if the response contains all data for the request (e.g., a request issued to a single entry endpoint, or a filter query at the last page of a paginated response) and true if the response is incomplete in the sense that multiple objects match the request, and not all of them have been included in the response (e.g., a query with multiple pages that is not at the last page). optimade_schema : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A JSON API links object that points to a schema for the response. If it is a string, or a dictionary containing no meta field, the provided URL MUST point at an OpenAPI schema. It is possible that future versions of this specification allows for alternative schema types. Hence, if the meta field of the JSON API links object is provided and contains a field schema_type that is not equal to the string OpenAPI the client MUST not handle failures to parse the schema or to validate the response against the schema as errors. provider : Provider pydantic-field \u00b6 information on the database provider of the implementation. query : ResponseMetaQuery pydantic-field required \u00b6 Information on the Query that was requested response_message : str pydantic-field \u00b6 response string from the server time_stamp : datetime pydantic-field \u00b6 A timestamp containing the date and time at which the query was executed. warnings : List [ optimade . models . optimade_json . Warnings ] pydantic-field \u00b6 A list of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \"warning\" . The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status , representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects. ResponseMetaQuery ( BaseModel ) pydantic-model \u00b6 Information on the query that was requested. representation : str pydantic-field required \u00b6 A string with the part of the URL following the versioned or unversioned base URL that serves the API. Query parameters that have not been used in processing the request MAY be omitted. In particular, if no query parameters have been involved in processing the request, the query part of the URL MAY be excluded. Example: /structures?filter=nelements=2 Success ( Response ) pydantic-model \u00b6 errors are not allowed either_data_meta_or_errors_must_be_set ( values ) classmethod \u00b6 Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values Warnings ( OptimadeError ) pydantic-model \u00b6 OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class. type : str pydantic-field \u00b6 Warnings must be of type \"warning\" Config \u00b6 schema_extra ( schema , model ) staticmethod \u00b6 Update OpenAPI JSON schema model for Warning . Ensure type is in the list required properties and in the correct place. Remove status property. This property is not allowed for Warning , nor is it a part of the OPTIMADE definition of the Warning object. Note Since type is the last model field defined, it will simply be appended. Source code in optimade/models/optimade_json.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"Warnings\" ]) -> None : \"\"\"Update OpenAPI JSON schema model for `Warning`. * Ensure `type` is in the list required properties and in the correct place. * Remove `status` property. This property is not allowed for `Warning`, nor is it a part of the OPTIMADE definition of the `Warning` object. Note: Since `type` is the _last_ model field defined, it will simply be appended. \"\"\" if \"required\" in schema : if \"type\" not in schema [ \"required\" ]: schema [ \"required\" ] . append ( \"type\" ) else : schema [ \"required\" ] = [ \"type\" ] schema . get ( \"properties\" , {}) . pop ( \"status\" , None ) references \u00b6 Person ( BaseModel ) pydantic-model \u00b6 A person, i.e., an author, editor or other. firstname : str pydantic-field \u00b6 First name of the person. lastname : str pydantic-field \u00b6 Last name of the person. name : str pydantic-field required \u00b6 Full name of the person, REQUIRED. ReferenceResource ( EntryResource ) pydantic-model \u00b6 The references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , volume , year : meanings of these properties match the BibTeX specification , values are strings; bib_type : type of the reference, corresponding to type property in the BibTeX specification, value is string; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., any of the properties MAY be null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties. ReferenceResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification . address : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. annote : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. authors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the authors of the reference. bib_type : str pydantic-field \u00b6 Type of the reference, corresponding to the type property in the BiBTeX specification. booktitle : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. chapter : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. crossref : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. doi : str pydantic-field \u00b6 The digital object identifier of the reference. edition : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. editors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the editors of the reference. howpublished : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. institution : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. journal : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. key : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. month : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. note : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. number : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. organization : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. pages : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. publisher : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. school : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. series : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. title : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. url : AnyUrl pydantic-field \u00b6 The URL of the reference. volume : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. year : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. responses \u00b6 ErrorResponse ( Response ) pydantic-model \u00b6 errors MUST be present and data MUST be skipped structures \u00b6 Assembly ( BaseModel ) pydantic-model \u00b6 A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). group_probabilities : List [ float ] pydantic-field required \u00b6 Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species . sites_in_groups : List [ List [ int ]] pydantic-field required \u00b6 Index of the sites (0-based) that belong to each group for each assembly. Examples : [[1], [2]] : two groups, one with the second site, one with the third. [[1,2], [3]] : one group with the second and third site, one with the fourth. Periodicity ( IntEnum ) \u00b6 Integer enumeration of dimension_types values Species ( BaseModel ) pydantic-model \u00b6 A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms. attached : List [ str ] pydantic-field \u00b6 If provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element. chemical_symbols : List [ str ] pydantic-field required \u00b6 MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features . concentration : List [ float ] pydantic-field required \u00b6 MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : List [ float ] pydantic-field \u00b6 If present MUST be a list of floats expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0. name : str pydantic-field required \u00b6 Gives the name of the species; the name value MUST be unique in the species list. nattached : List [ int ] pydantic-field \u00b6 If provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the :field: attached key. original_name : str pydantic-field \u00b6 Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. StructureFeatures ( Enum ) \u00b6 Enumeration of structure_features values StructureResource ( EntryResource ) pydantic-model \u00b6 Representing a structure. StructureResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions. assemblies : List [ optimade . models . structures . Assembly ] pydantic-field \u00b6 A description of groups of sites that are statistically correlated. Type : list of dictionary with keys: sites_in_groups : list of list of integers (REQUIRED) group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. The property SHOULD be null for entries that have no partial occupancies. If present, the correct flag MUST be set in the list structure_features . Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: [[1], [2]] : two groups, one with the second site, one with the third. Example: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species . If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: { \"cartesian_site_positions\" : [[ 0 , 0 , 0 ]], \"species_at_sites\" : [ \"SiGe-vac\" ], \"species\" : [ { \"name\" : \"SiGe-vac\" , \"chemical_symbols\" : [ \"Si\" , \"Ge\" , \"vacancy\" ], \"concentration\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } Using multiple species and the assemblies: { \"cartesian_site_positions\" : [ [ 0 , 0 , 0 ], [ 0 , 0 , 0 ], [ 0 , 0 , 0 ] ], \"species_at_sites\" : [ \"Si\" , \"Ge\" , \"vac\" ], \"species\" : [ { \"name\" : \"Si\" , \"chemical_symbols\" : [ \"Si\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"Ge\" , \"chemical_symbols\" : [ \"Ge\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"vac\" , \"chemical_symbols\" : [ \"vacancy\" ], \"concentration\" : [ 1.0 ] } }, \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ], [ 2 ] ], \"group_probabilities\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: { \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ] ], \"group_probabilities\" : [ 0.2 , 0.8 ], }, { \"sites_in_groups\" : [ [ 2 ], [ 3 ] ], \"group_probabilities\" : [ 0.3 , 0.7 ] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability). cartesian_site_positions : List [ types . ConstrainedListValue ] pydantic-field required \u00b6 Cartesian positions of each site in the structure. A site is usually used to describe positions of atoms; what atoms can be encountered at a given site is conveyed by the species_at_sites property, and the species themselves are described in the species property. Type : list of list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length equal to the number of sites in the structure, where every element is a list of the three Cartesian coordinates of a site expressed as float values in the unit angstrom (\u00c5). An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies ). Examples : [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin. chemical_formula_anonymous : ConstrainedStrValue pydantic-field required \u00b6 The anonymous formula is the chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : \"A2B\" \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is chemical_formula_anonymous=\"A2B\" . chemical_formula_descriptive : str pydantic-field required \u00b6 The chemical formula for a structure as a string in a form chosen by the API implementation. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry . Examples : \"(H2O)2 Na\" \"NaCl\" \"CaCO3\" \"CCaO3\" \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: chemical_formula_descriptive CONTAINS \"H2O\" . chemical_formula_hill : ConstrainedStrValue pydantic-field \u00b6 The chemical formula for a structure in Hill form with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, only a subset of the filter features MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, chemical_formula_hill is \"H2O2\" (i.e., not \"HO\" , nor \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in Hill order , followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : \"H2O2\" Query examples : A filter that matches an exactly given formula is chemical_formula_hill=\"H2O2\" . chemical_formula_reduced : ConstrainedStrValue pydantic-field required \u00b6 The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate queries on formula components are instead suggested to be formulated using set-type filter operators on the multi valued elements and elements_ratios properties. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : \"H2NaO\" \"ClNa\" \"CCaO3\" Query examples : A filter that matches an exactly given formula is chemical_formula_reduced=\"H2NaO\" . dimension_types : ConstrainedListValue pydantic-field \u00b6 List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ), this list indicates if the direction is periodic (value 1 ) or non-periodic (value 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in lattice_vectors and not the Cartesian x, y, z directions. Type : list of integers. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: [0, 0, 0] For a wire along the direction specified by the third lattice vector: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: [1, 0, 1] For a bulk 3D system: [1, 1, 1] elements : List [ str ] pydantic-field required \u00b6 Names of the different elements present in the structure. Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The strings are the chemical symbols, i.e., either a single uppercase letter or an uppercase letter followed by a number of lowercase letters. The order MUST be alphabetical. Note: This property SHOULD NOT contain the string \"X\" to indicate non-chemical elements or \"vacancy\" to indicate vacancies (in contrast to the field chemical_symbols for the species property). Examples : [\"Si\"] [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use elements HAS ALL \"Si\", \"Al\", \"O\" AND elements LENGTH 3 . elements_ratios : List [ float ] pydantic-field required \u00b6 Relative proportions of different elements in the structure. Type : list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : [1.0] [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: Useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally inadvisable. OPTIONAL: a filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 . lattice_vectors : ConstrainedListValue pydantic-field \u00b6 The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). Type : list of list of floats or unknown values. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. MUST always contain three vectors of three coordinates each, independently of the elements of property dimension_types . The vectors SHOULD by convention be chosen so the determinant of the lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. The coordinates of the lattice vectors of non-periodic dimensions (i.e., those dimensions for which dimension_types is 0 ) MAY be given as a list of all null values. If a lattice vector contains the value null , all coordinates of that lattice vector MUST be null . Examples : [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is (4, 0, 0) , i.e., a vector aligned along the x axis of length 4 \u00c5; the second vector is (0, 4, 0) ; and the third vector is (0, 1, 4) . nelements : int pydantic-field required \u00b6 Number of different elements in the structure as an integer. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 3 Querying : Note: queries on this property can equivalently be formulated using elements LENGTH . A filter that matches structures that have exactly 4 elements: nelements=4 . A filter that matches structures that have between 2 and 7 elements: nelements>=2 AND nelements<=7 . nperiodic_dimensions : int pydantic-field required \u00b6 An integer specifying the number of periodic dimensions in the structure, equivalent to the number of non-zero entries in dimension_types . Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The integer value MUST be between 0 and 3 inclusive and MUST be equal to the sum of the items in the dimension_types property. This property only reflects the treatment of the lattice vectors provided for the structure, and not any physical interpretation of the dimensionality of its contents. Examples : 2 should be indicated in cases where dimension_types is any of [1, 1, 0] , [1, 0, 1] , [0, 1, 1] . Query examples : Match only structures with exactly 3 periodic dimensions: nperiodic_dimensions=3 Match all structures with 2 or fewer periodic dimensions: nperiodic_dimensions<=2 nsites : int pydantic-field required \u00b6 An integer specifying the length of the cartesian_site_positions property. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 42 Query examples : Match only structures with exactly 4 sites: nsites=4 Match structures that have between 2 and 7 sites: nsites>=2 AND nsites<=7 species : List [ optimade . models . structures . Species ] pydantic-field required \u00b6 A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Type : list of dictionary with keys: name : string (REQUIRED) chemical_symbols : list of strings (REQUIRED) concentration : list of float (REQUIRED) attached : list of strings (REQUIRED) nattached : list of integers (OPTIONAL) mass : list of floats (OPTIONAL) original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features . concentration : REQUIRED; MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different sites (even of the same species). attached : OPTIONAL; if provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element. nattached : OPTIONAL; if provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the attached key. The implementation MUST include either both or none of the attached and nattached keys, and if they are provided, they MUST be of the same length. Furthermore, if they are provided, the structure_features property MUST include the string site_attachments . mass : OPTIONAL. If present MUST be a list of floats, with the same length as chemical_symbols , providing element masses expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites ). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., \"Ti\" for titanium, \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms. species_at_sites : List [ str ] pydantic-field required \u00b6 Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions ). Each species name mentioned in the species_at_sites list MUST be described in the list property species (i.e. for each value in the species_at_sites list there MUST exist exactly one dictionary in the species list with the name attribute equal to the corresponding species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled \"Ti\" and the second a species labeled \"O2\" . [\"Ac\", \"Ac\", \"Ag\", \"Ir\"] indicating the first two sites contains the \"Ac\" species, while the third and fourth sites contain the \"Ag\" and \"Ir\" species, respectively. structure_features : List [ optimade . models . structures . StructureFeatures ] pydantic-field required \u00b6 A list of strings that flag which special features are used by the structure. Type : list of strings Requirements/Conventions : Support : MUST be supported by all implementations, MUST NOT be null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : disorder : this flag MUST be present if any one entry in the species list has a chemical_symbols list that is longer than 1 element. implicit_atoms : this flag MUST be present if the structure contains atoms that are not assigned to sites via the property species_at_sites (e.g., because their positions are unknown). When this flag is present, the properties related to the chemical formula will likely not match the type and count of atoms represented by the species_at_sites , species and assemblies properties. site_attachments : this flag MUST be present if any one entry in the species list includes attached and nattached . assemblies : this flag MUST be present if the property assemblies is present. Examples : A structure having implicit atoms and using assemblies: [\"assemblies\", \"implicit_atoms\"] Config \u00b6 schema_extra ( schema , model ) \u00b6 Two things need to be added to the schema: Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, dimension_types and lattice_vectors , are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be nullable according to the OpenAPI definition. Source code in optimade/models/structures.py def schema_extra ( schema , model ): \"\"\"Two things need to be added to the schema: 1. Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, `dimension_types` and `lattice_vectors`, are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. 2. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be `nullable` according to the OpenAPI definition. \"\"\" schema [ \"required\" ] . insert ( 7 , \"dimension_types\" ) schema [ \"required\" ] . insert ( 9 , \"lattice_vectors\" ) nullable_props = ( prop for prop in schema [ \"required\" ] if schema [ \"properties\" ][ prop ] . get ( \"support\" ) == SupportLevel . SHOULD ) for prop in nullable_props : schema [ \"properties\" ][ prop ][ \"nullable\" ] = True warn_on_missing_correlated_fields ( values ) classmethod \u00b6 Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. Source code in optimade/models/structures.py @root_validator ( pre = True ) def warn_on_missing_correlated_fields ( cls , values ): \"\"\"Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. \"\"\" accumulated_warnings = [] for field_set in CORRELATED_STRUCTURE_FIELDS : missing_fields = { f for f in field_set if values . get ( f ) is None } if missing_fields and len ( missing_fields ) != len ( field_set ): accumulated_warnings += [ f \"Structure with values { values } is missing fields { missing_fields } which are required if { field_set - missing_fields } are present.\" ] for warn in accumulated_warnings : warnings . warn ( warn , MissingExpectedField ) return values utils \u00b6 ANONYMOUS_ELEMENTS \u00b6 Returns the first 150 values of the anonymous element generator. SemanticVersion ( str ) \u00b6 A custom type for a semantic version, using the recommended semver regexp from https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string. base_version : str property readonly \u00b6 The base version string without patch and metadata info. build_metadata : str property readonly \u00b6 The build metadata. major : int property readonly \u00b6 The major version number. minor : int property readonly \u00b6 The minor version number. patch : int property readonly \u00b6 The patch version number. prerelease : str property readonly \u00b6 The pre-release tag. SupportLevel ( Enum ) \u00b6 OPTIMADE property/field support levels OptimadeField ( * args , * , support = None , queryable = None , unit = None , ** kwargs ) \u00b6 A wrapper around pydantic.Field that adds OPTIMADE-specific field paramters queryable , support and unit , indicating the corresponding support level in the specification and the physical unit of the field. Parameters: Name Type Description Default support Optional[optimade.models.utils.SupportLevel] The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. None queryable Optional[optimade.models.utils.SupportLevel] The support level corresponding to the queryablility of this field. None unit Optional[str] A string describing the unit of the field. None Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic field with extra validation provided by StrictField . Source code in optimade/models/utils.py def OptimadeField ( * args , support : Optional [ SupportLevel ] = None , queryable : Optional [ SupportLevel ] = None , unit : Optional [ str ] = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that adds OPTIMADE-specific field paramters `queryable`, `support` and `unit`, indicating the corresponding support level in the specification and the physical unit of the field. Arguments: support: The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. queryable: The support level corresponding to the queryablility of this field. unit: A string describing the unit of the field. Returns: The pydantic field with extra validation provided by [`StrictField`][optimade.models.utils.StrictField]. \"\"\" # Collect non-null keyword arguments to add to the Field schema if unit is not None : kwargs [ \"unit\" ] = unit if queryable is not None : if isinstance ( queryable , str ): queryable = SupportLevel ( queryable . lower ()) kwargs [ \"queryable\" ] = queryable if support is not None : if isinstance ( support , str ): support = SupportLevel ( support . lower ()) kwargs [ \"support\" ] = support return StrictField ( * args , ** kwargs ) StrictField ( * args , * , description = None , ** kwargs ) \u00b6 A wrapper around pydantic.Field that does the following: Forbids any \"extra\" keys that would be passed to pydantic.Field , except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". Emits a warning when no description is provided. Parameters: Name Type Description Default *args Positional arguments passed through to Field . () description str The description of the Field ; if this is not specified then a UserWarning will be emitted. None **kwargs Extra keyword arguments to be passed to Field . {} Exceptions: Type Description RuntimeError If **kwargs contains a key not found in the function signature of Field , or in the extensions used by models in this package (see above). Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic Field . Source code in optimade/models/utils.py def StrictField ( * args , description : str = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that does the following: - Forbids any \"extra\" keys that would be passed to `pydantic.Field`, except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". - Emits a warning when no description is provided. Arguments: *args: Positional arguments passed through to `Field`. description: The description of the `Field`; if this is not specified then a `UserWarning` will be emitted. **kwargs: Extra keyword arguments to be passed to `Field`. Raises: RuntimeError: If `**kwargs` contains a key not found in the function signature of `Field`, or in the extensions used by models in this package (see above). Returns: The pydantic `Field`. \"\"\" allowed_keys = [ \"unit\" , \"pattern\" , \"uniqueItems\" , \"support\" , \"queryable\" , \"sortable\" , ] _banned = [ k for k in kwargs if k not in set ( _PYDANTIC_FIELD_KWARGS + allowed_keys )] if _banned : raise RuntimeError ( f \"Not creating StrictField( { args } , { kwargs } ) with forbidden keywords { _banned } .\" ) if description is not None : kwargs [ \"description\" ] = description if description is None : warnings . warn ( f \"No description provided for StrictField specified by { args } , { kwargs } .\" ) return Field ( * args , ** kwargs ) anonymous_element_generator () \u00b6 Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. Source code in optimade/models/utils.py def anonymous_element_generator (): \"\"\" Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. \"\"\" from string import ascii_lowercase for size in itertools . count ( 1 ): for s in itertools . product ( ascii_lowercase , repeat = size ): s = list ( s ) s [ 0 ] = s [ 0 ] . upper () yield \"\" . join ( s )","title":"All models"},{"location":"all_models/#all-models","text":"","title":"All models"},{"location":"all_models/#optimade.models.baseinfo","text":"","title":"baseinfo"},{"location":"all_models/#optimade.models.baseinfo.AvailableApiVersion","text":"A JSON object containing information about an available API version","title":"AvailableApiVersion"},{"location":"all_models/#optimade.models.baseinfo.AvailableApiVersion.url","text":"A string specifying a versioned base URL that MUST adhere to the rules in section Base URL","title":"url"},{"location":"all_models/#optimade.models.baseinfo.AvailableApiVersion.version","text":"A string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'. Examples: 1.0.0 , 1.0.0-rc.2 .","title":"version"},{"location":"all_models/#optimade.models.baseinfo.AvailableApiVersion.crosscheck_url_and_version","text":"Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) # as with version urls, we need to split any release tags or build metadata out of these URLs url_version = tuple ( int ( val ) for val in url_version . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values","title":"crosscheck_url_and_version()"},{"location":"all_models/#optimade.models.baseinfo.AvailableApiVersion.url_must_be_versioned_base_url","text":"The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v","title":"url_must_be_versioned_base_url()"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes","text":"Attributes for Base URL Info endpoint","title":"BaseInfoAttributes"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes.api_version","text":"Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 .","title":"api_version"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes.available_api_versions","text":"A list of dictionaries of available API versions at other base URLs","title":"available_api_versions"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes.available_endpoints","text":"List of available endpoints (i.e., the string to be appended to the versioned base URL).","title":"available_endpoints"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes.entry_types_by_format","text":"Available entry endpoints as a function of output formats.","title":"entry_types_by_format"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes.formats","text":"List of available output formats.","title":"formats"},{"location":"all_models/#optimade.models.baseinfo.BaseInfoAttributes.is_index","text":"If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false ).","title":"is_index"},{"location":"all_models/#optimade.models.entries","text":"","title":"entries"},{"location":"all_models/#optimade.models.entries.EntryInfoProperty","text":"","title":"EntryInfoProperty"},{"location":"all_models/#optimade.models.entries.EntryInfoProperty.description","text":"A human-readable description of the entry property","title":"description"},{"location":"all_models/#optimade.models.entries.EntryInfoProperty.sortable","text":"Defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true .","title":"sortable"},{"location":"all_models/#optimade.models.entries.EntryInfoProperty.type","text":"The type of the property's value. This MUST be any of the types defined in the Data types section. For the purpose of compatibility with future versions of this specification, a client MUST accept values that are not string values specifying any of the OPTIMADE Data types, but MUST then also disregard the type field. Note, if the value is a nested type, only the outermost type should be reported. E.g., for the entry resource structures , the species property is defined as a list of dictionaries, hence its type value would be list .","title":"type"},{"location":"all_models/#optimade.models.entries.EntryInfoProperty.unit","text":"The physical unit of the entry property. This MUST be a valid representation of units according to version 2.1 of The Unified Code for Units of Measure . It is RECOMMENDED that non-standard (non-SI) units are described in the description for the property.","title":"unit"},{"location":"all_models/#optimade.models.entries.EntryInfoResource","text":"","title":"EntryInfoResource"},{"location":"all_models/#optimade.models.entries.EntryInfoResource.description","text":"Description of the entry.","title":"description"},{"location":"all_models/#optimade.models.entries.EntryInfoResource.formats","text":"List of output formats available for this type of entry.","title":"formats"},{"location":"all_models/#optimade.models.entries.EntryInfoResource.output_fields_by_format","text":"Dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary.","title":"output_fields_by_format"},{"location":"all_models/#optimade.models.entries.EntryInfoResource.properties","text":"A dictionary describing queryable properties for this entry type, where each key is a property name.","title":"properties"},{"location":"all_models/#optimade.models.entries.EntryRelationships","text":"This model wraps the JSON API Relationships to include type-specific top level keys.","title":"EntryRelationships"},{"location":"all_models/#optimade.models.entries.EntryRelationships.references","text":"Object containing links to relationships with entries of the references type.","title":"references"},{"location":"all_models/#optimade.models.entries.EntryRelationships.structures","text":"Object containing links to relationships with entries of the structures type.","title":"structures"},{"location":"all_models/#optimade.models.entries.EntryResource","text":"The base model for an entry resource.","title":"EntryResource"},{"location":"all_models/#optimade.models.entries.EntryResourceAttributes","text":"Contains key-value pairs representing the entry's properties.","title":"EntryResourceAttributes"},{"location":"all_models/#optimade.models.entries.EntryResourceAttributes.immutable_id","text":"The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. Type : string. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.)","title":"immutable_id"},{"location":"all_models/#optimade.models.entries.EntryResourceAttributes.last_modified","text":"Date and time representing when the entry was last modified. Type : timestamp. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter response_fields is present and does not include this property. Example : As part of JSON response format: \"2007-04-05T14:30:20Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format string.)","title":"last_modified"},{"location":"all_models/#optimade.models.index_metadb","text":"","title":"index_metadb"},{"location":"all_models/#optimade.models.index_metadb.DefaultRelationship","text":"Enumeration of key(s) for relationship dictionary in IndexInfoResource","title":"DefaultRelationship"},{"location":"all_models/#optimade.models.index_metadb.IndexInfoAttributes","text":"Attributes for Base URL Info endpoint for an Index Meta-Database","title":"IndexInfoAttributes"},{"location":"all_models/#optimade.models.index_metadb.IndexInfoResource","text":"Index Meta-Database Base URL Info endpoint resource","title":"IndexInfoResource"},{"location":"all_models/#optimade.models.index_metadb.IndexRelationship","text":"Index Meta-Database relationship","title":"IndexRelationship"},{"location":"all_models/#optimade.models.index_metadb.IndexRelationship.data","text":"JSON API resource linkage . It MUST be either null or contain a single Links identifier object with the fields id and type","title":"data"},{"location":"all_models/#optimade.models.index_metadb.RelatedLinksResource","text":"A related Links resource object","title":"RelatedLinksResource"},{"location":"all_models/#optimade.models.jsonapi","text":"This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/","title":"jsonapi"},{"location":"all_models/#optimade.models.jsonapi.Attributes","text":"Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type","title":"Attributes"},{"location":"all_models/#optimade.models.jsonapi.BaseResource","text":"Minimum requirements to represent a Resource","title":"BaseResource"},{"location":"all_models/#optimade.models.jsonapi.BaseResource.id","text":"Resource ID","title":"id"},{"location":"all_models/#optimade.models.jsonapi.BaseResource.type","text":"Resource type","title":"type"},{"location":"all_models/#optimade.models.jsonapi.BaseResource.Config","text":"","title":"Config"},{"location":"all_models/#optimade.models.jsonapi.BaseResource.Config.schema_extra","text":"Ensure id and type are the first two entries in the list required properties. Note This requires that id and type are the first model fields defined for all sub-models of BaseResource . Source code in optimade/models/jsonapi.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"BaseResource\" ]) -> None : \"\"\"Ensure `id` and `type` are the first two entries in the list required properties. Note: This _requires_ that `id` and `type` are the _first_ model fields defined for all sub-models of `BaseResource`. \"\"\" if \"id\" not in schema . get ( \"required\" , []): schema [ \"required\" ] = [ \"id\" ] + schema . get ( \"required\" , []) if \"type\" not in schema . get ( \"required\" , []): required = [] for field in schema . get ( \"required\" , []): required . append ( field ) if field == \"id\" : # To make sure the property order match the listed properties, # this ensures \"type\" is added immediately after \"id\". required . append ( \"type\" ) schema [ \"required\" ] = required","title":"schema_extra()"},{"location":"all_models/#optimade.models.jsonapi.Error","text":"An error response","title":"Error"},{"location":"all_models/#optimade.models.jsonapi.Error.code","text":"an application-specific error code, expressed as a string value.","title":"code"},{"location":"all_models/#optimade.models.jsonapi.Error.detail","text":"A human-readable explanation specific to this occurrence of the problem.","title":"detail"},{"location":"all_models/#optimade.models.jsonapi.Error.id","text":"A unique identifier for this particular occurrence of the problem.","title":"id"},{"location":"all_models/#optimade.models.jsonapi.Error.links","text":"A links object storing about","title":"links"},{"location":"all_models/#optimade.models.jsonapi.Error.meta","text":"a meta object containing non-standard meta-information about the error.","title":"meta"},{"location":"all_models/#optimade.models.jsonapi.Error.source","text":"An object containing references to the source of the error","title":"source"},{"location":"all_models/#optimade.models.jsonapi.Error.status","text":"the HTTP status code applicable to this problem, expressed as a string value.","title":"status"},{"location":"all_models/#optimade.models.jsonapi.Error.title","text":"A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.","title":"title"},{"location":"all_models/#optimade.models.jsonapi.Error.__hash__","text":"Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ())","title":"__hash__()"},{"location":"all_models/#optimade.models.jsonapi.ErrorLinks","text":"A Links object specific to Error objects","title":"ErrorLinks"},{"location":"all_models/#optimade.models.jsonapi.ErrorLinks.about","text":"A link that leads to further details about this particular occurrence of the problem.","title":"about"},{"location":"all_models/#optimade.models.jsonapi.ErrorSource","text":"an object containing references to the source of the error","title":"ErrorSource"},{"location":"all_models/#optimade.models.jsonapi.ErrorSource.parameter","text":"a string indicating which URI query parameter caused the error.","title":"parameter"},{"location":"all_models/#optimade.models.jsonapi.ErrorSource.pointer","text":"a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute].","title":"pointer"},{"location":"all_models/#optimade.models.jsonapi.JsonApi","text":"An object describing the server's implementation","title":"JsonApi"},{"location":"all_models/#optimade.models.jsonapi.JsonApi.meta","text":"Non-standard meta information","title":"meta"},{"location":"all_models/#optimade.models.jsonapi.JsonApi.version","text":"Version of the json API used","title":"version"},{"location":"all_models/#optimade.models.jsonapi.Link","text":"A link MUST be represented as either: a string containing the link's URL or a link object.","title":"Link"},{"location":"all_models/#optimade.models.jsonapi.Link.href","text":"a string containing the link\u2019s URL.","title":"href"},{"location":"all_models/#optimade.models.jsonapi.Link.meta","text":"a meta object containing non-standard meta-information about the link.","title":"meta"},{"location":"all_models/#optimade.models.jsonapi.Meta","text":"Non-standard meta-information that can not be represented as an attribute or relationship.","title":"Meta"},{"location":"all_models/#optimade.models.jsonapi.Relationship","text":"Representation references from the resource object in which it\u2019s defined to other resource objects.","title":"Relationship"},{"location":"all_models/#optimade.models.jsonapi.Relationship.data","text":"Resource linkage","title":"data"},{"location":"all_models/#optimade.models.jsonapi.Relationship.links","text":"a links object containing at least one of the following: self, related","title":"links"},{"location":"all_models/#optimade.models.jsonapi.Relationship.meta","text":"a meta object that contains non-standard meta-information about the relationship.","title":"meta"},{"location":"all_models/#optimade.models.jsonapi.RelationshipLinks","text":"A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object.","title":"RelationshipLinks"},{"location":"all_models/#optimade.models.jsonapi.RelationshipLinks.related","text":"A related resource link .","title":"related"},{"location":"all_models/#optimade.models.jsonapi.RelationshipLinks.self","text":"A link for the relationship itself (a 'relationship link'). This link allows the client to directly manipulate the relationship. When fetched successfully, this link returns the linkage for the related resources as its primary data. (See Fetching Relationships .)","title":"self"},{"location":"all_models/#optimade.models.jsonapi.Relationships","text":"Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id","title":"Relationships"},{"location":"all_models/#optimade.models.jsonapi.Resource","text":"Resource objects appear in a JSON API document to represent resources.","title":"Resource"},{"location":"all_models/#optimade.models.jsonapi.Resource.attributes","text":"an attributes object representing some of the resource\u2019s data.","title":"attributes"},{"location":"all_models/#optimade.models.jsonapi.Resource.links","text":"a links object containing links related to the resource.","title":"links"},{"location":"all_models/#optimade.models.jsonapi.Resource.meta","text":"a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship.","title":"meta"},{"location":"all_models/#optimade.models.jsonapi.Resource.relationships","text":"Relationships object describing relationships between the resource and other JSON API resources.","title":"relationships"},{"location":"all_models/#optimade.models.jsonapi.ResourceLinks","text":"A Resource Links object","title":"ResourceLinks"},{"location":"all_models/#optimade.models.jsonapi.ResourceLinks.self","text":"A link that identifies the resource represented by the resource object.","title":"self"},{"location":"all_models/#optimade.models.jsonapi.Response","text":"A top-level response","title":"Response"},{"location":"all_models/#optimade.models.jsonapi.Response.data","text":"Outputted Data","title":"data"},{"location":"all_models/#optimade.models.jsonapi.Response.errors","text":"A list of unique errors","title":"errors"},{"location":"all_models/#optimade.models.jsonapi.Response.included","text":"A list of unique included resources","title":"included"},{"location":"all_models/#optimade.models.jsonapi.Response.jsonapi","text":"Information about the JSON API used","title":"jsonapi"},{"location":"all_models/#optimade.models.jsonapi.Response.links","text":"Links associated with the primary data or errors","title":"links"},{"location":"all_models/#optimade.models.jsonapi.Response.meta","text":"A meta object containing non-standard information related to the Success","title":"meta"},{"location":"all_models/#optimade.models.jsonapi.Response.Config","text":"The specification mandates that datetimes must be encoded following RFC3339 , which does not support fractional seconds, thus they must be stripped in the response. This can cause issues when the underlying database contains fields that do include microseconds, as filters may return unexpected results.","title":"Config"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks","text":"A set of Links objects, possibly including pagination","title":"ToplevelLinks"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.first","text":"The first page of data","title":"first"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.last","text":"The last page of data","title":"last"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.next","text":"The next page of data","title":"next"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.prev","text":"The previous page of data","title":"prev"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.related","text":"A related resource link","title":"related"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.self","text":"A link to itself","title":"self"},{"location":"all_models/#optimade.models.jsonapi.ToplevelLinks.check_additional_keys_are_links","text":"The ToplevelLinks class allows any additional keys, as long as they are also Links or Urls themselves. Source code in optimade/models/jsonapi.py @root_validator ( pre = False ) def check_additional_keys_are_links ( cls , values ): \"\"\"The `ToplevelLinks` class allows any additional keys, as long as they are also Links or Urls themselves. \"\"\" for key , value in values . items (): if key not in cls . schema ()[ \"properties\" ]: values [ key ] = parse_obj_as ( Optional [ Union [ AnyUrl , Link ]], value ) return values","title":"check_additional_keys_are_links()"},{"location":"all_models/#optimade.models.links","text":"","title":"links"},{"location":"all_models/#optimade.models.links.Aggregate","text":"Enumeration of aggregate values","title":"Aggregate"},{"location":"all_models/#optimade.models.links.LinkType","text":"Enumeration of link_type values","title":"LinkType"},{"location":"all_models/#optimade.models.links.LinksResource","text":"A Links endpoint resource object","title":"LinksResource"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes","text":"Links endpoint resource object attributes","title":"LinksResourceAttributes"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.aggregate","text":"A string indicating whether a client that is following links to aggregate results from different OPTIMADE implementations should follow this link or not. This flag SHOULD NOT be indicated for links where link_type is not child . If not specified, clients MAY assume that the value is ok . If specified, and the value is anything different than ok , the client MUST assume that the server is suggesting not to follow the link during aggregation by default (also if the value is not among the known ones, in case a future specification adds new accepted values). Specific values indicate the reason why the server is providing the suggestion. A client MAY follow the link anyway if it has reason to do so (e.g., if the client is looking for all test databases, it MAY follow the links marked with aggregate = test ). If specified, it MUST be one of the values listed in section Link Aggregate Options.","title":"aggregate"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.base_url","text":"JSON API links object, pointing to the base URL for this implementation","title":"base_url"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.description","text":"Human-readable description for the OPTIMADE API implementation, e.g., for use in clients to show a description to the end-user.","title":"description"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.homepage","text":"JSON API links object, pointing to a homepage URL for this implementation","title":"homepage"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.link_type","text":"The type of the linked relation. MUST be one of these values: 'child', 'root', 'external', 'providers'.","title":"link_type"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.name","text":"Human-readable name for the OPTIMADE API implementation, e.g., for use in clients to show the name to the end-user.","title":"name"},{"location":"all_models/#optimade.models.links.LinksResourceAttributes.no_aggregate_reason","text":"An OPTIONAL human-readable string indicating the reason for suggesting not to aggregate results following the link. It SHOULD NOT be present if aggregate = ok .","title":"no_aggregate_reason"},{"location":"all_models/#optimade.models.optimade_json","text":"Modified JSON API v1.0 for OPTIMADE API","title":"optimade_json"},{"location":"all_models/#optimade.models.optimade_json.BaseRelationshipMeta","text":"Specific meta field for base relationship resource","title":"BaseRelationshipMeta"},{"location":"all_models/#optimade.models.optimade_json.BaseRelationshipMeta.description","text":"OPTIONAL human-readable description of the relationship","title":"description"},{"location":"all_models/#optimade.models.optimade_json.BaseRelationshipResource","text":"Minimum requirements to represent a relationship resource","title":"BaseRelationshipResource"},{"location":"all_models/#optimade.models.optimade_json.BaseRelationshipResource.meta","text":"Relationship meta field. MUST contain 'description' if supplied.","title":"meta"},{"location":"all_models/#optimade.models.optimade_json.DataType","text":"Optimade Data Types See the section \"Data types\" in the OPTIMADE API specification for more information.","title":"DataType"},{"location":"all_models/#optimade.models.optimade_json.Implementation","text":"Information on the server implementation","title":"Implementation"},{"location":"all_models/#optimade.models.optimade_json.Implementation.homepage","text":"A JSON API links object pointing to the homepage of the implementation.","title":"homepage"},{"location":"all_models/#optimade.models.optimade_json.Implementation.maintainer","text":"A dictionary providing details about the maintainer of the implementation.","title":"maintainer"},{"location":"all_models/#optimade.models.optimade_json.Implementation.name","text":"name of the implementation","title":"name"},{"location":"all_models/#optimade.models.optimade_json.Implementation.source_url","text":"A JSON API links object pointing to the implementation source, either downloadable archive or version control system.","title":"source_url"},{"location":"all_models/#optimade.models.optimade_json.Implementation.version","text":"version string of the current implementation","title":"version"},{"location":"all_models/#optimade.models.optimade_json.ImplementationMaintainer","text":"Details about the maintainer of the implementation","title":"ImplementationMaintainer"},{"location":"all_models/#optimade.models.optimade_json.ImplementationMaintainer.email","text":"the maintainer's email address","title":"email"},{"location":"all_models/#optimade.models.optimade_json.OptimadeError","text":"detail MUST be present","title":"OptimadeError"},{"location":"all_models/#optimade.models.optimade_json.Provider","text":"Information on the database provider of the implementation.","title":"Provider"},{"location":"all_models/#optimade.models.optimade_json.Provider.description","text":"a longer description of the database provider","title":"description"},{"location":"all_models/#optimade.models.optimade_json.Provider.homepage","text":"a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object.","title":"homepage"},{"location":"all_models/#optimade.models.optimade_json.Provider.name","text":"a short name for the database provider","title":"name"},{"location":"all_models/#optimade.models.optimade_json.Provider.prefix","text":"database-provider-specific prefix as found in section Database-Provider-Specific Namespace Prefixes.","title":"prefix"},{"location":"all_models/#optimade.models.optimade_json.Relationship","text":"Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource","title":"Relationship"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta","text":"A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix.","title":"ResponseMeta"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.api_version","text":"Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 .","title":"api_version"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.data_available","text":"An integer containing the total number of data resource objects available in the database for the endpoint.","title":"data_available"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.data_returned","text":"An integer containing the total number of data resource objects returned for the current filter query, independent of pagination.","title":"data_returned"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.implementation","text":"a dictionary describing the server implementation","title":"implementation"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.last_id","text":"a string containing the last ID returned","title":"last_id"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.more_data_available","text":"false if the response contains all data for the request (e.g., a request issued to a single entry endpoint, or a filter query at the last page of a paginated response) and true if the response is incomplete in the sense that multiple objects match the request, and not all of them have been included in the response (e.g., a query with multiple pages that is not at the last page).","title":"more_data_available"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.optimade_schema","text":"A JSON API links object that points to a schema for the response. If it is a string, or a dictionary containing no meta field, the provided URL MUST point at an OpenAPI schema. It is possible that future versions of this specification allows for alternative schema types. Hence, if the meta field of the JSON API links object is provided and contains a field schema_type that is not equal to the string OpenAPI the client MUST not handle failures to parse the schema or to validate the response against the schema as errors.","title":"optimade_schema"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.provider","text":"information on the database provider of the implementation.","title":"provider"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.query","text":"Information on the Query that was requested","title":"query"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.response_message","text":"response string from the server","title":"response_message"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.time_stamp","text":"A timestamp containing the date and time at which the query was executed.","title":"time_stamp"},{"location":"all_models/#optimade.models.optimade_json.ResponseMeta.warnings","text":"A list of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \"warning\" . The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status , representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects.","title":"warnings"},{"location":"all_models/#optimade.models.optimade_json.ResponseMetaQuery","text":"Information on the query that was requested.","title":"ResponseMetaQuery"},{"location":"all_models/#optimade.models.optimade_json.ResponseMetaQuery.representation","text":"A string with the part of the URL following the versioned or unversioned base URL that serves the API. Query parameters that have not been used in processing the request MAY be omitted. In particular, if no query parameters have been involved in processing the request, the query part of the URL MAY be excluded. Example: /structures?filter=nelements=2","title":"representation"},{"location":"all_models/#optimade.models.optimade_json.Success","text":"errors are not allowed","title":"Success"},{"location":"all_models/#optimade.models.optimade_json.Success.either_data_meta_or_errors_must_be_set","text":"Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values","title":"either_data_meta_or_errors_must_be_set()"},{"location":"all_models/#optimade.models.optimade_json.Warnings","text":"OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class.","title":"Warnings"},{"location":"all_models/#optimade.models.optimade_json.Warnings.type","text":"Warnings must be of type \"warning\"","title":"type"},{"location":"all_models/#optimade.models.optimade_json.Warnings.Config","text":"","title":"Config"},{"location":"all_models/#optimade.models.optimade_json.Warnings.Config.schema_extra","text":"Update OpenAPI JSON schema model for Warning . Ensure type is in the list required properties and in the correct place. Remove status property. This property is not allowed for Warning , nor is it a part of the OPTIMADE definition of the Warning object. Note Since type is the last model field defined, it will simply be appended. Source code in optimade/models/optimade_json.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"Warnings\" ]) -> None : \"\"\"Update OpenAPI JSON schema model for `Warning`. * Ensure `type` is in the list required properties and in the correct place. * Remove `status` property. This property is not allowed for `Warning`, nor is it a part of the OPTIMADE definition of the `Warning` object. Note: Since `type` is the _last_ model field defined, it will simply be appended. \"\"\" if \"required\" in schema : if \"type\" not in schema [ \"required\" ]: schema [ \"required\" ] . append ( \"type\" ) else : schema [ \"required\" ] = [ \"type\" ] schema . get ( \"properties\" , {}) . pop ( \"status\" , None )","title":"schema_extra()"},{"location":"all_models/#optimade.models.references","text":"","title":"references"},{"location":"all_models/#optimade.models.references.Person","text":"A person, i.e., an author, editor or other.","title":"Person"},{"location":"all_models/#optimade.models.references.Person.firstname","text":"First name of the person.","title":"firstname"},{"location":"all_models/#optimade.models.references.Person.lastname","text":"Last name of the person.","title":"lastname"},{"location":"all_models/#optimade.models.references.Person.name","text":"Full name of the person, REQUIRED.","title":"name"},{"location":"all_models/#optimade.models.references.ReferenceResource","text":"The references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , volume , year : meanings of these properties match the BibTeX specification , values are strings; bib_type : type of the reference, corresponding to type property in the BibTeX specification, value is string; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., any of the properties MAY be null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties.","title":"ReferenceResource"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes","text":"Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification .","title":"ReferenceResourceAttributes"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.address","text":"Meaning of property matches the BiBTeX specification.","title":"address"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.annote","text":"Meaning of property matches the BiBTeX specification.","title":"annote"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.authors","text":"List of person objects containing the authors of the reference.","title":"authors"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.bib_type","text":"Type of the reference, corresponding to the type property in the BiBTeX specification.","title":"bib_type"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.booktitle","text":"Meaning of property matches the BiBTeX specification.","title":"booktitle"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.chapter","text":"Meaning of property matches the BiBTeX specification.","title":"chapter"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.crossref","text":"Meaning of property matches the BiBTeX specification.","title":"crossref"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.doi","text":"The digital object identifier of the reference.","title":"doi"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.edition","text":"Meaning of property matches the BiBTeX specification.","title":"edition"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.editors","text":"List of person objects containing the editors of the reference.","title":"editors"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.howpublished","text":"Meaning of property matches the BiBTeX specification.","title":"howpublished"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.institution","text":"Meaning of property matches the BiBTeX specification.","title":"institution"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.journal","text":"Meaning of property matches the BiBTeX specification.","title":"journal"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.key","text":"Meaning of property matches the BiBTeX specification.","title":"key"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.month","text":"Meaning of property matches the BiBTeX specification.","title":"month"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.note","text":"Meaning of property matches the BiBTeX specification.","title":"note"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.number","text":"Meaning of property matches the BiBTeX specification.","title":"number"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.organization","text":"Meaning of property matches the BiBTeX specification.","title":"organization"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.pages","text":"Meaning of property matches the BiBTeX specification.","title":"pages"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.publisher","text":"Meaning of property matches the BiBTeX specification.","title":"publisher"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.school","text":"Meaning of property matches the BiBTeX specification.","title":"school"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.series","text":"Meaning of property matches the BiBTeX specification.","title":"series"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.title","text":"Meaning of property matches the BiBTeX specification.","title":"title"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.url","text":"The URL of the reference.","title":"url"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.volume","text":"Meaning of property matches the BiBTeX specification.","title":"volume"},{"location":"all_models/#optimade.models.references.ReferenceResourceAttributes.year","text":"Meaning of property matches the BiBTeX specification.","title":"year"},{"location":"all_models/#optimade.models.responses","text":"","title":"responses"},{"location":"all_models/#optimade.models.responses.ErrorResponse","text":"errors MUST be present and data MUST be skipped","title":"ErrorResponse"},{"location":"all_models/#optimade.models.structures","text":"","title":"structures"},{"location":"all_models/#optimade.models.structures.Assembly","text":"A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent).","title":"Assembly"},{"location":"all_models/#optimade.models.structures.Assembly.group_probabilities","text":"Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species .","title":"group_probabilities"},{"location":"all_models/#optimade.models.structures.Assembly.sites_in_groups","text":"Index of the sites (0-based) that belong to each group for each assembly. Examples : [[1], [2]] : two groups, one with the second site, one with the third. [[1,2], [3]] : one group with the second and third site, one with the fourth.","title":"sites_in_groups"},{"location":"all_models/#optimade.models.structures.Periodicity","text":"Integer enumeration of dimension_types values","title":"Periodicity"},{"location":"all_models/#optimade.models.structures.Species","text":"A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms.","title":"Species"},{"location":"all_models/#optimade.models.structures.Species.attached","text":"If provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element.","title":"attached"},{"location":"all_models/#optimade.models.structures.Species.chemical_symbols","text":"MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features .","title":"chemical_symbols"},{"location":"all_models/#optimade.models.structures.Species.concentration","text":"MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species).","title":"concentration"},{"location":"all_models/#optimade.models.structures.Species.mass","text":"If present MUST be a list of floats expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0.","title":"mass"},{"location":"all_models/#optimade.models.structures.Species.name","text":"Gives the name of the species; the name value MUST be unique in the species list.","title":"name"},{"location":"all_models/#optimade.models.structures.Species.nattached","text":"If provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the :field: attached key.","title":"nattached"},{"location":"all_models/#optimade.models.structures.Species.original_name","text":"Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation.","title":"original_name"},{"location":"all_models/#optimade.models.structures.StructureFeatures","text":"Enumeration of structure_features values","title":"StructureFeatures"},{"location":"all_models/#optimade.models.structures.StructureResource","text":"Representing a structure.","title":"StructureResource"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes","text":"This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions.","title":"StructureResourceAttributes"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.assemblies","text":"A description of groups of sites that are statistically correlated. Type : list of dictionary with keys: sites_in_groups : list of list of integers (REQUIRED) group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. The property SHOULD be null for entries that have no partial occupancies. If present, the correct flag MUST be set in the list structure_features . Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: [[1], [2]] : two groups, one with the second site, one with the third. Example: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species . If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: { \"cartesian_site_positions\" : [[ 0 , 0 , 0 ]], \"species_at_sites\" : [ \"SiGe-vac\" ], \"species\" : [ { \"name\" : \"SiGe-vac\" , \"chemical_symbols\" : [ \"Si\" , \"Ge\" , \"vacancy\" ], \"concentration\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } Using multiple species and the assemblies: { \"cartesian_site_positions\" : [ [ 0 , 0 , 0 ], [ 0 , 0 , 0 ], [ 0 , 0 , 0 ] ], \"species_at_sites\" : [ \"Si\" , \"Ge\" , \"vac\" ], \"species\" : [ { \"name\" : \"Si\" , \"chemical_symbols\" : [ \"Si\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"Ge\" , \"chemical_symbols\" : [ \"Ge\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"vac\" , \"chemical_symbols\" : [ \"vacancy\" ], \"concentration\" : [ 1.0 ] } }, \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ], [ 2 ] ], \"group_probabilities\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: { \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ] ], \"group_probabilities\" : [ 0.2 , 0.8 ], }, { \"sites_in_groups\" : [ [ 2 ], [ 3 ] ], \"group_probabilities\" : [ 0.3 , 0.7 ] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability).","title":"assemblies"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.cartesian_site_positions","text":"Cartesian positions of each site in the structure. A site is usually used to describe positions of atoms; what atoms can be encountered at a given site is conveyed by the species_at_sites property, and the species themselves are described in the species property. Type : list of list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length equal to the number of sites in the structure, where every element is a list of the three Cartesian coordinates of a site expressed as float values in the unit angstrom (\u00c5). An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies ). Examples : [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin.","title":"cartesian_site_positions"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_anonymous","text":"The anonymous formula is the chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : \"A2B\" \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is chemical_formula_anonymous=\"A2B\" .","title":"chemical_formula_anonymous"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_descriptive","text":"The chemical formula for a structure as a string in a form chosen by the API implementation. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry . Examples : \"(H2O)2 Na\" \"NaCl\" \"CaCO3\" \"CCaO3\" \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: chemical_formula_descriptive CONTAINS \"H2O\" .","title":"chemical_formula_descriptive"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_hill","text":"The chemical formula for a structure in Hill form with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, only a subset of the filter features MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, chemical_formula_hill is \"H2O2\" (i.e., not \"HO\" , nor \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in Hill order , followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : \"H2O2\" Query examples : A filter that matches an exactly given formula is chemical_formula_hill=\"H2O2\" .","title":"chemical_formula_hill"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_reduced","text":"The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate queries on formula components are instead suggested to be formulated using set-type filter operators on the multi valued elements and elements_ratios properties. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : \"H2NaO\" \"ClNa\" \"CCaO3\" Query examples : A filter that matches an exactly given formula is chemical_formula_reduced=\"H2NaO\" .","title":"chemical_formula_reduced"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.dimension_types","text":"List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ), this list indicates if the direction is periodic (value 1 ) or non-periodic (value 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in lattice_vectors and not the Cartesian x, y, z directions. Type : list of integers. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: [0, 0, 0] For a wire along the direction specified by the third lattice vector: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: [1, 0, 1] For a bulk 3D system: [1, 1, 1]","title":"dimension_types"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.elements","text":"Names of the different elements present in the structure. Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The strings are the chemical symbols, i.e., either a single uppercase letter or an uppercase letter followed by a number of lowercase letters. The order MUST be alphabetical. Note: This property SHOULD NOT contain the string \"X\" to indicate non-chemical elements or \"vacancy\" to indicate vacancies (in contrast to the field chemical_symbols for the species property). Examples : [\"Si\"] [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use elements HAS ALL \"Si\", \"Al\", \"O\" AND elements LENGTH 3 .","title":"elements"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.elements_ratios","text":"Relative proportions of different elements in the structure. Type : list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : [1.0] [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: Useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally inadvisable. OPTIONAL: a filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 .","title":"elements_ratios"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.lattice_vectors","text":"The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). Type : list of list of floats or unknown values. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. MUST always contain three vectors of three coordinates each, independently of the elements of property dimension_types . The vectors SHOULD by convention be chosen so the determinant of the lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. The coordinates of the lattice vectors of non-periodic dimensions (i.e., those dimensions for which dimension_types is 0 ) MAY be given as a list of all null values. If a lattice vector contains the value null , all coordinates of that lattice vector MUST be null . Examples : [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is (4, 0, 0) , i.e., a vector aligned along the x axis of length 4 \u00c5; the second vector is (0, 4, 0) ; and the third vector is (0, 1, 4) .","title":"lattice_vectors"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.nelements","text":"Number of different elements in the structure as an integer. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 3 Querying : Note: queries on this property can equivalently be formulated using elements LENGTH . A filter that matches structures that have exactly 4 elements: nelements=4 . A filter that matches structures that have between 2 and 7 elements: nelements>=2 AND nelements<=7 .","title":"nelements"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.nperiodic_dimensions","text":"An integer specifying the number of periodic dimensions in the structure, equivalent to the number of non-zero entries in dimension_types . Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The integer value MUST be between 0 and 3 inclusive and MUST be equal to the sum of the items in the dimension_types property. This property only reflects the treatment of the lattice vectors provided for the structure, and not any physical interpretation of the dimensionality of its contents. Examples : 2 should be indicated in cases where dimension_types is any of [1, 1, 0] , [1, 0, 1] , [0, 1, 1] . Query examples : Match only structures with exactly 3 periodic dimensions: nperiodic_dimensions=3 Match all structures with 2 or fewer periodic dimensions: nperiodic_dimensions<=2","title":"nperiodic_dimensions"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.nsites","text":"An integer specifying the length of the cartesian_site_positions property. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 42 Query examples : Match only structures with exactly 4 sites: nsites=4 Match structures that have between 2 and 7 sites: nsites>=2 AND nsites<=7","title":"nsites"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.species","text":"A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Type : list of dictionary with keys: name : string (REQUIRED) chemical_symbols : list of strings (REQUIRED) concentration : list of float (REQUIRED) attached : list of strings (REQUIRED) nattached : list of integers (OPTIONAL) mass : list of floats (OPTIONAL) original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features . concentration : REQUIRED; MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different sites (even of the same species). attached : OPTIONAL; if provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element. nattached : OPTIONAL; if provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the attached key. The implementation MUST include either both or none of the attached and nattached keys, and if they are provided, they MUST be of the same length. Furthermore, if they are provided, the structure_features property MUST include the string site_attachments . mass : OPTIONAL. If present MUST be a list of floats, with the same length as chemical_symbols , providing element masses expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites ). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., \"Ti\" for titanium, \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms.","title":"species"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.species_at_sites","text":"Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions ). Each species name mentioned in the species_at_sites list MUST be described in the list property species (i.e. for each value in the species_at_sites list there MUST exist exactly one dictionary in the species list with the name attribute equal to the corresponding species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled \"Ti\" and the second a species labeled \"O2\" . [\"Ac\", \"Ac\", \"Ag\", \"Ir\"] indicating the first two sites contains the \"Ac\" species, while the third and fourth sites contain the \"Ag\" and \"Ir\" species, respectively.","title":"species_at_sites"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.structure_features","text":"A list of strings that flag which special features are used by the structure. Type : list of strings Requirements/Conventions : Support : MUST be supported by all implementations, MUST NOT be null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : disorder : this flag MUST be present if any one entry in the species list has a chemical_symbols list that is longer than 1 element. implicit_atoms : this flag MUST be present if the structure contains atoms that are not assigned to sites via the property species_at_sites (e.g., because their positions are unknown). When this flag is present, the properties related to the chemical formula will likely not match the type and count of atoms represented by the species_at_sites , species and assemblies properties. site_attachments : this flag MUST be present if any one entry in the species list includes attached and nattached . assemblies : this flag MUST be present if the property assemblies is present. Examples : A structure having implicit atoms and using assemblies: [\"assemblies\", \"implicit_atoms\"]","title":"structure_features"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.Config","text":"","title":"Config"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.Config.schema_extra","text":"Two things need to be added to the schema: Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, dimension_types and lattice_vectors , are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be nullable according to the OpenAPI definition. Source code in optimade/models/structures.py def schema_extra ( schema , model ): \"\"\"Two things need to be added to the schema: 1. Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, `dimension_types` and `lattice_vectors`, are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. 2. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be `nullable` according to the OpenAPI definition. \"\"\" schema [ \"required\" ] . insert ( 7 , \"dimension_types\" ) schema [ \"required\" ] . insert ( 9 , \"lattice_vectors\" ) nullable_props = ( prop for prop in schema [ \"required\" ] if schema [ \"properties\" ][ prop ] . get ( \"support\" ) == SupportLevel . SHOULD ) for prop in nullable_props : schema [ \"properties\" ][ prop ][ \"nullable\" ] = True","title":"schema_extra()"},{"location":"all_models/#optimade.models.structures.StructureResourceAttributes.warn_on_missing_correlated_fields","text":"Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. Source code in optimade/models/structures.py @root_validator ( pre = True ) def warn_on_missing_correlated_fields ( cls , values ): \"\"\"Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. \"\"\" accumulated_warnings = [] for field_set in CORRELATED_STRUCTURE_FIELDS : missing_fields = { f for f in field_set if values . get ( f ) is None } if missing_fields and len ( missing_fields ) != len ( field_set ): accumulated_warnings += [ f \"Structure with values { values } is missing fields { missing_fields } which are required if { field_set - missing_fields } are present.\" ] for warn in accumulated_warnings : warnings . warn ( warn , MissingExpectedField ) return values","title":"warn_on_missing_correlated_fields()"},{"location":"all_models/#optimade.models.utils","text":"","title":"utils"},{"location":"all_models/#optimade.models.utils.ANONYMOUS_ELEMENTS","text":"Returns the first 150 values of the anonymous element generator.","title":"ANONYMOUS_ELEMENTS"},{"location":"all_models/#optimade.models.utils.SemanticVersion","text":"A custom type for a semantic version, using the recommended semver regexp from https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string.","title":"SemanticVersion"},{"location":"all_models/#optimade.models.utils.SemanticVersion.base_version","text":"The base version string without patch and metadata info.","title":"base_version"},{"location":"all_models/#optimade.models.utils.SemanticVersion.build_metadata","text":"The build metadata.","title":"build_metadata"},{"location":"all_models/#optimade.models.utils.SemanticVersion.major","text":"The major version number.","title":"major"},{"location":"all_models/#optimade.models.utils.SemanticVersion.minor","text":"The minor version number.","title":"minor"},{"location":"all_models/#optimade.models.utils.SemanticVersion.patch","text":"The patch version number.","title":"patch"},{"location":"all_models/#optimade.models.utils.SemanticVersion.prerelease","text":"The pre-release tag.","title":"prerelease"},{"location":"all_models/#optimade.models.utils.SupportLevel","text":"OPTIMADE property/field support levels","title":"SupportLevel"},{"location":"all_models/#optimade.models.utils.OptimadeField","text":"A wrapper around pydantic.Field that adds OPTIMADE-specific field paramters queryable , support and unit , indicating the corresponding support level in the specification and the physical unit of the field. Parameters: Name Type Description Default support Optional[optimade.models.utils.SupportLevel] The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. None queryable Optional[optimade.models.utils.SupportLevel] The support level corresponding to the queryablility of this field. None unit Optional[str] A string describing the unit of the field. None Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic field with extra validation provided by StrictField . Source code in optimade/models/utils.py def OptimadeField ( * args , support : Optional [ SupportLevel ] = None , queryable : Optional [ SupportLevel ] = None , unit : Optional [ str ] = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that adds OPTIMADE-specific field paramters `queryable`, `support` and `unit`, indicating the corresponding support level in the specification and the physical unit of the field. Arguments: support: The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. queryable: The support level corresponding to the queryablility of this field. unit: A string describing the unit of the field. Returns: The pydantic field with extra validation provided by [`StrictField`][optimade.models.utils.StrictField]. \"\"\" # Collect non-null keyword arguments to add to the Field schema if unit is not None : kwargs [ \"unit\" ] = unit if queryable is not None : if isinstance ( queryable , str ): queryable = SupportLevel ( queryable . lower ()) kwargs [ \"queryable\" ] = queryable if support is not None : if isinstance ( support , str ): support = SupportLevel ( support . lower ()) kwargs [ \"support\" ] = support return StrictField ( * args , ** kwargs )","title":"OptimadeField()"},{"location":"all_models/#optimade.models.utils.StrictField","text":"A wrapper around pydantic.Field that does the following: Forbids any \"extra\" keys that would be passed to pydantic.Field , except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". Emits a warning when no description is provided. Parameters: Name Type Description Default *args Positional arguments passed through to Field . () description str The description of the Field ; if this is not specified then a UserWarning will be emitted. None **kwargs Extra keyword arguments to be passed to Field . {} Exceptions: Type Description RuntimeError If **kwargs contains a key not found in the function signature of Field , or in the extensions used by models in this package (see above). Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic Field . Source code in optimade/models/utils.py def StrictField ( * args , description : str = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that does the following: - Forbids any \"extra\" keys that would be passed to `pydantic.Field`, except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". - Emits a warning when no description is provided. Arguments: *args: Positional arguments passed through to `Field`. description: The description of the `Field`; if this is not specified then a `UserWarning` will be emitted. **kwargs: Extra keyword arguments to be passed to `Field`. Raises: RuntimeError: If `**kwargs` contains a key not found in the function signature of `Field`, or in the extensions used by models in this package (see above). Returns: The pydantic `Field`. \"\"\" allowed_keys = [ \"unit\" , \"pattern\" , \"uniqueItems\" , \"support\" , \"queryable\" , \"sortable\" , ] _banned = [ k for k in kwargs if k not in set ( _PYDANTIC_FIELD_KWARGS + allowed_keys )] if _banned : raise RuntimeError ( f \"Not creating StrictField( { args } , { kwargs } ) with forbidden keywords { _banned } .\" ) if description is not None : kwargs [ \"description\" ] = description if description is None : warnings . warn ( f \"No description provided for StrictField specified by { args } , { kwargs } .\" ) return Field ( * args , ** kwargs )","title":"StrictField()"},{"location":"all_models/#optimade.models.utils.anonymous_element_generator","text":"Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. Source code in optimade/models/utils.py def anonymous_element_generator (): \"\"\" Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. \"\"\" from string import ascii_lowercase for size in itertools . count ( 1 ): for s in itertools . product ( ascii_lowercase , repeat = size ): s = list ( s ) s [ 0 ] = s [ 0 ] . upper () yield \"\" . join ( s )","title":"anonymous_element_generator()"},{"location":"configuration/","text":"Configuration \u00b6 Since the server implementation is built with FastAPI , which uses pydantic , the configuration is based on pydantic's Setting management . This way of handling configuration options supports various different approaches to configure the server. We recommend either or a combination of the following: Set environment variables. Create a JSON file with an implementation's complete configuration. When adding a third, final option, this also represents the (descending) order of priority with which configuration values are determined: Use defaults in ServerConfig . The JSON configuration file \u00b6 The main way of configuring the OPTIMADE server is by creating a configuration JSON file. An example of one that works with the example implementation can be found in optimade_config.json : Configuration file for the default OPTIMADE server { \"debug\" : false , \"default_db\" : \"test_server\" , \"base_url\" : \"http://localhost:5000\" , \"implementation\" : { \"name\" : \"Example implementation\" , \"source_url\" : \"https://github.com/Materials-Consortia/optimade-python-tools\" , \"maintainer\" : { \"email\" : \"dev@optimade.org\" } }, \"provider\" : { \"name\" : \"Example provider\" , \"description\" : \"Provider used for examples, not to be assigned to a real database\" , \"prefix\" : \"exmpl\" , \"homepage\" : \"https://example.com\" }, \"index_base_url\" : \"http://localhost:5001\" , \"provider_fields\" : { \"structures\" : [ \"band_gap\" , \"chemsys\" ] }, \"aliases\" : { \"structures\" : { \"id\" : \"task_id\" , \"immutable_id\" : \"_id\" , \"chemical_formula_descriptive\" : \"pretty_formula\" , \"chemical_formula_reduced\" : \"pretty_formula\" , \"chemical_formula_anonymous\" : \"formula_anonymous\" } }, \"length_aliases\" : { \"structures\" : { \"chemsys\" : \"nelements\" } } } Environment variables \u00b6 In order for the implementation to know where your configuration JSON file is located, you can set an environment variable OPTIMADE_CONFIG_FILE with the value of the full path to the JSON file. This variable is actually an extension of the configuration option config_file . By default, the server will try to load a JSON file called .optimade.json located in your home folder (or equivalent). Here the generally recognized environment variable prefix becomes evident, namely OPTIMADE_ or optimade_ . Hence, you can set (or overwrite) any configuration option from the server's defaults or a value read from the configuration JSON by setting an environment variable named OPTIMADE_<configuration_option> . List of configuration options \u00b6 See config.py for a complete list of configuration options. The following configuration file represents the default values for all configuration options: Default values for all configuration options { \"config_file\" : \"~/.optimade.json\" , \"debug\" : false , \"use_real_mongo\" : false , \"mongo_database\" : \"optimade\" , \"mongo_uri\" : \"localhost:27017\" , \"links_collection\" : \"links\" , \"references_collection\" : \"references\" , \"structures_collection\" : \"structures\" , \"page_limit\" : 20 , \"page_limit_max\" : 500 , \"default_db\" : \"test_server\" , \"base_url\" : null , \"implementation\" : { \"name\" : \"OPTIMADE Python Tools\" , \"version\" : \"0.13.3\" , \"source_url\" : \"https://github.com/Materials-Consortia/optimade-python-tools\" , \"maintainer\" : { \"email\" : \"dev@optimade.org\" } }, \"index_base_url\" : null , \"provider\" : { \"name\" : \"Example provider\" , \"description\" : \"Provider used for examples, not to be assigned to a real database\" , \"prefix\" : \"exmpl\" , \"homepage\" : \"https://example.com\" }, \"provider_fields\" : {}, \"aliases\" : {}, \"length_aliases\" : {}, \"index_links_path\" : \"./optimade/server/index_links.json\" , \"log_level\" : \"info\" , \"log_dir\" : \"/var/log/optimade/\" }","title":"Configuration"},{"location":"configuration/#configuration","text":"Since the server implementation is built with FastAPI , which uses pydantic , the configuration is based on pydantic's Setting management . This way of handling configuration options supports various different approaches to configure the server. We recommend either or a combination of the following: Set environment variables. Create a JSON file with an implementation's complete configuration. When adding a third, final option, this also represents the (descending) order of priority with which configuration values are determined: Use defaults in ServerConfig .","title":"Configuration"},{"location":"configuration/#the-json-configuration-file","text":"The main way of configuring the OPTIMADE server is by creating a configuration JSON file. An example of one that works with the example implementation can be found in optimade_config.json : Configuration file for the default OPTIMADE server { \"debug\" : false , \"default_db\" : \"test_server\" , \"base_url\" : \"http://localhost:5000\" , \"implementation\" : { \"name\" : \"Example implementation\" , \"source_url\" : \"https://github.com/Materials-Consortia/optimade-python-tools\" , \"maintainer\" : { \"email\" : \"dev@optimade.org\" } }, \"provider\" : { \"name\" : \"Example provider\" , \"description\" : \"Provider used for examples, not to be assigned to a real database\" , \"prefix\" : \"exmpl\" , \"homepage\" : \"https://example.com\" }, \"index_base_url\" : \"http://localhost:5001\" , \"provider_fields\" : { \"structures\" : [ \"band_gap\" , \"chemsys\" ] }, \"aliases\" : { \"structures\" : { \"id\" : \"task_id\" , \"immutable_id\" : \"_id\" , \"chemical_formula_descriptive\" : \"pretty_formula\" , \"chemical_formula_reduced\" : \"pretty_formula\" , \"chemical_formula_anonymous\" : \"formula_anonymous\" } }, \"length_aliases\" : { \"structures\" : { \"chemsys\" : \"nelements\" } } }","title":"The JSON configuration file"},{"location":"configuration/#environment-variables","text":"In order for the implementation to know where your configuration JSON file is located, you can set an environment variable OPTIMADE_CONFIG_FILE with the value of the full path to the JSON file. This variable is actually an extension of the configuration option config_file . By default, the server will try to load a JSON file called .optimade.json located in your home folder (or equivalent). Here the generally recognized environment variable prefix becomes evident, namely OPTIMADE_ or optimade_ . Hence, you can set (or overwrite) any configuration option from the server's defaults or a value read from the configuration JSON by setting an environment variable named OPTIMADE_<configuration_option> .","title":"Environment variables"},{"location":"configuration/#list-of-configuration-options","text":"See config.py for a complete list of configuration options. The following configuration file represents the default values for all configuration options: Default values for all configuration options { \"config_file\" : \"~/.optimade.json\" , \"debug\" : false , \"use_real_mongo\" : false , \"mongo_database\" : \"optimade\" , \"mongo_uri\" : \"localhost:27017\" , \"links_collection\" : \"links\" , \"references_collection\" : \"references\" , \"structures_collection\" : \"structures\" , \"page_limit\" : 20 , \"page_limit_max\" : 500 , \"default_db\" : \"test_server\" , \"base_url\" : null , \"implementation\" : { \"name\" : \"OPTIMADE Python Tools\" , \"version\" : \"0.13.3\" , \"source_url\" : \"https://github.com/Materials-Consortia/optimade-python-tools\" , \"maintainer\" : { \"email\" : \"dev@optimade.org\" } }, \"index_base_url\" : null , \"provider\" : { \"name\" : \"Example provider\" , \"description\" : \"Provider used for examples, not to be assigned to a real database\" , \"prefix\" : \"exmpl\" , \"homepage\" : \"https://example.com\" }, \"provider_fields\" : {}, \"aliases\" : {}, \"length_aliases\" : {}, \"index_links_path\" : \"./optimade/server/index_links.json\" , \"log_level\" : \"info\" , \"log_dir\" : \"/var/log/optimade/\" }","title":"List of configuration options"},{"location":"api_reference/adapters/base/","text":"base \u00b6 The base for all adapters. An entry resource adapter is a tool to wrap OPTIMADE JSON-deserialized Python dictionaries in the relevant pydantic model for the particular resource. This means data resources in an OPTIMADE REST API response can be converted to valid Python types written specifically for them. One can then use the standard pydantic functionality on the wrapped objects, reasoning about the embedded hierarchical types as well as retrieve default values for properties not supplied by the raw API response resource. Furthermore, the entry resource adapter allows conversion between the entry resource and any implemented equivalent data structure. See Reference and Structure to find out what the entry resources can be converted to for ReferenceResource s and StructureResource s, respectively. EntryAdapter \u00b6 Base class for lazy resource entry adapters. Attributes: Name Type Description ENTRY_RESOURCE EntryResource Entry resource to store entry as. _type_converters Dict[str, Callable] Dictionary of valid conversion types for entry. as_<_type_converters> Convert entry to a type listed in _type_converters . entry : EntryResource property writable \u00b6 Get OPTIMADE entry. Returns: Type Description EntryResource The entry resource. ENTRY_RESOURCE ( Resource ) pydantic-model \u00b6 The base model for an entry resource. __getattr__ ( self , name ) special \u00b6 Get converted entry or attribute from OPTIMADE entry. Support any level of \".\"-nested OPTIMADE ENTRY_RESOURCE attributes, e.g., attributes.species for StuctureResource . Note All nested attributes must individually be subclasses of pydantic.BaseModel , i.e., one can not access nested attributes in lists by passing a \".\"-nested name to this method, e.g., attributes.species.name or attributes.species[0].name will not work for variable name . Order: Try to return converted entry if using as_<_type_converters key> . Try to return OPTIMADE ENTRY_RESOURCE (nested) attribute. Try to return OPTIMADE ENTRY_RESOURCE.attributes (nested) attribute. Raise AttributeError . Parameters: Name Type Description Default name str Requested attribute. required Exceptions: Type Description AttributeError If the requested attribute is not recognized. See above for the description of the order in which an attribute is tested for validity. Source code in optimade/adapters/base.py def __getattr__ ( self , name : str ) -> Any : \"\"\"Get converted entry or attribute from OPTIMADE entry. Support any level of \".\"-nested OPTIMADE `ENTRY_RESOURCE` attributes, e.g., `attributes.species` for [`StuctureResource`][optimade.models.structures.StructureResource]. Note: All nested attributes must individually be subclasses of `pydantic.BaseModel`, i.e., one can not access nested attributes in lists by passing a \".\"-nested `name` to this method, e.g., `attributes.species.name` or `attributes.species[0].name` will not work for variable `name`. Order: - Try to return converted entry if using `as_<_type_converters key>`. - Try to return OPTIMADE `ENTRY_RESOURCE` (nested) attribute. - Try to return OPTIMADE `ENTRY_RESOURCE.attributes` (nested) attribute. - Raise `AttributeError`. Parameters: name (str): Requested attribute. Raises: AttributeError: If the requested attribute is not recognized. See above for the description of the order in which an attribute is tested for validity. \"\"\" # as_<entry_type> if name . startswith ( \"as_\" ): entry_type = \"_\" . join ( name . split ( \"_\" )[ 1 :]) return self . convert ( entry_type ) # Try returning ENTRY_RESOURCE attribute try : res = self . _get_model_attributes (( self . entry , self . entry . attributes ), name ) except AttributeError : pass else : return res # Non-valid attribute entry_resource_name = re . match ( r \"(<class ')([a-zA-Z_]+\\.)*([a-zA-Z_]+)('>)\" , str ( self . ENTRY_RESOURCE ) ) entry_resource_name = ( entry_resource_name . group ( 3 ) if entry_resource_name is not None else \"UNKNOWN RESOURCE\" ) raise AttributeError ( f \"Unknown attribute: { name } \\n \" \"If you want to get a converted entry as <entry_type> use `as_<entry_type>`, \" f \"where `<entry_type>` is one of { tuple ( self . _type_converters . keys ()) + tuple ( self . _common_converters . keys ()) } \\n \" f \"Otherwise, you can try to retrieve an OPTIMADE { entry_resource_name } attribute or property.\" ) __init__ ( self , entry ) special \u00b6 Parameters: Name Type Description Default entry dict A JSON OPTIMADE single resource entry. required Source code in optimade/adapters/base.py def __init__ ( self , entry : dict ) -> None : \"\"\" Parameters: entry (dict): A JSON OPTIMADE single resource entry. \"\"\" self . _entry = None self . _converted = {} self . entry = entry # Note that these return also the default values for otherwise non-provided properties. self . _common_converters = { \"json\" : self . entry . json , # Return JSON serialized string, see https://pydantic-docs.helpmanual.io/usage/exporting_models/#modeljson \"dict\" : self . entry . dict , # Return Python dict, see https://pydantic-docs.helpmanual.io/usage/exporting_models/#modeldict } convert ( self , format ) \u00b6 Convert OPTIMADE entry to desired format. Parameters: Name Type Description Default format str Type or format to which the entry should be converted. required Exceptions: Type Description AttributeError If format can not be found in _type_converters or _common_converters . Returns: Type Description Any The converted entry according to the desired format or type. Source code in optimade/adapters/base.py def convert ( self , format : str ) -> Any : \"\"\"Convert OPTIMADE entry to desired format. Parameters: format (str): Type or format to which the entry should be converted. Raises: AttributeError: If `format` can not be found in `_type_converters` or `_common_converters`. Returns: The converted entry according to the desired format or type. \"\"\" if ( format not in self . _type_converters and format not in self . _common_converters ): raise AttributeError ( f \"Non-valid entry type to convert to: { format } \\n \" f \"Valid entry types: { tuple ( self . _type_converters . keys ()) + tuple ( self . _common_converters . keys ()) } \" ) if self . _converted . get ( format , None ) is None : if format in self . _type_converters : self . _converted [ format ] = self . _type_converters [ format ]( self . entry ) else : self . _converted [ format ] = self . _common_converters [ format ]() return self . _converted [ format ]","title":"base"},{"location":"api_reference/adapters/base/#base","text":"The base for all adapters. An entry resource adapter is a tool to wrap OPTIMADE JSON-deserialized Python dictionaries in the relevant pydantic model for the particular resource. This means data resources in an OPTIMADE REST API response can be converted to valid Python types written specifically for them. One can then use the standard pydantic functionality on the wrapped objects, reasoning about the embedded hierarchical types as well as retrieve default values for properties not supplied by the raw API response resource. Furthermore, the entry resource adapter allows conversion between the entry resource and any implemented equivalent data structure. See Reference and Structure to find out what the entry resources can be converted to for ReferenceResource s and StructureResource s, respectively.","title":"base"},{"location":"api_reference/adapters/base/#optimade.adapters.base.EntryAdapter","text":"Base class for lazy resource entry adapters. Attributes: Name Type Description ENTRY_RESOURCE EntryResource Entry resource to store entry as. _type_converters Dict[str, Callable] Dictionary of valid conversion types for entry. as_<_type_converters> Convert entry to a type listed in _type_converters .","title":"EntryAdapter"},{"location":"api_reference/adapters/base/#optimade.adapters.base.EntryAdapter.entry","text":"Get OPTIMADE entry. Returns: Type Description EntryResource The entry resource.","title":"entry"},{"location":"api_reference/adapters/base/#optimade.adapters.base.EntryAdapter.ENTRY_RESOURCE","text":"The base model for an entry resource.","title":"ENTRY_RESOURCE"},{"location":"api_reference/adapters/base/#optimade.adapters.base.EntryAdapter.__getattr__","text":"Get converted entry or attribute from OPTIMADE entry. Support any level of \".\"-nested OPTIMADE ENTRY_RESOURCE attributes, e.g., attributes.species for StuctureResource . Note All nested attributes must individually be subclasses of pydantic.BaseModel , i.e., one can not access nested attributes in lists by passing a \".\"-nested name to this method, e.g., attributes.species.name or attributes.species[0].name will not work for variable name . Order: Try to return converted entry if using as_<_type_converters key> . Try to return OPTIMADE ENTRY_RESOURCE (nested) attribute. Try to return OPTIMADE ENTRY_RESOURCE.attributes (nested) attribute. Raise AttributeError . Parameters: Name Type Description Default name str Requested attribute. required Exceptions: Type Description AttributeError If the requested attribute is not recognized. See above for the description of the order in which an attribute is tested for validity. Source code in optimade/adapters/base.py def __getattr__ ( self , name : str ) -> Any : \"\"\"Get converted entry or attribute from OPTIMADE entry. Support any level of \".\"-nested OPTIMADE `ENTRY_RESOURCE` attributes, e.g., `attributes.species` for [`StuctureResource`][optimade.models.structures.StructureResource]. Note: All nested attributes must individually be subclasses of `pydantic.BaseModel`, i.e., one can not access nested attributes in lists by passing a \".\"-nested `name` to this method, e.g., `attributes.species.name` or `attributes.species[0].name` will not work for variable `name`. Order: - Try to return converted entry if using `as_<_type_converters key>`. - Try to return OPTIMADE `ENTRY_RESOURCE` (nested) attribute. - Try to return OPTIMADE `ENTRY_RESOURCE.attributes` (nested) attribute. - Raise `AttributeError`. Parameters: name (str): Requested attribute. Raises: AttributeError: If the requested attribute is not recognized. See above for the description of the order in which an attribute is tested for validity. \"\"\" # as_<entry_type> if name . startswith ( \"as_\" ): entry_type = \"_\" . join ( name . split ( \"_\" )[ 1 :]) return self . convert ( entry_type ) # Try returning ENTRY_RESOURCE attribute try : res = self . _get_model_attributes (( self . entry , self . entry . attributes ), name ) except AttributeError : pass else : return res # Non-valid attribute entry_resource_name = re . match ( r \"(<class ')([a-zA-Z_]+\\.)*([a-zA-Z_]+)('>)\" , str ( self . ENTRY_RESOURCE ) ) entry_resource_name = ( entry_resource_name . group ( 3 ) if entry_resource_name is not None else \"UNKNOWN RESOURCE\" ) raise AttributeError ( f \"Unknown attribute: { name } \\n \" \"If you want to get a converted entry as <entry_type> use `as_<entry_type>`, \" f \"where `<entry_type>` is one of { tuple ( self . _type_converters . keys ()) + tuple ( self . _common_converters . keys ()) } \\n \" f \"Otherwise, you can try to retrieve an OPTIMADE { entry_resource_name } attribute or property.\" )","title":"__getattr__()"},{"location":"api_reference/adapters/base/#optimade.adapters.base.EntryAdapter.__init__","text":"Parameters: Name Type Description Default entry dict A JSON OPTIMADE single resource entry. required Source code in optimade/adapters/base.py def __init__ ( self , entry : dict ) -> None : \"\"\" Parameters: entry (dict): A JSON OPTIMADE single resource entry. \"\"\" self . _entry = None self . _converted = {} self . entry = entry # Note that these return also the default values for otherwise non-provided properties. self . _common_converters = { \"json\" : self . entry . json , # Return JSON serialized string, see https://pydantic-docs.helpmanual.io/usage/exporting_models/#modeljson \"dict\" : self . entry . dict , # Return Python dict, see https://pydantic-docs.helpmanual.io/usage/exporting_models/#modeldict }","title":"__init__()"},{"location":"api_reference/adapters/base/#optimade.adapters.base.EntryAdapter.convert","text":"Convert OPTIMADE entry to desired format. Parameters: Name Type Description Default format str Type or format to which the entry should be converted. required Exceptions: Type Description AttributeError If format can not be found in _type_converters or _common_converters . Returns: Type Description Any The converted entry according to the desired format or type. Source code in optimade/adapters/base.py def convert ( self , format : str ) -> Any : \"\"\"Convert OPTIMADE entry to desired format. Parameters: format (str): Type or format to which the entry should be converted. Raises: AttributeError: If `format` can not be found in `_type_converters` or `_common_converters`. Returns: The converted entry according to the desired format or type. \"\"\" if ( format not in self . _type_converters and format not in self . _common_converters ): raise AttributeError ( f \"Non-valid entry type to convert to: { format } \\n \" f \"Valid entry types: { tuple ( self . _type_converters . keys ()) + tuple ( self . _common_converters . keys ()) } \" ) if self . _converted . get ( format , None ) is None : if format in self . _type_converters : self . _converted [ format ] = self . _type_converters [ format ]( self . entry ) else : self . _converted [ format ] = self . _common_converters [ format ]() return self . _converted [ format ]","title":"convert()"},{"location":"api_reference/adapters/exceptions/","text":"exceptions \u00b6 ConversionError ( Exception ) \u00b6 Could not convert entry to format","title":"exceptions"},{"location":"api_reference/adapters/exceptions/#exceptions","text":"","title":"exceptions"},{"location":"api_reference/adapters/exceptions/#optimade.adapters.exceptions.ConversionError","text":"Could not convert entry to format","title":"ConversionError"},{"location":"api_reference/adapters/logger/","text":"logger \u00b6 Logger for optimade.adapters","title":"logger"},{"location":"api_reference/adapters/logger/#logger","text":"Logger for optimade.adapters","title":"logger"},{"location":"api_reference/adapters/warnings/","text":"warnings \u00b6 AdapterPackageNotFound ( OptimadeWarning ) \u00b6 The package for an adapter cannot be found. ConversionWarning ( OptimadeWarning ) \u00b6 A non-critical error/fallback/choice happened during conversion of an entry to format.","title":"warnings"},{"location":"api_reference/adapters/warnings/#warnings","text":"","title":"warnings"},{"location":"api_reference/adapters/warnings/#optimade.adapters.warnings.AdapterPackageNotFound","text":"The package for an adapter cannot be found.","title":"AdapterPackageNotFound"},{"location":"api_reference/adapters/warnings/#optimade.adapters.warnings.ConversionWarning","text":"A non-critical error/fallback/choice happened during conversion of an entry to format.","title":"ConversionWarning"},{"location":"api_reference/adapters/references/adapter/","text":"adapter \u00b6 Reference ( EntryAdapter ) \u00b6 Lazy reference resource converter. Go to EntryAdapter to see the full list of methods and properties. Attributes: Name Type Description ENTRY_RESOURCE ReferenceResource This adapter stores entry resources as ReferenceResource s. _type_converters Dict[str, Callable] Dictionary of valid conversion types for entry. There are currently no available types. as_<_type_converters> Convert entry to a type listed in _type_converters . ENTRY_RESOURCE ( EntryResource ) pydantic-model \u00b6 The references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , volume , year : meanings of these properties match the BibTeX specification , values are strings; bib_type : type of the reference, corresponding to type property in the BibTeX specification, value is string; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., any of the properties MAY be null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties.","title":"adapter"},{"location":"api_reference/adapters/references/adapter/#adapter","text":"","title":"adapter"},{"location":"api_reference/adapters/references/adapter/#optimade.adapters.references.adapter.Reference","text":"Lazy reference resource converter. Go to EntryAdapter to see the full list of methods and properties. Attributes: Name Type Description ENTRY_RESOURCE ReferenceResource This adapter stores entry resources as ReferenceResource s. _type_converters Dict[str, Callable] Dictionary of valid conversion types for entry. There are currently no available types. as_<_type_converters> Convert entry to a type listed in _type_converters .","title":"Reference"},{"location":"api_reference/adapters/references/adapter/#optimade.adapters.references.adapter.Reference.ENTRY_RESOURCE","text":"The references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , volume , year : meanings of these properties match the BibTeX specification , values are strings; bib_type : type of the reference, corresponding to type property in the BibTeX specification, value is string; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., any of the properties MAY be null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties.","title":"ENTRY_RESOURCE"},{"location":"api_reference/adapters/structures/adapter/","text":"adapter \u00b6 Structure ( EntryAdapter ) \u00b6 Lazy structure resource converter. Go to EntryAdapter to see the full list of methods and properties. Attributes: Name Type Description ENTRY_RESOURCE StructureResource This adapter stores entry resources as StructureResource s. _type_converters Dict[str, Callable] Dictionary of valid conversion types for entry. Currently available types: aiida_structuredata ase cif pdb pdbx_mmcif pymatgen jarvis as_<_type_converters> Convert entry to a type listed in _type_converters . ENTRY_RESOURCE ( EntryResource ) pydantic-model \u00b6 Representing a structure.","title":"adapter"},{"location":"api_reference/adapters/structures/adapter/#adapter","text":"","title":"adapter"},{"location":"api_reference/adapters/structures/adapter/#optimade.adapters.structures.adapter.Structure","text":"Lazy structure resource converter. Go to EntryAdapter to see the full list of methods and properties. Attributes: Name Type Description ENTRY_RESOURCE StructureResource This adapter stores entry resources as StructureResource s. _type_converters Dict[str, Callable] Dictionary of valid conversion types for entry. Currently available types: aiida_structuredata ase cif pdb pdbx_mmcif pymatgen jarvis as_<_type_converters> Convert entry to a type listed in _type_converters .","title":"Structure"},{"location":"api_reference/adapters/structures/adapter/#optimade.adapters.structures.adapter.Structure.ENTRY_RESOURCE","text":"Representing a structure.","title":"ENTRY_RESOURCE"},{"location":"api_reference/adapters/structures/aiida/","text":"aiida \u00b6 Convert an OPTIMADE structure, in the format of StructureResource to an AiiDA StructureData Node. For more information on the AiiDA code see their website . This conversion function relies on the aiida-core package. get_aiida_structure_data ( optimade_structure ) \u00b6 Get AiiDA StructureData from OPTIMADE structure. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description StructureData AiiDA StructureData Node. Source code in optimade/adapters/structures/aiida.py def get_aiida_structure_data ( optimade_structure : OptimadeStructure ) -> StructureData : \"\"\"Get AiiDA `StructureData` from OPTIMADE structure. Parameters: optimade_structure: OPTIMADE structure. Returns: AiiDA `StructureData` Node. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"StructureData\" )): warn ( AIIDA_NOT_FOUND , AdapterPackageNotFound ) return None attributes = optimade_structure . attributes # Convert null/None values to float(\"nan\") lattice_vectors , adjust_cell = pad_cell ( attributes . lattice_vectors ) structure = StructureData ( cell = lattice_vectors ) # Add Kinds for kind in attributes . species : symbols = [] concentration = [] mass = 0.0 for index , chemical_symbol in enumerate ( kind . chemical_symbols ): # NOTE: The non-chemical element identifier \"X\" is identical to how AiiDA handles this, # so it will be treated the same as any other true chemical identifier. if chemical_symbol == \"vacancy\" : # Skip. This is how AiiDA handles vacancies; # to not include them, while keeping the concentration in a site less than 1. continue else : symbols . append ( chemical_symbol ) concentration . append ( kind . concentration [ index ]) # AiiDA needs a definition for the mass, and for it to be > 0 # mass is OPTIONAL for OPTIMADE structures if kind . mass : mass += kind . concentration [ index ] * kind . mass [ index ] if not mass : warn ( f \"No mass defined for <species(name= { kind . name !r} )>, will default to setting mass to 1.0.\" , ConversionWarning , ) structure . append_kind ( Kind ( symbols = symbols , weights = concentration , mass = mass or 1.0 , name = kind . name ) ) # Add Sites for index in range ( attributes . nsites ): # range() to ensure 1-to-1 between kind and site structure . append_site ( Site ( kind_name = attributes . species_at_sites [ index ], position = attributes . cartesian_site_positions [ index ], ) ) if adjust_cell : structure . _adjust_default_cell ( pbc = [ bool ( dim . value ) for dim in attributes . dimension_types ] ) return structure","title":"aiida"},{"location":"api_reference/adapters/structures/aiida/#aiida","text":"Convert an OPTIMADE structure, in the format of StructureResource to an AiiDA StructureData Node. For more information on the AiiDA code see their website . This conversion function relies on the aiida-core package.","title":"aiida"},{"location":"api_reference/adapters/structures/aiida/#optimade.adapters.structures.aiida.get_aiida_structure_data","text":"Get AiiDA StructureData from OPTIMADE structure. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description StructureData AiiDA StructureData Node. Source code in optimade/adapters/structures/aiida.py def get_aiida_structure_data ( optimade_structure : OptimadeStructure ) -> StructureData : \"\"\"Get AiiDA `StructureData` from OPTIMADE structure. Parameters: optimade_structure: OPTIMADE structure. Returns: AiiDA `StructureData` Node. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"StructureData\" )): warn ( AIIDA_NOT_FOUND , AdapterPackageNotFound ) return None attributes = optimade_structure . attributes # Convert null/None values to float(\"nan\") lattice_vectors , adjust_cell = pad_cell ( attributes . lattice_vectors ) structure = StructureData ( cell = lattice_vectors ) # Add Kinds for kind in attributes . species : symbols = [] concentration = [] mass = 0.0 for index , chemical_symbol in enumerate ( kind . chemical_symbols ): # NOTE: The non-chemical element identifier \"X\" is identical to how AiiDA handles this, # so it will be treated the same as any other true chemical identifier. if chemical_symbol == \"vacancy\" : # Skip. This is how AiiDA handles vacancies; # to not include them, while keeping the concentration in a site less than 1. continue else : symbols . append ( chemical_symbol ) concentration . append ( kind . concentration [ index ]) # AiiDA needs a definition for the mass, and for it to be > 0 # mass is OPTIONAL for OPTIMADE structures if kind . mass : mass += kind . concentration [ index ] * kind . mass [ index ] if not mass : warn ( f \"No mass defined for <species(name= { kind . name !r} )>, will default to setting mass to 1.0.\" , ConversionWarning , ) structure . append_kind ( Kind ( symbols = symbols , weights = concentration , mass = mass or 1.0 , name = kind . name ) ) # Add Sites for index in range ( attributes . nsites ): # range() to ensure 1-to-1 between kind and site structure . append_site ( Site ( kind_name = attributes . species_at_sites [ index ], position = attributes . cartesian_site_positions [ index ], ) ) if adjust_cell : structure . _adjust_default_cell ( pbc = [ bool ( dim . value ) for dim in attributes . dimension_types ] ) return structure","title":"get_aiida_structure_data()"},{"location":"api_reference/adapters/structures/ase/","text":"ase \u00b6 Convert an OPTIMADE structure, in the format of StructureResource to an ASE Atoms object. This conversion function relies on the ASE code. For more information on the ASE code see their documentation . get_ase_atoms ( optimade_structure ) \u00b6 Get ASE Atoms from OPTIMADE structure. Caution Cannot handle partial occupancies (this includes vacancies). Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description Atoms ASE Atoms object. Source code in optimade/adapters/structures/ase.py def get_ase_atoms ( optimade_structure : OptimadeStructure ) -> Atoms : \"\"\"Get ASE `Atoms` from OPTIMADE structure. Caution: Cannot handle partial occupancies (this includes vacancies). Parameters: optimade_structure: OPTIMADE structure. Returns: ASE `Atoms` object. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"Atoms\" )): warn ( ASE_NOT_FOUND , AdapterPackageNotFound ) return None attributes = optimade_structure . attributes # Cannot handle partial occupancies if StructureFeatures . DISORDER in attributes . structure_features : raise ConversionError ( \"ASE cannot handle structures with partial occupancies, sorry.\" ) species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } # Since we've made sure there are no species with more than 1 chemical symbol, # asking for index 0 will always work. if \"X\" in [ specie . chemical_symbols [ 0 ] for specie in species . values ()]: raise ConversionError ( \"ASE cannot handle structures with unknown ('X') chemical symbols, sorry.\" ) atoms = [] for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = attributes . cartesian_site_positions [ site_number ] current_species = species [ species_name ] # Argument above about chemical symbols also holds here mass = None if current_species . mass : mass = current_species . mass [ 0 ] atoms . append ( Atom ( symbol = species_name , position = site , mass = mass )) return Atoms ( symbols = atoms , cell = attributes . lattice_vectors , pbc = attributes . dimension_types )","title":"ase"},{"location":"api_reference/adapters/structures/ase/#ase","text":"Convert an OPTIMADE structure, in the format of StructureResource to an ASE Atoms object. This conversion function relies on the ASE code. For more information on the ASE code see their documentation .","title":"ase"},{"location":"api_reference/adapters/structures/ase/#optimade.adapters.structures.ase.get_ase_atoms","text":"Get ASE Atoms from OPTIMADE structure. Caution Cannot handle partial occupancies (this includes vacancies). Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description Atoms ASE Atoms object. Source code in optimade/adapters/structures/ase.py def get_ase_atoms ( optimade_structure : OptimadeStructure ) -> Atoms : \"\"\"Get ASE `Atoms` from OPTIMADE structure. Caution: Cannot handle partial occupancies (this includes vacancies). Parameters: optimade_structure: OPTIMADE structure. Returns: ASE `Atoms` object. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"Atoms\" )): warn ( ASE_NOT_FOUND , AdapterPackageNotFound ) return None attributes = optimade_structure . attributes # Cannot handle partial occupancies if StructureFeatures . DISORDER in attributes . structure_features : raise ConversionError ( \"ASE cannot handle structures with partial occupancies, sorry.\" ) species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } # Since we've made sure there are no species with more than 1 chemical symbol, # asking for index 0 will always work. if \"X\" in [ specie . chemical_symbols [ 0 ] for specie in species . values ()]: raise ConversionError ( \"ASE cannot handle structures with unknown ('X') chemical symbols, sorry.\" ) atoms = [] for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = attributes . cartesian_site_positions [ site_number ] current_species = species [ species_name ] # Argument above about chemical symbols also holds here mass = None if current_species . mass : mass = current_species . mass [ 0 ] atoms . append ( Atom ( symbol = species_name , position = site , mass = mass )) return Atoms ( symbols = atoms , cell = attributes . lattice_vectors , pbc = attributes . dimension_types )","title":"get_ase_atoms()"},{"location":"api_reference/adapters/structures/cif/","text":"cif \u00b6 Convert an OPTIMADE structure, in the format of StructureResource to a CIF file (Crystallographic Information File). For more information on the CIF file format, see the official documentation . Note This conversion function is inspired heavily by the similar conversion function in the ASE library. See here for the original ASE code. For more information on the ASE library, see their documentation . This conversion function relies on the NumPy library. get_cif ( optimade_structure ) \u00b6 Get CIF file as string from OPTIMADE structure. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description str The CIF file as a single Python str object. Source code in optimade/adapters/structures/cif.py def get_cif ( # pylint: disable=too-many-locals,too-many-branches optimade_structure : OptimadeStructure , ) -> str : \"\"\"Get CIF file as string from OPTIMADE structure. Parameters: optimade_structure: OPTIMADE structure. Returns: The CIF file as a single Python `str` object. \"\"\" # NumPy is needed for calculations if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cif = \"\"\"# # Created from an OPTIMADE structure. # # See https://www.optimade.org and/or # https://github.com/Materials-Consortia/OPTIMADE for more information. # \"\"\" cif += f \"data_ { optimade_structure . id } \\n\\n \" attributes = optimade_structure . attributes # Do this only if there's three non-zero lattice vectors # NOTE: This also negates handling of lattice_vectors with null/None values if all ( attributes . dimension_types ): a_vector , b_vector , c_vector , alpha , beta , gamma = cell_to_cellpar ( attributes . lattice_vectors ) cif += ( f \"_cell_length_a { a_vector : g } \\n \" f \"_cell_length_b { b_vector : g } \\n \" f \"_cell_length_c { c_vector : g } \\n \" f \"_cell_angle_alpha { alpha : g } \\n \" f \"_cell_angle_beta { beta : g } \\n \" f \"_cell_angle_gamma { gamma : g } \\n\\n \" ) cif += ( \"_symmetry_space_group_name_H-M 'P 1' \\n \" \"_symmetry_int_tables_number 1 \\n\\n \" \"loop_ \\n \" \" _symmetry_equiv_pos_as_xyz \\n \" \" 'x, y, z' \\n\\n \" ) # Since some structure viewers are having issues with cartesian coordinates, # we calculate the fractional coordinates if this is a 3D structure and we have all the necessary information. if not hasattr ( attributes , \"fractional_site_positions\" ): attributes . fractional_site_positions = fractional_coordinates ( cell = attributes . lattice_vectors , cartesian_positions = attributes . cartesian_site_positions , ) # NOTE: This is otherwise a bit ahead of its time, since this OPTIMADE property is part of an open PR. # See https://github.com/Materials-Consortia/OPTIMADE/pull/206 coord_type = ( \"fract\" if hasattr ( attributes , \"fractional_site_positions\" ) else \"Cartn\" ) cif += ( \"loop_ \\n \" \" _atom_site_type_symbol \\n \" # species.chemical_symbols \" _atom_site_label \\n \" # species.name + unique int \" _atom_site_occupancy \\n \" # species.concentration f \" _atom_site_ { coord_type } _x \\n \" # cartesian_site_positions f \" _atom_site_ { coord_type } _y \\n \" # cartesian_site_positions f \" _atom_site_ { coord_type } _z \\n \" # cartesian_site_positions \" _atom_site_thermal_displace_type \\n \" # Set to 'Biso' \" _atom_site_B_iso_or_equiv \\n \" # Set to 1.0:f ) if coord_type == \"fract\" : sites = attributes . fractional_site_positions else : sites = attributes . cartesian_site_positions species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } symbol_occurences = {} for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = sites [ site_number ] current_species = species [ species_name ] for index , symbol in enumerate ( current_species . chemical_symbols ): if symbol == \"vacancy\" : continue if symbol in symbol_occurences : symbol_occurences [ symbol ] += 1 else : symbol_occurences [ symbol ] = 1 label = f \" { symbol }{ symbol_occurences [ symbol ] } \" cif += ( f \" { symbol } { label } { current_species . concentration [ index ] : 6.4f } { site [ 0 ] : 8.5f } \" f \" { site [ 1 ] : 8.5f } { site [ 2 ] : 8.5f } { 'Biso' : 4 } { '1.000' : 6 } \\n \" ) return cif","title":"cif"},{"location":"api_reference/adapters/structures/cif/#cif","text":"Convert an OPTIMADE structure, in the format of StructureResource to a CIF file (Crystallographic Information File). For more information on the CIF file format, see the official documentation . Note This conversion function is inspired heavily by the similar conversion function in the ASE library. See here for the original ASE code. For more information on the ASE library, see their documentation . This conversion function relies on the NumPy library.","title":"cif"},{"location":"api_reference/adapters/structures/cif/#optimade.adapters.structures.cif.get_cif","text":"Get CIF file as string from OPTIMADE structure. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description str The CIF file as a single Python str object. Source code in optimade/adapters/structures/cif.py def get_cif ( # pylint: disable=too-many-locals,too-many-branches optimade_structure : OptimadeStructure , ) -> str : \"\"\"Get CIF file as string from OPTIMADE structure. Parameters: optimade_structure: OPTIMADE structure. Returns: The CIF file as a single Python `str` object. \"\"\" # NumPy is needed for calculations if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cif = \"\"\"# # Created from an OPTIMADE structure. # # See https://www.optimade.org and/or # https://github.com/Materials-Consortia/OPTIMADE for more information. # \"\"\" cif += f \"data_ { optimade_structure . id } \\n\\n \" attributes = optimade_structure . attributes # Do this only if there's three non-zero lattice vectors # NOTE: This also negates handling of lattice_vectors with null/None values if all ( attributes . dimension_types ): a_vector , b_vector , c_vector , alpha , beta , gamma = cell_to_cellpar ( attributes . lattice_vectors ) cif += ( f \"_cell_length_a { a_vector : g } \\n \" f \"_cell_length_b { b_vector : g } \\n \" f \"_cell_length_c { c_vector : g } \\n \" f \"_cell_angle_alpha { alpha : g } \\n \" f \"_cell_angle_beta { beta : g } \\n \" f \"_cell_angle_gamma { gamma : g } \\n\\n \" ) cif += ( \"_symmetry_space_group_name_H-M 'P 1' \\n \" \"_symmetry_int_tables_number 1 \\n\\n \" \"loop_ \\n \" \" _symmetry_equiv_pos_as_xyz \\n \" \" 'x, y, z' \\n\\n \" ) # Since some structure viewers are having issues with cartesian coordinates, # we calculate the fractional coordinates if this is a 3D structure and we have all the necessary information. if not hasattr ( attributes , \"fractional_site_positions\" ): attributes . fractional_site_positions = fractional_coordinates ( cell = attributes . lattice_vectors , cartesian_positions = attributes . cartesian_site_positions , ) # NOTE: This is otherwise a bit ahead of its time, since this OPTIMADE property is part of an open PR. # See https://github.com/Materials-Consortia/OPTIMADE/pull/206 coord_type = ( \"fract\" if hasattr ( attributes , \"fractional_site_positions\" ) else \"Cartn\" ) cif += ( \"loop_ \\n \" \" _atom_site_type_symbol \\n \" # species.chemical_symbols \" _atom_site_label \\n \" # species.name + unique int \" _atom_site_occupancy \\n \" # species.concentration f \" _atom_site_ { coord_type } _x \\n \" # cartesian_site_positions f \" _atom_site_ { coord_type } _y \\n \" # cartesian_site_positions f \" _atom_site_ { coord_type } _z \\n \" # cartesian_site_positions \" _atom_site_thermal_displace_type \\n \" # Set to 'Biso' \" _atom_site_B_iso_or_equiv \\n \" # Set to 1.0:f ) if coord_type == \"fract\" : sites = attributes . fractional_site_positions else : sites = attributes . cartesian_site_positions species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } symbol_occurences = {} for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = sites [ site_number ] current_species = species [ species_name ] for index , symbol in enumerate ( current_species . chemical_symbols ): if symbol == \"vacancy\" : continue if symbol in symbol_occurences : symbol_occurences [ symbol ] += 1 else : symbol_occurences [ symbol ] = 1 label = f \" { symbol }{ symbol_occurences [ symbol ] } \" cif += ( f \" { symbol } { label } { current_species . concentration [ index ] : 6.4f } { site [ 0 ] : 8.5f } \" f \" { site [ 1 ] : 8.5f } { site [ 2 ] : 8.5f } { 'Biso' : 4 } { '1.000' : 6 } \\n \" ) return cif","title":"get_cif()"},{"location":"api_reference/adapters/structures/jarvis/","text":"jarvis \u00b6 Convert an OPTIMADE structure, in the format of StructureResource to a JARVIS Atoms object. For more information on the NIST-JARVIS repository, see their website . This conversion function relies on the jarvis-tools package. Contributing author This conversion function was contributed by Kamal Choudhary ( @knc6 ). get_jarvis_atoms ( optimade_structure ) \u00b6 Get jarvis Atoms from OPTIMADE structure. Caution Cannot handle partial occupancies. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description Atoms A jarvis Atoms object. Source code in optimade/adapters/structures/jarvis.py def get_jarvis_atoms ( optimade_structure : OptimadeStructure ) -> Atoms : \"\"\"Get jarvis `Atoms` from OPTIMADE structure. Caution: Cannot handle partial occupancies. Parameters: optimade_structure: OPTIMADE structure. Returns: A jarvis `Atoms` object. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"Atoms\" )): warn ( JARVIS_NOT_FOUND , AdapterPackageNotFound ) return None attributes = optimade_structure . attributes # Cannot handle partial occupancies if StructureFeatures . DISORDER in attributes . structure_features : raise ConversionError ( \"jarvis-tools cannot handle structures with partial occupancies.\" ) return Atoms ( lattice_mat = attributes . lattice_vectors , elements = [ specie . name for specie in attributes . species ], coords = attributes . cartesian_site_positions , cartesian = True , )","title":"jarvis"},{"location":"api_reference/adapters/structures/jarvis/#jarvis","text":"Convert an OPTIMADE structure, in the format of StructureResource to a JARVIS Atoms object. For more information on the NIST-JARVIS repository, see their website . This conversion function relies on the jarvis-tools package. Contributing author This conversion function was contributed by Kamal Choudhary ( @knc6 ).","title":"jarvis"},{"location":"api_reference/adapters/structures/jarvis/#optimade.adapters.structures.jarvis.get_jarvis_atoms","text":"Get jarvis Atoms from OPTIMADE structure. Caution Cannot handle partial occupancies. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description Atoms A jarvis Atoms object. Source code in optimade/adapters/structures/jarvis.py def get_jarvis_atoms ( optimade_structure : OptimadeStructure ) -> Atoms : \"\"\"Get jarvis `Atoms` from OPTIMADE structure. Caution: Cannot handle partial occupancies. Parameters: optimade_structure: OPTIMADE structure. Returns: A jarvis `Atoms` object. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"Atoms\" )): warn ( JARVIS_NOT_FOUND , AdapterPackageNotFound ) return None attributes = optimade_structure . attributes # Cannot handle partial occupancies if StructureFeatures . DISORDER in attributes . structure_features : raise ConversionError ( \"jarvis-tools cannot handle structures with partial occupancies.\" ) return Atoms ( lattice_mat = attributes . lattice_vectors , elements = [ specie . name for specie in attributes . species ], coords = attributes . cartesian_site_positions , cartesian = True , )","title":"get_jarvis_atoms()"},{"location":"api_reference/adapters/structures/proteindatabank/","text":"proteindatabank \u00b6 Convert an OPTIMADE structure, in the format of StructureResource to a PDB file or PDBx/mmCIF file (Protein Data Bank). For more information on the file formats, see this FAQ page from the wwPDB website. Note These conversion functions are inspired heavily by the similar conversion functions in the ASE library. See here (PDB) and here (PDBx/mmCIF) for the original ASE code. For more information on the ASE library, see their documentation . These conversion functions both rely on the NumPy library. Warning Currently, the PDBx/mmCIF conversion function is not parsing as a complete PDBx/mmCIF file. get_pdb ( optimade_structure ) \u00b6 Write Protein Data Bank (PDB) structure in the old PDB format from OPTIMADE structure. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description str A PDB file as a single Python str object. Source code in optimade/adapters/structures/proteindatabank.py def get_pdb ( # pylint: disable=too-many-locals optimade_structure : OptimadeStructure , ) -> str : \"\"\"Write Protein Data Bank (PDB) structure in the old PDB format from OPTIMADE structure. Parameters: optimade_structure: OPTIMADE structure. Returns: A PDB file as a single Python `str` object. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None pdb = \"\" attributes = optimade_structure . attributes rotation = None if all ( attributes . dimension_types ): currentcell = np . asarray ( attributes . lattice_vectors ) cellpar = cell_to_cellpar ( currentcell ) exportedcell = cellpar_to_cell ( cellpar ) rotation = np . linalg . solve ( currentcell , exportedcell ) # Setting Z-value = 1 and using P1 since we have all atoms defined explicitly Z = 1 spacegroup = \"P 1\" pdb += ( f \"CRYST1 { cellpar [ 0 ] : 9.3f }{ cellpar [ 1 ] : 9.3f }{ cellpar [ 2 ] : 8.3f } \" f \" { cellpar [ 3 ] : 7.2f }{ cellpar [ 4 ] : 7.2f }{ cellpar [ 5 ] : 7.2f } { spacegroup : 11s }{ Z : 4d } \\n \" ) for i , vector in enumerate ( scaled_cell ( currentcell )): pdb += f \"SCALE { i + 1 } { vector [ 0 ] : 10.6f }{ vector [ 1 ] : 10.6f }{ vector [ 2 ] : 10.6f } { 0 : 10.5f } \\n \" # There is a limit of 5 digit numbers in this field. pdb_maxnum = 100000 bfactor = 1.0 pdb += \"MODEL 1 \\n \" species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } sites = np . asarray ( attributes . cartesian_site_positions ) if rotation is not None : sites = sites . dot ( rotation ) for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = sites [ site_number ] current_species = species [ species_name ] for index , symbol in enumerate ( current_species . chemical_symbols ): if symbol == \"vacancy\" : continue label = species_name if len ( current_species . chemical_symbols ) > 1 : if ( \"vacancy\" in current_species . chemical_symbols and len ( current_species . chemical_symbols ) == 2 ): pass else : label = f \" { symbol }{ index + 1 } \" pdb += ( f \"ATOM { site_number % pdb_maxnum : 5d } { label : 4 } MOL 1 \" f \" { site [ 0 ] : 8.3f }{ site [ 1 ] : 8.3f }{ site [ 2 ] : 8.3f } \" f \" { current_species . concentration [ index ] : 6.2f } \" f \" { bfactor : 6.2f } { symbol . upper () : 2 } \\n \" ) pdb += \"ENDMDL \\n \" return pdb get_pdbx_mmcif ( optimade_structure ) \u00b6 Write Protein Data Bank (PDB) structure in the PDBx/mmCIF format from OPTIMADE structure. Warning The result of this function can currently not be parsed as a complete PDBx/mmCIF file. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description str A modern PDBx/mmCIF file as a single Python str object. Source code in optimade/adapters/structures/proteindatabank.py def get_pdbx_mmcif ( # pylint: disable=too-many-locals optimade_structure : OptimadeStructure , ) -> str : \"\"\"Write Protein Data Bank (PDB) structure in the PDBx/mmCIF format from OPTIMADE structure. Warning: The result of this function can currently not be parsed as a complete PDBx/mmCIF file. Parameters: optimade_structure: OPTIMADE structure. Return: A modern PDBx/mmCIF file as a single Python `str` object. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cif = \"\"\"# # Created from an OPTIMADE structure. # # See https://www.optimade.org and/or # https://github.com/Materials-Consortia/OPTIMADE for more information. # # CIF 2.0 format, specifically mmCIF (PDBx). # See http://mmcif.wwpdb.org for more information. # \"\"\" entry_id = f \" { optimade_structure . type }{ optimade_structure . id } \" cif += f \"data_ { entry_id } \\n _entry.id { entry_id } \\n # \\n \" attributes = optimade_structure . attributes # Do this only if there's three non-zero lattice vectors if all ( attributes . dimension_types ): a_vector , b_vector , c_vector , alpha , beta , gamma = cell_to_cellpar ( attributes . lattice_vectors ) cif += ( f \"_cell.entry_id { entry_id } \\n \" f \"_cell.length_a { a_vector : g } \\n \" f \"_cell.length_b { b_vector : g } \\n \" f \"_cell.length_c { c_vector : g } \\n \" f \"_cell.angle_alpha { alpha : g } \\n \" f \"_cell.angle_beta { beta : g } \\n \" f \"_cell.angle_gamma { gamma : g } \\n \" \"_cell.Z_PDB 1 \\n # \\n \" ) cif += ( f \"_symmetry.entry_id { entry_id } \\n \" \"_symmetry.space_group_name_H-M 'P 1' \\n \" \"_symmetry.Int_Tables_number 1 \\n # \\n \" ) # Since some structure viewers are having issues with cartesian coordinates, # we calculate the fractional coordinates if this is a 3D structure and we have all the necessary information. if not hasattr ( attributes , \"fractional_site_positions\" ): attributes . fractional_site_positions = fractional_coordinates ( cell = attributes . lattice_vectors , cartesian_positions = attributes . cartesian_site_positions , ) # NOTE: The following lines are perhaps needed to create a \"valid\" PDBx/mmCIF file. # However, at the same time, the information here is \"default\" and will for all structures \"at this moment in time\" # be the same. I.e., no information is gained by adding this now. # If it is found that they indeed are needed to create a \"valid\" PDBx/mmCIF file, they should be included in the output. # cif += ( # \"loop_\\n\" # \"_struct_asym.id\\n\" # \"_struct_asym.entity_id\\n\" # \"A 1\\n#\\n\" # At this point, not using this feature. # ) # cif += ( # \"loop_\\n\" # \"_chem_comp.id\\n\" # \"X\\n#\\n\" # At this point, not using this feature. # ) # cif += ( # \"loop_\\n\" # \"_entity.id\\n\" # \"1\\n#\\n\" # At this point, not using this feature. # ) # NOTE: This is otherwise a bit ahead of its time, since this OPTIMADE property is part of an open PR. # See https://github.com/Materials-Consortia/OPTIMADE/pull/206 coord_type = ( \"fract\" if hasattr ( attributes , \"fractional_site_positions\" ) else \"Cartn\" ) cif += ( \"loop_ \\n \" \"_atom_site.group_PDB \\n \" # Always \"ATOM\" \"_atom_site.id \\n \" # number (1-counting) \"_atom_site.type_symbol \\n \" # species.chemical_symbols \"_atom_site.label_atom_id \\n \" # species.checmical_symbols symbol + number # For these next keys, see the comment above. # \"_atom_site.label_asym_id\\n\" # Will be set to \"A\" _struct_asym.id above # \"_atom_site.label_comp_id\\n\" # Will be set to \"X\" _chem_comp.id above # \"_atom_site.label_entity_id\\n\" # Will be set to \"1\" _entity.id above # \"_atom_site.label_seq_id\\n\" \"_atom_site.occupancy \\n \" # species.concentration f \"_atom_site. { coord_type } _x \\n \" # cartesian_site_positions f \"_atom_site. { coord_type } _y \\n \" # cartesian_site_positions f \"_atom_site. { coord_type } _z \\n \" # cartesian_site_positions \"_atom_site.thermal_displace_type \\n \" # Set to 'Biso' \"_atom_site.B_iso_or_equiv \\n \" # Set to 1.0:f ) if coord_type == \"fract\" : sites = attributes . fractional_site_positions else : sites = attributes . cartesian_site_positions species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = sites [ site_number ] current_species = species [ species_name ] for index , symbol in enumerate ( current_species . chemical_symbols ): if symbol == \"vacancy\" : continue label = f \" { species_name . upper () }{ site_number + 1 } \" if len ( current_species . chemical_symbols ) > 1 : if ( \"vacancy\" in current_species . chemical_symbols and len ( current_species . chemical_symbols ) == 2 ): pass else : label = f \" { symbol . upper () }{ index + 1 } \" cif += ( f \"ATOM { site_number + 1 : 5d } { symbol } { label : 8 } \" f \" { current_species . concentration [ index ] : 6.4f } { site [ 0 ] : 8.5f } \" f \" { site [ 1 ] : 8.5f } { site [ 2 ] : 8.5f } { 'Biso' : 4 } { '1.000' : 6 } \\n \" ) return cif","title":"proteindatabank"},{"location":"api_reference/adapters/structures/proteindatabank/#proteindatabank","text":"Convert an OPTIMADE structure, in the format of StructureResource to a PDB file or PDBx/mmCIF file (Protein Data Bank). For more information on the file formats, see this FAQ page from the wwPDB website. Note These conversion functions are inspired heavily by the similar conversion functions in the ASE library. See here (PDB) and here (PDBx/mmCIF) for the original ASE code. For more information on the ASE library, see their documentation . These conversion functions both rely on the NumPy library. Warning Currently, the PDBx/mmCIF conversion function is not parsing as a complete PDBx/mmCIF file.","title":"proteindatabank"},{"location":"api_reference/adapters/structures/proteindatabank/#optimade.adapters.structures.proteindatabank.get_pdb","text":"Write Protein Data Bank (PDB) structure in the old PDB format from OPTIMADE structure. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description str A PDB file as a single Python str object. Source code in optimade/adapters/structures/proteindatabank.py def get_pdb ( # pylint: disable=too-many-locals optimade_structure : OptimadeStructure , ) -> str : \"\"\"Write Protein Data Bank (PDB) structure in the old PDB format from OPTIMADE structure. Parameters: optimade_structure: OPTIMADE structure. Returns: A PDB file as a single Python `str` object. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None pdb = \"\" attributes = optimade_structure . attributes rotation = None if all ( attributes . dimension_types ): currentcell = np . asarray ( attributes . lattice_vectors ) cellpar = cell_to_cellpar ( currentcell ) exportedcell = cellpar_to_cell ( cellpar ) rotation = np . linalg . solve ( currentcell , exportedcell ) # Setting Z-value = 1 and using P1 since we have all atoms defined explicitly Z = 1 spacegroup = \"P 1\" pdb += ( f \"CRYST1 { cellpar [ 0 ] : 9.3f }{ cellpar [ 1 ] : 9.3f }{ cellpar [ 2 ] : 8.3f } \" f \" { cellpar [ 3 ] : 7.2f }{ cellpar [ 4 ] : 7.2f }{ cellpar [ 5 ] : 7.2f } { spacegroup : 11s }{ Z : 4d } \\n \" ) for i , vector in enumerate ( scaled_cell ( currentcell )): pdb += f \"SCALE { i + 1 } { vector [ 0 ] : 10.6f }{ vector [ 1 ] : 10.6f }{ vector [ 2 ] : 10.6f } { 0 : 10.5f } \\n \" # There is a limit of 5 digit numbers in this field. pdb_maxnum = 100000 bfactor = 1.0 pdb += \"MODEL 1 \\n \" species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } sites = np . asarray ( attributes . cartesian_site_positions ) if rotation is not None : sites = sites . dot ( rotation ) for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = sites [ site_number ] current_species = species [ species_name ] for index , symbol in enumerate ( current_species . chemical_symbols ): if symbol == \"vacancy\" : continue label = species_name if len ( current_species . chemical_symbols ) > 1 : if ( \"vacancy\" in current_species . chemical_symbols and len ( current_species . chemical_symbols ) == 2 ): pass else : label = f \" { symbol }{ index + 1 } \" pdb += ( f \"ATOM { site_number % pdb_maxnum : 5d } { label : 4 } MOL 1 \" f \" { site [ 0 ] : 8.3f }{ site [ 1 ] : 8.3f }{ site [ 2 ] : 8.3f } \" f \" { current_species . concentration [ index ] : 6.2f } \" f \" { bfactor : 6.2f } { symbol . upper () : 2 } \\n \" ) pdb += \"ENDMDL \\n \" return pdb","title":"get_pdb()"},{"location":"api_reference/adapters/structures/proteindatabank/#optimade.adapters.structures.proteindatabank.get_pdbx_mmcif","text":"Write Protein Data Bank (PDB) structure in the PDBx/mmCIF format from OPTIMADE structure. Warning The result of this function can currently not be parsed as a complete PDBx/mmCIF file. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description str A modern PDBx/mmCIF file as a single Python str object. Source code in optimade/adapters/structures/proteindatabank.py def get_pdbx_mmcif ( # pylint: disable=too-many-locals optimade_structure : OptimadeStructure , ) -> str : \"\"\"Write Protein Data Bank (PDB) structure in the PDBx/mmCIF format from OPTIMADE structure. Warning: The result of this function can currently not be parsed as a complete PDBx/mmCIF file. Parameters: optimade_structure: OPTIMADE structure. Return: A modern PDBx/mmCIF file as a single Python `str` object. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cif = \"\"\"# # Created from an OPTIMADE structure. # # See https://www.optimade.org and/or # https://github.com/Materials-Consortia/OPTIMADE for more information. # # CIF 2.0 format, specifically mmCIF (PDBx). # See http://mmcif.wwpdb.org for more information. # \"\"\" entry_id = f \" { optimade_structure . type }{ optimade_structure . id } \" cif += f \"data_ { entry_id } \\n _entry.id { entry_id } \\n # \\n \" attributes = optimade_structure . attributes # Do this only if there's three non-zero lattice vectors if all ( attributes . dimension_types ): a_vector , b_vector , c_vector , alpha , beta , gamma = cell_to_cellpar ( attributes . lattice_vectors ) cif += ( f \"_cell.entry_id { entry_id } \\n \" f \"_cell.length_a { a_vector : g } \\n \" f \"_cell.length_b { b_vector : g } \\n \" f \"_cell.length_c { c_vector : g } \\n \" f \"_cell.angle_alpha { alpha : g } \\n \" f \"_cell.angle_beta { beta : g } \\n \" f \"_cell.angle_gamma { gamma : g } \\n \" \"_cell.Z_PDB 1 \\n # \\n \" ) cif += ( f \"_symmetry.entry_id { entry_id } \\n \" \"_symmetry.space_group_name_H-M 'P 1' \\n \" \"_symmetry.Int_Tables_number 1 \\n # \\n \" ) # Since some structure viewers are having issues with cartesian coordinates, # we calculate the fractional coordinates if this is a 3D structure and we have all the necessary information. if not hasattr ( attributes , \"fractional_site_positions\" ): attributes . fractional_site_positions = fractional_coordinates ( cell = attributes . lattice_vectors , cartesian_positions = attributes . cartesian_site_positions , ) # NOTE: The following lines are perhaps needed to create a \"valid\" PDBx/mmCIF file. # However, at the same time, the information here is \"default\" and will for all structures \"at this moment in time\" # be the same. I.e., no information is gained by adding this now. # If it is found that they indeed are needed to create a \"valid\" PDBx/mmCIF file, they should be included in the output. # cif += ( # \"loop_\\n\" # \"_struct_asym.id\\n\" # \"_struct_asym.entity_id\\n\" # \"A 1\\n#\\n\" # At this point, not using this feature. # ) # cif += ( # \"loop_\\n\" # \"_chem_comp.id\\n\" # \"X\\n#\\n\" # At this point, not using this feature. # ) # cif += ( # \"loop_\\n\" # \"_entity.id\\n\" # \"1\\n#\\n\" # At this point, not using this feature. # ) # NOTE: This is otherwise a bit ahead of its time, since this OPTIMADE property is part of an open PR. # See https://github.com/Materials-Consortia/OPTIMADE/pull/206 coord_type = ( \"fract\" if hasattr ( attributes , \"fractional_site_positions\" ) else \"Cartn\" ) cif += ( \"loop_ \\n \" \"_atom_site.group_PDB \\n \" # Always \"ATOM\" \"_atom_site.id \\n \" # number (1-counting) \"_atom_site.type_symbol \\n \" # species.chemical_symbols \"_atom_site.label_atom_id \\n \" # species.checmical_symbols symbol + number # For these next keys, see the comment above. # \"_atom_site.label_asym_id\\n\" # Will be set to \"A\" _struct_asym.id above # \"_atom_site.label_comp_id\\n\" # Will be set to \"X\" _chem_comp.id above # \"_atom_site.label_entity_id\\n\" # Will be set to \"1\" _entity.id above # \"_atom_site.label_seq_id\\n\" \"_atom_site.occupancy \\n \" # species.concentration f \"_atom_site. { coord_type } _x \\n \" # cartesian_site_positions f \"_atom_site. { coord_type } _y \\n \" # cartesian_site_positions f \"_atom_site. { coord_type } _z \\n \" # cartesian_site_positions \"_atom_site.thermal_displace_type \\n \" # Set to 'Biso' \"_atom_site.B_iso_or_equiv \\n \" # Set to 1.0:f ) if coord_type == \"fract\" : sites = attributes . fractional_site_positions else : sites = attributes . cartesian_site_positions species : Dict [ str , OptimadeStructureSpecies ] = { species . name : species for species in attributes . species } for site_number in range ( attributes . nsites ): species_name = attributes . species_at_sites [ site_number ] site = sites [ site_number ] current_species = species [ species_name ] for index , symbol in enumerate ( current_species . chemical_symbols ): if symbol == \"vacancy\" : continue label = f \" { species_name . upper () }{ site_number + 1 } \" if len ( current_species . chemical_symbols ) > 1 : if ( \"vacancy\" in current_species . chemical_symbols and len ( current_species . chemical_symbols ) == 2 ): pass else : label = f \" { symbol . upper () }{ index + 1 } \" cif += ( f \"ATOM { site_number + 1 : 5d } { symbol } { label : 8 } \" f \" { current_species . concentration [ index ] : 6.4f } { site [ 0 ] : 8.5f } \" f \" { site [ 1 ] : 8.5f } { site [ 2 ] : 8.5f } { 'Biso' : 4 } { '1.000' : 6 } \\n \" ) return cif","title":"get_pdbx_mmcif()"},{"location":"api_reference/adapters/structures/pymatgen/","text":"pymatgen \u00b6 Convert an OPTIMADE structure, in the format of StructureResource to a pymatgen Molecule or Structure object. This conversion function relies on the pymatgen package. For more information on the pymatgen code see their documentation . get_pymatgen ( optimade_structure ) \u00b6 Get pymatgen Structure or Molecule from OPTIMADE structure. This function will return either a pymatgen Structure or Molecule based on the periodicity or periodic dimensionality of OPTIMADE structure. For bulk, three-dimensional structures, a pymatgen Structure is returned. This means, if the dimension_types attribute is comprised of all 1 s (or Periodicity.PERIODIC s). Otherwise, a pymatgen Molecule is returned. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description Union[pymatgen.core.structure.Structure, pymatgen.core.structure.Molecule] A pymatgen Structure or Molecule based on the periodicity of the OPTIMADE structure. Source code in optimade/adapters/structures/pymatgen.py def get_pymatgen ( optimade_structure : OptimadeStructure ) -> Union [ Structure , Molecule ]: \"\"\"Get pymatgen `Structure` or `Molecule` from OPTIMADE structure. This function will return either a pymatgen `Structure` or `Molecule` based on the periodicity or periodic dimensionality of OPTIMADE structure. For bulk, three-dimensional structures, a pymatgen `Structure` is returned. This means, if the [`dimension_types`][optimade.models.structures.StructureResourceAttributes.dimension_types] attribute is comprised of all `1`s (or [`Periodicity.PERIODIC`][optimade.models.structures.Periodicity.PERIODIC]s). Otherwise, a pymatgen `Molecule` is returned. Parameters: optimade_structure: OPTIMADE structure. Returns: A pymatgen `Structure` or `Molecule` based on the periodicity of the OPTIMADE structure. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"Structure\" )): warn ( PYMATGEN_NOT_FOUND , AdapterPackageNotFound ) return None if all ( optimade_structure . attributes . dimension_types ): return _get_structure ( optimade_structure ) return _get_molecule ( optimade_structure )","title":"pymatgen"},{"location":"api_reference/adapters/structures/pymatgen/#pymatgen","text":"Convert an OPTIMADE structure, in the format of StructureResource to a pymatgen Molecule or Structure object. This conversion function relies on the pymatgen package. For more information on the pymatgen code see their documentation .","title":"pymatgen"},{"location":"api_reference/adapters/structures/pymatgen/#optimade.adapters.structures.pymatgen.get_pymatgen","text":"Get pymatgen Structure or Molecule from OPTIMADE structure. This function will return either a pymatgen Structure or Molecule based on the periodicity or periodic dimensionality of OPTIMADE structure. For bulk, three-dimensional structures, a pymatgen Structure is returned. This means, if the dimension_types attribute is comprised of all 1 s (or Periodicity.PERIODIC s). Otherwise, a pymatgen Molecule is returned. Parameters: Name Type Description Default optimade_structure StructureResource OPTIMADE structure. required Returns: Type Description Union[pymatgen.core.structure.Structure, pymatgen.core.structure.Molecule] A pymatgen Structure or Molecule based on the periodicity of the OPTIMADE structure. Source code in optimade/adapters/structures/pymatgen.py def get_pymatgen ( optimade_structure : OptimadeStructure ) -> Union [ Structure , Molecule ]: \"\"\"Get pymatgen `Structure` or `Molecule` from OPTIMADE structure. This function will return either a pymatgen `Structure` or `Molecule` based on the periodicity or periodic dimensionality of OPTIMADE structure. For bulk, three-dimensional structures, a pymatgen `Structure` is returned. This means, if the [`dimension_types`][optimade.models.structures.StructureResourceAttributes.dimension_types] attribute is comprised of all `1`s (or [`Periodicity.PERIODIC`][optimade.models.structures.Periodicity.PERIODIC]s). Otherwise, a pymatgen `Molecule` is returned. Parameters: optimade_structure: OPTIMADE structure. Returns: A pymatgen `Structure` or `Molecule` based on the periodicity of the OPTIMADE structure. \"\"\" if \"optimade.adapters\" in repr ( globals () . get ( \"Structure\" )): warn ( PYMATGEN_NOT_FOUND , AdapterPackageNotFound ) return None if all ( optimade_structure . attributes . dimension_types ): return _get_structure ( optimade_structure ) return _get_molecule ( optimade_structure )","title":"get_pymatgen()"},{"location":"api_reference/adapters/structures/utils/","text":"utils \u00b6 Utility functions to help the conversion functions along. Most of these functions rely on the NumPy library. cell_to_cellpar ( cell , radians = False ) \u00b6 Returns the cell parameters [a, b, c, alpha, beta, gamma] . Angles are in degrees unless radian=True is used. Note Based on ASE code . Parameters: Name Type Description Default cell Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A Cartesian 3x3 cell. This equates to the lattice_vectors attribute. required radians bool Use radians instead of degrees (default) for angles. False Returns: Type Description List[float] The unit cell parameters as a list of float values. Source code in optimade/adapters/structures/utils.py def cell_to_cellpar ( cell : Tuple [ Vector3D , Vector3D , Vector3D ], radians : bool = False ) -> List [ float ]: \"\"\"Returns the cell parameters `[a, b, c, alpha, beta, gamma]`. Angles are in degrees unless `radian=True` is used. Note: Based on [ASE code](https://wiki.fysik.dtu.dk/ase/_modules/ase/geometry/cell.html#cell_to_cellpar). Parameters: cell: A Cartesian 3x3 cell. This equates to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. radians: Use radians instead of degrees (default) for angles. Returns: The unit cell parameters as a `list` of `float` values. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cell = np . asarray ( cell ) lengths = [ np . linalg . norm ( vector ) for vector in cell ] angles = [] for i in range ( 3 ): j = i - 1 k = i - 2 outer_product = lengths [ j ] * lengths [ k ] if outer_product > 1e-16 : x_vector = np . dot ( cell [ j ], cell [ k ]) / outer_product angle = 180.0 / np . pi * np . arccos ( x_vector ) else : angle = 90.0 angles . append ( angle ) if radians : angles = [ angle * np . pi / 180 for angle in angles ] return np . array ( lengths + angles ) cellpar_to_cell ( cellpar , ab_normal = ( 0 , 0 , 1 ), a_direction = None ) \u00b6 Return a 3x3 cell matrix from cellpar=[a,b,c,alpha,beta,gamma] . Angles must be in degrees. The returned cell is orientated such that a and b are normal to ab_normal and a is parallel to the projection of a_direction in the a-b plane. Default a_direction is (1,0,0), unless this is parallel to ab_normal , in which case default a_direction is (0,0,1). The returned cell has the vectors va, vb and vc along the rows. The cell will be oriented such that va and vb are normal to ab_normal and va will be along the projection of a_direction onto the a-b plane. Examples: >>> cell = cellpar_to_cell ([ 1 , 2 , 4 , 10 , 20 , 30 ], ( 0 , 1 , 1 ), ( 1 , 2 , 3 )) >>> np . round ( cell , 3 ) array ([[ 0.816 , - 0.408 , 0.408 ], [ 1.992 , - 0.13 , 0.13 ], [ 3.859 , - 0.745 , 0.745 ]]) Note Direct copy of ASE code . Parameters: Name Type Description Default cellpar List[float] The unit cell parameters as a list of float values. Note : The angles must be given in degrees. required ab_normal Tuple[int, int, int] Unit vector normal to the ab-plane. (0, 0, 1) a_direction Tuple[int, int, int] Unit vector defining the a-direction (default: (1, 0, 0) ). None Returns: Type Description List[types.ConstrainedListValue] A Cartesian 3x3 cell. This should equate to the lattice_vectors attribute. Source code in optimade/adapters/structures/utils.py def cellpar_to_cell ( cellpar : List [ float ], ab_normal : Tuple [ int , int , int ] = ( 0 , 0 , 1 ), a_direction : Tuple [ int , int , int ] = None , ) -> List [ Vector3D ]: \"\"\"Return a 3x3 cell matrix from `cellpar=[a,b,c,alpha,beta,gamma]`. Angles must be in degrees. The returned cell is orientated such that a and b are normal to `ab_normal` and a is parallel to the projection of `a_direction` in the a-b plane. Default `a_direction` is (1,0,0), unless this is parallel to `ab_normal`, in which case default `a_direction` is (0,0,1). The returned cell has the vectors va, vb and vc along the rows. The cell will be oriented such that va and vb are normal to `ab_normal` and va will be along the projection of `a_direction` onto the a-b plane. Example: >>> cell = cellpar_to_cell([1, 2, 4, 10, 20, 30], (0, 1, 1), (1, 2, 3)) >>> np.round(cell, 3) array([[ 0.816, -0.408, 0.408], [ 1.992, -0.13 , 0.13 ], [ 3.859, -0.745, 0.745]]) Note: Direct copy of [ASE code](https://wiki.fysik.dtu.dk/ase/_modules/ase/geometry/cell.html#cellpar_to_cell). Parameters: cellpar: The unit cell parameters as a `list` of `float` values. **Note**: The angles must be given in degrees. ab_normal: Unit vector normal to the ab-plane. a_direction: Unit vector defining the a-direction (default: `(1, 0, 0)`). Returns: A Cartesian 3x3 cell. This should equate to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None if a_direction is None : if np . linalg . norm ( np . cross ( ab_normal , ( 1 , 0 , 0 ))) < 1e-5 : a_direction = ( 0 , 0 , 1 ) else : a_direction = ( 1 , 0 , 0 ) # Define rotated X,Y,Z-system, with Z along ab_normal and X along # the projection of a_direction onto the normal plane of Z. a_direction_array = np . array ( a_direction ) Z = unit_vector ( ab_normal ) X = unit_vector ( a_direction_array - np . dot ( a_direction_array , Z ) * Z ) Y = np . cross ( Z , X ) # Express va, vb and vc in the X,Y,Z-system alpha , beta , gamma = 90.0 , 90.0 , 90.0 if isinstance ( cellpar , ( int , float )): a = b = c = cellpar elif len ( cellpar ) == 1 : a = b = c = cellpar [ 0 ] elif len ( cellpar ) == 3 : a , b , c = cellpar else : a , b , c , alpha , beta , gamma = cellpar # Handle orthorhombic cells separately to avoid rounding errors eps = 2 * np . spacing ( 90.0 , dtype = np . float64 ) # around 1.4e-14 # alpha if abs ( abs ( alpha ) - 90 ) < eps : cos_alpha = 0.0 else : cos_alpha = np . cos ( alpha * np . pi / 180.0 ) # beta if abs ( abs ( beta ) - 90 ) < eps : cos_beta = 0.0 else : cos_beta = np . cos ( beta * np . pi / 180.0 ) # gamma if abs ( gamma - 90 ) < eps : cos_gamma = 0.0 sin_gamma = 1.0 elif abs ( gamma + 90 ) < eps : cos_gamma = 0.0 sin_gamma = - 1.0 else : cos_gamma = np . cos ( gamma * np . pi / 180.0 ) sin_gamma = np . sin ( gamma * np . pi / 180.0 ) # Build the cell vectors va = a * np . array ([ 1 , 0 , 0 ]) vb = b * np . array ([ cos_gamma , sin_gamma , 0 ]) cx = cos_beta cy = ( cos_alpha - cos_beta * cos_gamma ) / sin_gamma cz_sqr = 1.0 - cx * cx - cy * cy assert cz_sqr >= 0 cz = np . sqrt ( cz_sqr ) vc = c * np . array ([ cx , cy , cz ]) # Convert to the Cartesian x,y,z-system abc = np . vstack (( va , vb , vc )) T = np . vstack (( X , Y , Z )) cell = np . dot ( abc , T ) return cell fractional_coordinates ( cell , cartesian_positions ) \u00b6 Returns fractional coordinates and wraps coordinates to [0,1[ . Note Based on ASE code . Parameters: Name Type Description Default cell Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A Cartesian 3x3 cell. This equates to the lattice_vectors attribute. required cartesian_positions List[types.ConstrainedListValue] A list of cartesian atomic positions. This equates to the cartesian_site_positions attribute. required Returns: Type Description List[types.ConstrainedListValue] A list of fractional coordinates for the atomic positions. Source code in optimade/adapters/structures/utils.py def fractional_coordinates ( cell : Tuple [ Vector3D , Vector3D , Vector3D ], cartesian_positions : List [ Vector3D ] ) -> List [ Vector3D ]: \"\"\"Returns fractional coordinates and wraps coordinates to `[0,1[`. Note: Based on [ASE code](https://wiki.fysik.dtu.dk/ase/_modules/ase/atoms.html#Atoms.get_scaled_positions). Parameters: cell: A Cartesian 3x3 cell. This equates to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. cartesian_positions: A list of cartesian atomic positions. This equates to the [`cartesian_site_positions`][optimade.models.structures.StructureResourceAttributes.cartesian_site_positions] attribute. Returns: A list of fractional coordinates for the atomic positions. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cell = np . asarray ( cell ) cartesian_positions = np . asarray ( cartesian_positions ) fractional = np . linalg . solve ( cell . T , cartesian_positions . T ) . T # Expecting a bulk 3D structure here, note, this may change in the future. # See `ase.atoms:Atoms.get_scaled_positions()` for ideas on how to handle lower dimensional structures. # Furthermore, according to ASE we need to modulo 1.0 twice. # This seems to be due to small floats % 1.0 becomes 1.0, hence twice makes it 0.0. for i in range ( 3 ): fractional [:, i ] %= 1.0 fractional [:, i ] %= 1.0 return [ tuple ( position ) for position in fractional ] pad_cell ( lattice_vectors , padding = None ) \u00b6 Turn any null / None values into a float in given tuple of lattice_vectors . Parameters: Name Type Description Default lattice_vectors Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A 3x3 cartesian cell. This is the lattice_vectors attribute. required padding float A value with which null or None values should be replaced. None Returns: Type Description Tuple[Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue], bool] The possibly redacted/padded lattice_vectors and a bool declaring whether or not the value has been redacted/padded or not, i.e., whether it contained null or None values. Source code in optimade/adapters/structures/utils.py def pad_cell ( lattice_vectors : Tuple [ Vector3D , Vector3D , Vector3D ], padding : float = None ) -> Tuple [ Tuple [ Vector3D , Vector3D , Vector3D ], bool ]: \"\"\"Turn any `null`/`None` values into a `float` in given `tuple` of [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors]. Parameters: lattice_vectors: A 3x3 cartesian cell. This is the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. padding: A value with which `null` or `None` values should be replaced. Returns: The possibly redacted/padded `lattice_vectors` and a `bool` declaring whether or not the value has been redacted/padded or not, i.e., whether it contained `null` or `None` values. \"\"\" return _pad_iter_of_iters ( iterable = lattice_vectors , padding = padding , outer = tuple , inner = tuple , ) scaled_cell ( cell ) \u00b6 Return a scaled 3x3 cell from cartesian 3x3 cell ( lattice_vectors ). This is based on PDB's method of calculating SCALE from CRYST data. For more info, see this site . Parameters: Name Type Description Default cell Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A Cartesian 3x3 cell. This equates to the lattice_vectors attribute. required Returns: Type Description Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A scaled 3x3 cell. Source code in optimade/adapters/structures/utils.py def scaled_cell ( cell : Tuple [ Vector3D , Vector3D , Vector3D ] ) -> Tuple [ Vector3D , Vector3D , Vector3D ]: \"\"\"Return a scaled 3x3 cell from cartesian 3x3 cell (`lattice_vectors`). This is based on PDB's method of calculating SCALE from CRYST data. For more info, see [this site](https://www.wwpdb.org/documentation/file-format-content/format33/sect8.html#SCALEn). Parameters: cell: A Cartesian 3x3 cell. This equates to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. Returns: A scaled 3x3 cell. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cell = np . asarray ( cell ) volume = np . dot ( cell [ 0 ], np . cross ( cell [ 1 ], cell [ 2 ])) scale = [] for i in range ( 3 ): vector = np . cross ( cell [( i + 1 ) % 3 ], cell [( i + 2 ) % 3 ]) / volume scale . append ( tuple ( vector )) return tuple ( scale ) unit_vector ( x ) \u00b6 Return a unit vector in the same direction as x . Parameters: Name Type Description Default x ConstrainedListValue A three-dimensional vector. required Returns: Type Description ConstrainedListValue A unit vector in the same direction as x . Source code in optimade/adapters/structures/utils.py def unit_vector ( x : Vector3D ) -> Vector3D : \"\"\"Return a unit vector in the same direction as `x`. Parameters: x: A three-dimensional vector. Returns: A unit vector in the same direction as `x`. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None y = np . array ( x , dtype = \"float\" ) return y / np . linalg . norm ( y )","title":"utils"},{"location":"api_reference/adapters/structures/utils/#utils","text":"Utility functions to help the conversion functions along. Most of these functions rely on the NumPy library.","title":"utils"},{"location":"api_reference/adapters/structures/utils/#optimade.adapters.structures.utils.cell_to_cellpar","text":"Returns the cell parameters [a, b, c, alpha, beta, gamma] . Angles are in degrees unless radian=True is used. Note Based on ASE code . Parameters: Name Type Description Default cell Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A Cartesian 3x3 cell. This equates to the lattice_vectors attribute. required radians bool Use radians instead of degrees (default) for angles. False Returns: Type Description List[float] The unit cell parameters as a list of float values. Source code in optimade/adapters/structures/utils.py def cell_to_cellpar ( cell : Tuple [ Vector3D , Vector3D , Vector3D ], radians : bool = False ) -> List [ float ]: \"\"\"Returns the cell parameters `[a, b, c, alpha, beta, gamma]`. Angles are in degrees unless `radian=True` is used. Note: Based on [ASE code](https://wiki.fysik.dtu.dk/ase/_modules/ase/geometry/cell.html#cell_to_cellpar). Parameters: cell: A Cartesian 3x3 cell. This equates to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. radians: Use radians instead of degrees (default) for angles. Returns: The unit cell parameters as a `list` of `float` values. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cell = np . asarray ( cell ) lengths = [ np . linalg . norm ( vector ) for vector in cell ] angles = [] for i in range ( 3 ): j = i - 1 k = i - 2 outer_product = lengths [ j ] * lengths [ k ] if outer_product > 1e-16 : x_vector = np . dot ( cell [ j ], cell [ k ]) / outer_product angle = 180.0 / np . pi * np . arccos ( x_vector ) else : angle = 90.0 angles . append ( angle ) if radians : angles = [ angle * np . pi / 180 for angle in angles ] return np . array ( lengths + angles )","title":"cell_to_cellpar()"},{"location":"api_reference/adapters/structures/utils/#optimade.adapters.structures.utils.cellpar_to_cell","text":"Return a 3x3 cell matrix from cellpar=[a,b,c,alpha,beta,gamma] . Angles must be in degrees. The returned cell is orientated such that a and b are normal to ab_normal and a is parallel to the projection of a_direction in the a-b plane. Default a_direction is (1,0,0), unless this is parallel to ab_normal , in which case default a_direction is (0,0,1). The returned cell has the vectors va, vb and vc along the rows. The cell will be oriented such that va and vb are normal to ab_normal and va will be along the projection of a_direction onto the a-b plane. Examples: >>> cell = cellpar_to_cell ([ 1 , 2 , 4 , 10 , 20 , 30 ], ( 0 , 1 , 1 ), ( 1 , 2 , 3 )) >>> np . round ( cell , 3 ) array ([[ 0.816 , - 0.408 , 0.408 ], [ 1.992 , - 0.13 , 0.13 ], [ 3.859 , - 0.745 , 0.745 ]]) Note Direct copy of ASE code . Parameters: Name Type Description Default cellpar List[float] The unit cell parameters as a list of float values. Note : The angles must be given in degrees. required ab_normal Tuple[int, int, int] Unit vector normal to the ab-plane. (0, 0, 1) a_direction Tuple[int, int, int] Unit vector defining the a-direction (default: (1, 0, 0) ). None Returns: Type Description List[types.ConstrainedListValue] A Cartesian 3x3 cell. This should equate to the lattice_vectors attribute. Source code in optimade/adapters/structures/utils.py def cellpar_to_cell ( cellpar : List [ float ], ab_normal : Tuple [ int , int , int ] = ( 0 , 0 , 1 ), a_direction : Tuple [ int , int , int ] = None , ) -> List [ Vector3D ]: \"\"\"Return a 3x3 cell matrix from `cellpar=[a,b,c,alpha,beta,gamma]`. Angles must be in degrees. The returned cell is orientated such that a and b are normal to `ab_normal` and a is parallel to the projection of `a_direction` in the a-b plane. Default `a_direction` is (1,0,0), unless this is parallel to `ab_normal`, in which case default `a_direction` is (0,0,1). The returned cell has the vectors va, vb and vc along the rows. The cell will be oriented such that va and vb are normal to `ab_normal` and va will be along the projection of `a_direction` onto the a-b plane. Example: >>> cell = cellpar_to_cell([1, 2, 4, 10, 20, 30], (0, 1, 1), (1, 2, 3)) >>> np.round(cell, 3) array([[ 0.816, -0.408, 0.408], [ 1.992, -0.13 , 0.13 ], [ 3.859, -0.745, 0.745]]) Note: Direct copy of [ASE code](https://wiki.fysik.dtu.dk/ase/_modules/ase/geometry/cell.html#cellpar_to_cell). Parameters: cellpar: The unit cell parameters as a `list` of `float` values. **Note**: The angles must be given in degrees. ab_normal: Unit vector normal to the ab-plane. a_direction: Unit vector defining the a-direction (default: `(1, 0, 0)`). Returns: A Cartesian 3x3 cell. This should equate to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None if a_direction is None : if np . linalg . norm ( np . cross ( ab_normal , ( 1 , 0 , 0 ))) < 1e-5 : a_direction = ( 0 , 0 , 1 ) else : a_direction = ( 1 , 0 , 0 ) # Define rotated X,Y,Z-system, with Z along ab_normal and X along # the projection of a_direction onto the normal plane of Z. a_direction_array = np . array ( a_direction ) Z = unit_vector ( ab_normal ) X = unit_vector ( a_direction_array - np . dot ( a_direction_array , Z ) * Z ) Y = np . cross ( Z , X ) # Express va, vb and vc in the X,Y,Z-system alpha , beta , gamma = 90.0 , 90.0 , 90.0 if isinstance ( cellpar , ( int , float )): a = b = c = cellpar elif len ( cellpar ) == 1 : a = b = c = cellpar [ 0 ] elif len ( cellpar ) == 3 : a , b , c = cellpar else : a , b , c , alpha , beta , gamma = cellpar # Handle orthorhombic cells separately to avoid rounding errors eps = 2 * np . spacing ( 90.0 , dtype = np . float64 ) # around 1.4e-14 # alpha if abs ( abs ( alpha ) - 90 ) < eps : cos_alpha = 0.0 else : cos_alpha = np . cos ( alpha * np . pi / 180.0 ) # beta if abs ( abs ( beta ) - 90 ) < eps : cos_beta = 0.0 else : cos_beta = np . cos ( beta * np . pi / 180.0 ) # gamma if abs ( gamma - 90 ) < eps : cos_gamma = 0.0 sin_gamma = 1.0 elif abs ( gamma + 90 ) < eps : cos_gamma = 0.0 sin_gamma = - 1.0 else : cos_gamma = np . cos ( gamma * np . pi / 180.0 ) sin_gamma = np . sin ( gamma * np . pi / 180.0 ) # Build the cell vectors va = a * np . array ([ 1 , 0 , 0 ]) vb = b * np . array ([ cos_gamma , sin_gamma , 0 ]) cx = cos_beta cy = ( cos_alpha - cos_beta * cos_gamma ) / sin_gamma cz_sqr = 1.0 - cx * cx - cy * cy assert cz_sqr >= 0 cz = np . sqrt ( cz_sqr ) vc = c * np . array ([ cx , cy , cz ]) # Convert to the Cartesian x,y,z-system abc = np . vstack (( va , vb , vc )) T = np . vstack (( X , Y , Z )) cell = np . dot ( abc , T ) return cell","title":"cellpar_to_cell()"},{"location":"api_reference/adapters/structures/utils/#optimade.adapters.structures.utils.fractional_coordinates","text":"Returns fractional coordinates and wraps coordinates to [0,1[ . Note Based on ASE code . Parameters: Name Type Description Default cell Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A Cartesian 3x3 cell. This equates to the lattice_vectors attribute. required cartesian_positions List[types.ConstrainedListValue] A list of cartesian atomic positions. This equates to the cartesian_site_positions attribute. required Returns: Type Description List[types.ConstrainedListValue] A list of fractional coordinates for the atomic positions. Source code in optimade/adapters/structures/utils.py def fractional_coordinates ( cell : Tuple [ Vector3D , Vector3D , Vector3D ], cartesian_positions : List [ Vector3D ] ) -> List [ Vector3D ]: \"\"\"Returns fractional coordinates and wraps coordinates to `[0,1[`. Note: Based on [ASE code](https://wiki.fysik.dtu.dk/ase/_modules/ase/atoms.html#Atoms.get_scaled_positions). Parameters: cell: A Cartesian 3x3 cell. This equates to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. cartesian_positions: A list of cartesian atomic positions. This equates to the [`cartesian_site_positions`][optimade.models.structures.StructureResourceAttributes.cartesian_site_positions] attribute. Returns: A list of fractional coordinates for the atomic positions. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cell = np . asarray ( cell ) cartesian_positions = np . asarray ( cartesian_positions ) fractional = np . linalg . solve ( cell . T , cartesian_positions . T ) . T # Expecting a bulk 3D structure here, note, this may change in the future. # See `ase.atoms:Atoms.get_scaled_positions()` for ideas on how to handle lower dimensional structures. # Furthermore, according to ASE we need to modulo 1.0 twice. # This seems to be due to small floats % 1.0 becomes 1.0, hence twice makes it 0.0. for i in range ( 3 ): fractional [:, i ] %= 1.0 fractional [:, i ] %= 1.0 return [ tuple ( position ) for position in fractional ]","title":"fractional_coordinates()"},{"location":"api_reference/adapters/structures/utils/#optimade.adapters.structures.utils.pad_cell","text":"Turn any null / None values into a float in given tuple of lattice_vectors . Parameters: Name Type Description Default lattice_vectors Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A 3x3 cartesian cell. This is the lattice_vectors attribute. required padding float A value with which null or None values should be replaced. None Returns: Type Description Tuple[Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue], bool] The possibly redacted/padded lattice_vectors and a bool declaring whether or not the value has been redacted/padded or not, i.e., whether it contained null or None values. Source code in optimade/adapters/structures/utils.py def pad_cell ( lattice_vectors : Tuple [ Vector3D , Vector3D , Vector3D ], padding : float = None ) -> Tuple [ Tuple [ Vector3D , Vector3D , Vector3D ], bool ]: \"\"\"Turn any `null`/`None` values into a `float` in given `tuple` of [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors]. Parameters: lattice_vectors: A 3x3 cartesian cell. This is the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. padding: A value with which `null` or `None` values should be replaced. Returns: The possibly redacted/padded `lattice_vectors` and a `bool` declaring whether or not the value has been redacted/padded or not, i.e., whether it contained `null` or `None` values. \"\"\" return _pad_iter_of_iters ( iterable = lattice_vectors , padding = padding , outer = tuple , inner = tuple , )","title":"pad_cell()"},{"location":"api_reference/adapters/structures/utils/#optimade.adapters.structures.utils.scaled_cell","text":"Return a scaled 3x3 cell from cartesian 3x3 cell ( lattice_vectors ). This is based on PDB's method of calculating SCALE from CRYST data. For more info, see this site . Parameters: Name Type Description Default cell Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A Cartesian 3x3 cell. This equates to the lattice_vectors attribute. required Returns: Type Description Tuple[types.ConstrainedListValue, types.ConstrainedListValue, types.ConstrainedListValue] A scaled 3x3 cell. Source code in optimade/adapters/structures/utils.py def scaled_cell ( cell : Tuple [ Vector3D , Vector3D , Vector3D ] ) -> Tuple [ Vector3D , Vector3D , Vector3D ]: \"\"\"Return a scaled 3x3 cell from cartesian 3x3 cell (`lattice_vectors`). This is based on PDB's method of calculating SCALE from CRYST data. For more info, see [this site](https://www.wwpdb.org/documentation/file-format-content/format33/sect8.html#SCALEn). Parameters: cell: A Cartesian 3x3 cell. This equates to the [`lattice_vectors`][optimade.models.structures.StructureResourceAttributes.lattice_vectors] attribute. Returns: A scaled 3x3 cell. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None cell = np . asarray ( cell ) volume = np . dot ( cell [ 0 ], np . cross ( cell [ 1 ], cell [ 2 ])) scale = [] for i in range ( 3 ): vector = np . cross ( cell [( i + 1 ) % 3 ], cell [( i + 2 ) % 3 ]) / volume scale . append ( tuple ( vector )) return tuple ( scale )","title":"scaled_cell()"},{"location":"api_reference/adapters/structures/utils/#optimade.adapters.structures.utils.unit_vector","text":"Return a unit vector in the same direction as x . Parameters: Name Type Description Default x ConstrainedListValue A three-dimensional vector. required Returns: Type Description ConstrainedListValue A unit vector in the same direction as x . Source code in optimade/adapters/structures/utils.py def unit_vector ( x : Vector3D ) -> Vector3D : \"\"\"Return a unit vector in the same direction as `x`. Parameters: x: A three-dimensional vector. Returns: A unit vector in the same direction as `x`. \"\"\" if globals () . get ( \"np\" , None ) is None : warn ( NUMPY_NOT_FOUND , AdapterPackageNotFound ) return None y = np . array ( x , dtype = \"float\" ) return y / np . linalg . norm ( y )","title":"unit_vector()"},{"location":"api_reference/filterparser/lark_parser/","text":"lark_parser \u00b6","title":"lark_parser"},{"location":"api_reference/filterparser/lark_parser/#lark_parser","text":"","title":"lark_parser"},{"location":"api_reference/filtertransformers/base_transformer/","text":"base_transformer \u00b6 BaseTransformer ( ABC , Transformer ) \u00b6 Generic filter transformer that handles various parts of the grammar in a backend non-specific way. __init__ ( self , mapper = None ) special \u00b6 Initialise the transformer object, optionally loading in a resource mapper for use when post-processing. Source code in optimade/filtertransformers/base_transformer.py def __init__ ( self , mapper : BaseResourceMapper = None ): \"\"\"Initialise the transformer object, optionally loading in a resource mapper for use when post-processing. \"\"\" self . mapper = mapper comparison ( self , value ) \u00b6 comparison: constant_first_comparison | property_first_comparison Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def comparison ( self , value ): \"\"\" comparison: constant_first_comparison | property_first_comparison \"\"\" # Note: Return as is. return value constant ( self , value ) \u00b6 constant: string | number Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def constant ( self , value ): \"\"\" constant: string | number \"\"\" # Note: Return as is. return value constant_first_comparison ( self , arg ) \u00b6 constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def constant_first_comparison ( self , arg ): \"\"\" constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) \"\"\" expression ( self , arg ) \u00b6 expression: expression_clause ( OR expression_clause ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def expression ( self , arg ): \"\"\" expression: expression_clause ( OR expression_clause ) \"\"\" expression_clause ( self , arg ) \u00b6 expression_clause: expression_phrase ( AND expression_phrase )* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def expression_clause ( self , arg ): \"\"\" expression_clause: expression_phrase ( AND expression_phrase )* \"\"\" expression_phrase ( self , arg ) \u00b6 expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def expression_phrase ( self , arg ): \"\"\" expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) \"\"\" filter ( self , arg ) \u00b6 filter: expression* Source code in optimade/filtertransformers/base_transformer.py def filter ( self , arg ): \"\"\" filter: expression* \"\"\" return arg [ 0 ] if arg else None fuzzy_string_op_rhs ( self , arg ) \u00b6 fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def fuzzy_string_op_rhs ( self , arg ): \"\"\" fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value \"\"\" known_op_rhs ( self , arg ) \u00b6 known_op_rhs: IS ( KNOWN | UNKNOWN ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def known_op_rhs ( self , arg ): \"\"\" known_op_rhs: IS ( KNOWN | UNKNOWN ) \"\"\" length_op_rhs ( self , arg ) \u00b6 length_op_rhs: LENGTH [ OPERATOR ] value Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def length_op_rhs ( self , arg ): \"\"\" length_op_rhs: LENGTH [ OPERATOR ] value \"\"\" non_string_value ( self , value ) \u00b6 non_string_value: number | property Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def non_string_value ( self , value ): \"\"\" non_string_value: number | property \"\"\" # Note: Return as is. return value not_implemented_string ( self , value ) \u00b6 not_implemented_string: value Exceptions: Type Description NotImplementedError For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def not_implemented_string ( self , value ): \"\"\"not_implemented_string: value Raises: NotImplementedError: For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 \"\"\" raise NotImplementedError ( \"Comparing strings is not yet implemented.\" ) number ( self , number ) \u00b6 number: SIGNED_INT | SIGNED_FLOAT Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def number ( self , number ): \"\"\" number: SIGNED_INT | SIGNED_FLOAT \"\"\" if number . type == \"SIGNED_INT\" : type_ = int elif number . type == \"SIGNED_FLOAT\" : type_ = float return type_ ( number ) postprocess ( self , query ) \u00b6 Post-process the query according to the rules defined for the backend. Source code in optimade/filtertransformers/base_transformer.py def postprocess ( self , query ): \"\"\"Post-process the query according to the rules defined for the backend. \"\"\" return query property ( self , arg ) \u00b6 property: IDENTIFIER ( \".\" IDENTIFIER )* Source code in optimade/filtertransformers/base_transformer.py def property ( self , arg ): \"\"\" property: IDENTIFIER ( \".\" IDENTIFIER )* \"\"\" return \".\" . join ( arg ) property_first_comparison ( self , arg ) \u00b6 property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | set_zip_op_rhs | length_op_rhs ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def property_first_comparison ( self , arg ): \"\"\"property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | set_zip_op_rhs | length_op_rhs ) \"\"\" property_zip_addon ( self , arg ) \u00b6 property_zip_addon: \":\" property (\":\" property)* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def property_zip_addon ( self , arg ): \"\"\" property_zip_addon: \":\" property (\":\" property)* \"\"\" set_op_rhs ( self , arg ) \u00b6 set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def set_op_rhs ( self , arg ): \"\"\" set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) \"\"\" set_zip_op_rhs ( self , arg ) \u00b6 set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def set_zip_op_rhs ( self , arg ): \"\"\"set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) \"\"\" signed_int ( self , number ) \u00b6 signed_int : SIGNED_INT Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def signed_int ( self , number ): \"\"\" signed_int : SIGNED_INT \"\"\" return int ( number ) string ( self , string ) \u00b6 string: ESCAPED_STRING Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def string ( self , string ): \"\"\" string: ESCAPED_STRING \"\"\" return string . strip ( '\"' ) transform ( self , tree ) \u00b6 Transform the query using the Lark transformer then post-process. Source code in optimade/filtertransformers/base_transformer.py def transform ( self , tree ): \"\"\" Transform the query using the Lark transformer then post-process. \"\"\" return self . postprocess ( super () . transform ( tree )) value ( self , value ) \u00b6 value: string | number | property Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def value ( self , value ): \"\"\" value: string | number | property \"\"\" # Note: Return as is. return value value_list ( self , arg ) \u00b6 value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def value_list ( self , arg ): \"\"\" value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* \"\"\" value_op_rhs ( self , operator , value ) \u00b6 value_op_rhs: OPERATOR value Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) @abc . abstractmethod def value_op_rhs ( self , operator , value ): \"\"\" value_op_rhs: OPERATOR value \"\"\" value_zip ( self , arg ) \u00b6 value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def value_zip ( self , arg ): \"\"\" value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* \"\"\" value_zip_list ( self , arg ) \u00b6 value_zip_list: value_zip ( \",\" value_zip )* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def value_zip_list ( self , arg ): \"\"\" value_zip_list: value_zip ( \",\" value_zip )* \"\"\"","title":"base_transformer"},{"location":"api_reference/filtertransformers/base_transformer/#base_transformer","text":"","title":"base_transformer"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer","text":"Generic filter transformer that handles various parts of the grammar in a backend non-specific way.","title":"BaseTransformer"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.__init__","text":"Initialise the transformer object, optionally loading in a resource mapper for use when post-processing. Source code in optimade/filtertransformers/base_transformer.py def __init__ ( self , mapper : BaseResourceMapper = None ): \"\"\"Initialise the transformer object, optionally loading in a resource mapper for use when post-processing. \"\"\" self . mapper = mapper","title":"__init__()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.comparison","text":"comparison: constant_first_comparison | property_first_comparison Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def comparison ( self , value ): \"\"\" comparison: constant_first_comparison | property_first_comparison \"\"\" # Note: Return as is. return value","title":"comparison()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.constant","text":"constant: string | number Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def constant ( self , value ): \"\"\" constant: string | number \"\"\" # Note: Return as is. return value","title":"constant()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.constant_first_comparison","text":"constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def constant_first_comparison ( self , arg ): \"\"\" constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) \"\"\"","title":"constant_first_comparison()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.expression","text":"expression: expression_clause ( OR expression_clause ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def expression ( self , arg ): \"\"\" expression: expression_clause ( OR expression_clause ) \"\"\"","title":"expression()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.expression_clause","text":"expression_clause: expression_phrase ( AND expression_phrase )* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def expression_clause ( self , arg ): \"\"\" expression_clause: expression_phrase ( AND expression_phrase )* \"\"\"","title":"expression_clause()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.expression_phrase","text":"expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def expression_phrase ( self , arg ): \"\"\" expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) \"\"\"","title":"expression_phrase()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.filter","text":"filter: expression* Source code in optimade/filtertransformers/base_transformer.py def filter ( self , arg ): \"\"\" filter: expression* \"\"\" return arg [ 0 ] if arg else None","title":"filter()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.fuzzy_string_op_rhs","text":"fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def fuzzy_string_op_rhs ( self , arg ): \"\"\" fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value \"\"\"","title":"fuzzy_string_op_rhs()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.known_op_rhs","text":"known_op_rhs: IS ( KNOWN | UNKNOWN ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def known_op_rhs ( self , arg ): \"\"\" known_op_rhs: IS ( KNOWN | UNKNOWN ) \"\"\"","title":"known_op_rhs()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.length_op_rhs","text":"length_op_rhs: LENGTH [ OPERATOR ] value Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def length_op_rhs ( self , arg ): \"\"\" length_op_rhs: LENGTH [ OPERATOR ] value \"\"\"","title":"length_op_rhs()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.non_string_value","text":"non_string_value: number | property Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def non_string_value ( self , value ): \"\"\" non_string_value: number | property \"\"\" # Note: Return as is. return value","title":"non_string_value()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.not_implemented_string","text":"not_implemented_string: value Exceptions: Type Description NotImplementedError For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def not_implemented_string ( self , value ): \"\"\"not_implemented_string: value Raises: NotImplementedError: For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 \"\"\" raise NotImplementedError ( \"Comparing strings is not yet implemented.\" )","title":"not_implemented_string()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.number","text":"number: SIGNED_INT | SIGNED_FLOAT Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def number ( self , number ): \"\"\" number: SIGNED_INT | SIGNED_FLOAT \"\"\" if number . type == \"SIGNED_INT\" : type_ = int elif number . type == \"SIGNED_FLOAT\" : type_ = float return type_ ( number )","title":"number()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.postprocess","text":"Post-process the query according to the rules defined for the backend. Source code in optimade/filtertransformers/base_transformer.py def postprocess ( self , query ): \"\"\"Post-process the query according to the rules defined for the backend. \"\"\" return query","title":"postprocess()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.property","text":"property: IDENTIFIER ( \".\" IDENTIFIER )* Source code in optimade/filtertransformers/base_transformer.py def property ( self , arg ): \"\"\" property: IDENTIFIER ( \".\" IDENTIFIER )* \"\"\" return \".\" . join ( arg )","title":"property()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.property_first_comparison","text":"property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | set_zip_op_rhs | length_op_rhs ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def property_first_comparison ( self , arg ): \"\"\"property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | set_zip_op_rhs | length_op_rhs ) \"\"\"","title":"property_first_comparison()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.property_zip_addon","text":"property_zip_addon: \":\" property (\":\" property)* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def property_zip_addon ( self , arg ): \"\"\" property_zip_addon: \":\" property (\":\" property)* \"\"\"","title":"property_zip_addon()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.set_op_rhs","text":"set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def set_op_rhs ( self , arg ): \"\"\" set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) \"\"\"","title":"set_op_rhs()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.set_zip_op_rhs","text":"set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def set_zip_op_rhs ( self , arg ): \"\"\"set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) \"\"\"","title":"set_zip_op_rhs()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.signed_int","text":"signed_int : SIGNED_INT Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def signed_int ( self , number ): \"\"\" signed_int : SIGNED_INT \"\"\" return int ( number )","title":"signed_int()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.string","text":"string: ESCAPED_STRING Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def string ( self , string ): \"\"\" string: ESCAPED_STRING \"\"\" return string . strip ( '\"' )","title":"string()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.transform","text":"Transform the query using the Lark transformer then post-process. Source code in optimade/filtertransformers/base_transformer.py def transform ( self , tree ): \"\"\" Transform the query using the Lark transformer then post-process. \"\"\" return self . postprocess ( super () . transform ( tree ))","title":"transform()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.value","text":"value: string | number | property Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) def value ( self , value ): \"\"\" value: string | number | property \"\"\" # Note: Return as is. return value","title":"value()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.value_list","text":"value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def value_list ( self , arg ): \"\"\" value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* \"\"\"","title":"value_list()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.value_op_rhs","text":"value_op_rhs: OPERATOR value Source code in optimade/filtertransformers/base_transformer.py @v_args ( inline = True ) @abc . abstractmethod def value_op_rhs ( self , operator , value ): \"\"\" value_op_rhs: OPERATOR value \"\"\"","title":"value_op_rhs()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.value_zip","text":"value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def value_zip ( self , arg ): \"\"\" value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* \"\"\"","title":"value_zip()"},{"location":"api_reference/filtertransformers/base_transformer/#optimade.filtertransformers.base_transformer.BaseTransformer.value_zip_list","text":"value_zip_list: value_zip ( \",\" value_zip )* Source code in optimade/filtertransformers/base_transformer.py @abc . abstractmethod def value_zip_list ( self , arg ): \"\"\" value_zip_list: value_zip ( \",\" value_zip )* \"\"\"","title":"value_zip_list()"},{"location":"api_reference/filtertransformers/django/","text":"django \u00b6 DjangoTransformer \u00b6 Filter transformer for implementations using Django. Warning This transformer is deprecated as it only supports the 0.9.7 grammar version, and works different to other filter transformers in this package.","title":"django"},{"location":"api_reference/filtertransformers/django/#django","text":"","title":"django"},{"location":"api_reference/filtertransformers/django/#optimade.filtertransformers.django.DjangoTransformer","text":"Filter transformer for implementations using Django. Warning This transformer is deprecated as it only supports the 0.9.7 grammar version, and works different to other filter transformers in this package.","title":"DjangoTransformer"},{"location":"api_reference/filtertransformers/elasticsearch/","text":"elasticsearch \u00b6 ElasticTransformer ( BaseTransformer ) \u00b6 Transformer that transforms v0.10.1 grammar parse trees into queries. Uses elasticsearch_dsl and will produce a Q instance. __default__ ( self , tree , children , * args , ** kwargs ) special \u00b6 Default behavior for rules that only replace one symbol with another Source code in optimade/filtertransformers/elasticsearch.py def __default__ ( self , tree , children , * args , ** kwargs ): \"\"\" Default behavior for rules that only replace one symbol with another \"\"\" return children [ 0 ] __init__ ( self , quantities ) special \u00b6 Parameters: Name Type Description Default quantities List[optimade.filtertransformers.elasticsearch.Quantity] A list of :class: Quantity s that describe how optimade (and other) quantities are mapped to the elasticsearch index. required Source code in optimade/filtertransformers/elasticsearch.py def __init__ ( self , quantities : List [ Quantity ]): \"\"\" Arguments: quantities: A list of :class:`Quantity`s that describe how optimade (and other) quantities are mapped to the elasticsearch index. \"\"\" self . index_mapping = { quantity . name : quantity for quantity in quantities } super () . __init__ () expression ( self , args ) \u00b6 expression: expression_clause ( OR expression_clause ) Source code in optimade/filtertransformers/elasticsearch.py def expression ( self , args ): # expression: expression_clause ( _OR expression_clause )* result = args [ 0 ] for arg in args [ 1 :]: result |= arg return result expression_clause ( self , args ) \u00b6 expression_clause: expression_phrase ( AND expression_phrase )* Source code in optimade/filtertransformers/elasticsearch.py def expression_clause ( self , args ): # expression_clause: expression_phrase ( _AND expression_phrase )* result = args [ 0 ] for arg in args [ 1 :]: result &= arg return result expression_phrase ( self , args ) \u00b6 expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) Source code in optimade/filtertransformers/elasticsearch.py def expression_phrase ( self , args ): # expression_phrase: [ NOT ] ( operator | \"(\" expression \")\" ) if args [ 0 ] == \"NOT\" : return ~ args [ 1 ] return args [ 0 ] filter ( self , args ) \u00b6 filter: expression* Source code in optimade/filtertransformers/elasticsearch.py def filter ( self , args ): # filter: expression* if len ( args ) == 1 : return args [ 0 ] return Q ( \"bool\" , ** { \"must\" : args }) fuzzy_string_op_rhs ( self , args ) \u00b6 fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value Source code in optimade/filtertransformers/elasticsearch.py def fuzzy_string_op_rhs ( self , args ): op = args [ 0 ] value = args [ - 1 ] if op == \"CONTAINS\" : wildcard = \"* %s *\" % value if op == \"STARTS\" : wildcard = \" %s *\" % value if op == \"ENDS\" : wildcard = \"* %s \" % value return lambda quantity : Q ( \"wildcard\" , ** { self . _field ( quantity ): wildcard }) length_op_rhs ( self , args ) \u00b6 length_op_rhs: LENGTH [ OPERATOR ] value Source code in optimade/filtertransformers/elasticsearch.py def length_op_rhs ( self , args ): # length_op_rhs: LENGTH [ OPERATOR ] signed_int value = args [ - 1 ] if len ( args ) == 3 : op = args [ 1 ] else : op = \"=\" def query ( quantity ): if quantity . length_quantity is None : raise Exception ( \"LENGTH is not supported for %s \" % quantity . name ) quantity = quantity . length_quantity return self . _query_op ( quantity , op , value ) return query property ( self , args ) \u00b6 property: IDENTIFIER ( \".\" IDENTIFIER )* Source code in optimade/filtertransformers/elasticsearch.py def property ( self , args ): # property: IDENTIFIER ( \".\" IDENTIFIER )* quantity_name = args [ 0 ] if quantity_name not in self . index_mapping : raise Exception ( \" %s is not a searchable quantity\" % quantity_name ) quantity = self . index_mapping . get ( quantity_name , None ) if quantity is None : quantity = Quantity ( name = quantity_name ) return quantity property_zip_addon ( self , args ) \u00b6 property_zip_addon: \":\" property (\":\" property)* Source code in optimade/filtertransformers/elasticsearch.py def property_zip_addon ( self , args ): return args set_op_rhs ( self , args ) \u00b6 set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) Source code in optimade/filtertransformers/elasticsearch.py def set_op_rhs ( self , args ): # set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ... ) values = args [ - 1 ] if not isinstance ( values , list ): if len ( args ) == 3 : op = args [ 1 ] else : op = \"=\" values = [( op , values )] if len ( args ) == 3 : op = \"HAS \" + args [ 1 ] else : op = \"HAS\" return lambda quantity : self . _has_query_op ( [ quantity ], op , [[ value ] for value in values ] ) set_zip_op_rhs ( self , args ) \u00b6 set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) Source code in optimade/filtertransformers/elasticsearch.py def set_zip_op_rhs ( self , args ): # set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) add_on = args [ 0 ] values = args [ - 1 ] if len ( args ) == 4 : op = \"HAS \" + args [ 2 ] else : op = \"HAS\" values = [ values ] return lambda quantity : self . _has_query_op ([ quantity ] + add_on , op , values ) value_list ( self , args ) \u00b6 value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* Source code in optimade/filtertransformers/elasticsearch.py def value_list ( self , args ): result = [] op = \"=\" for arg in args : if arg in [ \"<\" , \"<=\" , \">\" , \">=\" , \"!=\" , \"=\" ]: op = arg else : result . append ( ( op , arg , ) ) op = \"=\" return result value_zip ( self , args ) \u00b6 value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* Source code in optimade/filtertransformers/elasticsearch.py def value_zip ( self , args ): return self . value_list ( args ) value_zip_list ( self , args ) \u00b6 value_zip_list: value_zip ( \",\" value_zip )* Source code in optimade/filtertransformers/elasticsearch.py def value_zip_list ( self , args ): return args Quantity \u00b6 Class to provide information about available quantities to the transformer. The elasticsearch transformer will use Quantity s to (a) do some semantic checks, (b) map quantities to the underlying elastic index. Attributes: Name Type Description name The name of the quantity as used in the filter expressions. es_field The name of the field for this quanity in elastic search, will be name by default. elastic_mapping_type A decendent of an elasticsearch_dsl Field that denotes which mapping was used in the elastic search index. length_quantity Elasticsearch does not support length of arrays, but we can map fields with array to other fields with ints about the array length. The LENGTH operator will only be supported for quantities with this attribute. has_only_quantity Elasticsearch does not support exclusive search on arrays, like a list of chemical elements. But, we can order all elements by atomic number and use a keyword field with all elements to perform this search. This only works for elements (i.e. labels in CHEMICAL_SYMBOLS ) and quantities with this attribute. nested_quantity To support optimade's 'zipped tuple' feature (e.g. 'elements:elements_ratios HAS \"H\":>0.33), we use elasticsearch nested objects and nested queries. This quantity will provide the field for the nested object that contains the quantity (and others). The zipped tuples will only work for quantities that share the same nested object quantity.","title":"elasticsearch"},{"location":"api_reference/filtertransformers/elasticsearch/#elasticsearch","text":"","title":"elasticsearch"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer","text":"Transformer that transforms v0.10.1 grammar parse trees into queries. Uses elasticsearch_dsl and will produce a Q instance.","title":"ElasticTransformer"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.__default__","text":"Default behavior for rules that only replace one symbol with another Source code in optimade/filtertransformers/elasticsearch.py def __default__ ( self , tree , children , * args , ** kwargs ): \"\"\" Default behavior for rules that only replace one symbol with another \"\"\" return children [ 0 ]","title":"__default__()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.__init__","text":"Parameters: Name Type Description Default quantities List[optimade.filtertransformers.elasticsearch.Quantity] A list of :class: Quantity s that describe how optimade (and other) quantities are mapped to the elasticsearch index. required Source code in optimade/filtertransformers/elasticsearch.py def __init__ ( self , quantities : List [ Quantity ]): \"\"\" Arguments: quantities: A list of :class:`Quantity`s that describe how optimade (and other) quantities are mapped to the elasticsearch index. \"\"\" self . index_mapping = { quantity . name : quantity for quantity in quantities } super () . __init__ ()","title":"__init__()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.expression","text":"expression: expression_clause ( OR expression_clause ) Source code in optimade/filtertransformers/elasticsearch.py def expression ( self , args ): # expression: expression_clause ( _OR expression_clause )* result = args [ 0 ] for arg in args [ 1 :]: result |= arg return result","title":"expression()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.expression_clause","text":"expression_clause: expression_phrase ( AND expression_phrase )* Source code in optimade/filtertransformers/elasticsearch.py def expression_clause ( self , args ): # expression_clause: expression_phrase ( _AND expression_phrase )* result = args [ 0 ] for arg in args [ 1 :]: result &= arg return result","title":"expression_clause()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.expression_phrase","text":"expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) Source code in optimade/filtertransformers/elasticsearch.py def expression_phrase ( self , args ): # expression_phrase: [ NOT ] ( operator | \"(\" expression \")\" ) if args [ 0 ] == \"NOT\" : return ~ args [ 1 ] return args [ 0 ]","title":"expression_phrase()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.filter","text":"filter: expression* Source code in optimade/filtertransformers/elasticsearch.py def filter ( self , args ): # filter: expression* if len ( args ) == 1 : return args [ 0 ] return Q ( \"bool\" , ** { \"must\" : args })","title":"filter()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.fuzzy_string_op_rhs","text":"fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value Source code in optimade/filtertransformers/elasticsearch.py def fuzzy_string_op_rhs ( self , args ): op = args [ 0 ] value = args [ - 1 ] if op == \"CONTAINS\" : wildcard = \"* %s *\" % value if op == \"STARTS\" : wildcard = \" %s *\" % value if op == \"ENDS\" : wildcard = \"* %s \" % value return lambda quantity : Q ( \"wildcard\" , ** { self . _field ( quantity ): wildcard })","title":"fuzzy_string_op_rhs()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.length_op_rhs","text":"length_op_rhs: LENGTH [ OPERATOR ] value Source code in optimade/filtertransformers/elasticsearch.py def length_op_rhs ( self , args ): # length_op_rhs: LENGTH [ OPERATOR ] signed_int value = args [ - 1 ] if len ( args ) == 3 : op = args [ 1 ] else : op = \"=\" def query ( quantity ): if quantity . length_quantity is None : raise Exception ( \"LENGTH is not supported for %s \" % quantity . name ) quantity = quantity . length_quantity return self . _query_op ( quantity , op , value ) return query","title":"length_op_rhs()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.property","text":"property: IDENTIFIER ( \".\" IDENTIFIER )* Source code in optimade/filtertransformers/elasticsearch.py def property ( self , args ): # property: IDENTIFIER ( \".\" IDENTIFIER )* quantity_name = args [ 0 ] if quantity_name not in self . index_mapping : raise Exception ( \" %s is not a searchable quantity\" % quantity_name ) quantity = self . index_mapping . get ( quantity_name , None ) if quantity is None : quantity = Quantity ( name = quantity_name ) return quantity","title":"property()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.property_zip_addon","text":"property_zip_addon: \":\" property (\":\" property)* Source code in optimade/filtertransformers/elasticsearch.py def property_zip_addon ( self , args ): return args","title":"property_zip_addon()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.set_op_rhs","text":"set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) Source code in optimade/filtertransformers/elasticsearch.py def set_op_rhs ( self , args ): # set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ... ) values = args [ - 1 ] if not isinstance ( values , list ): if len ( args ) == 3 : op = args [ 1 ] else : op = \"=\" values = [( op , values )] if len ( args ) == 3 : op = \"HAS \" + args [ 1 ] else : op = \"HAS\" return lambda quantity : self . _has_query_op ( [ quantity ], op , [[ value ] for value in values ] )","title":"set_op_rhs()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.set_zip_op_rhs","text":"set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) Source code in optimade/filtertransformers/elasticsearch.py def set_zip_op_rhs ( self , args ): # set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) add_on = args [ 0 ] values = args [ - 1 ] if len ( args ) == 4 : op = \"HAS \" + args [ 2 ] else : op = \"HAS\" values = [ values ] return lambda quantity : self . _has_query_op ([ quantity ] + add_on , op , values )","title":"set_zip_op_rhs()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.value_list","text":"value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* Source code in optimade/filtertransformers/elasticsearch.py def value_list ( self , args ): result = [] op = \"=\" for arg in args : if arg in [ \"<\" , \"<=\" , \">\" , \">=\" , \"!=\" , \"=\" ]: op = arg else : result . append ( ( op , arg , ) ) op = \"=\" return result","title":"value_list()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.value_zip","text":"value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* Source code in optimade/filtertransformers/elasticsearch.py def value_zip ( self , args ): return self . value_list ( args )","title":"value_zip()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.ElasticTransformer.value_zip_list","text":"value_zip_list: value_zip ( \",\" value_zip )* Source code in optimade/filtertransformers/elasticsearch.py def value_zip_list ( self , args ): return args","title":"value_zip_list()"},{"location":"api_reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.Quantity","text":"Class to provide information about available quantities to the transformer. The elasticsearch transformer will use Quantity s to (a) do some semantic checks, (b) map quantities to the underlying elastic index. Attributes: Name Type Description name The name of the quantity as used in the filter expressions. es_field The name of the field for this quanity in elastic search, will be name by default. elastic_mapping_type A decendent of an elasticsearch_dsl Field that denotes which mapping was used in the elastic search index. length_quantity Elasticsearch does not support length of arrays, but we can map fields with array to other fields with ints about the array length. The LENGTH operator will only be supported for quantities with this attribute. has_only_quantity Elasticsearch does not support exclusive search on arrays, like a list of chemical elements. But, we can order all elements by atomic number and use a keyword field with all elements to perform this search. This only works for elements (i.e. labels in CHEMICAL_SYMBOLS ) and quantities with this attribute. nested_quantity To support optimade's 'zipped tuple' feature (e.g. 'elements:elements_ratios HAS \"H\":>0.33), we use elasticsearch nested objects and nested queries. This quantity will provide the field for the nested object that contains the quantity (and others). The zipped tuples will only work for quantities that share the same nested object quantity.","title":"Quantity"},{"location":"api_reference/filtertransformers/mongo/","text":"mongo \u00b6 MongoTransformer ( BaseTransformer ) \u00b6 Transformer for MongoDB backend. Parses lark tree into a dictionary to be passed to pymongo/mongomock. Uses post-processing functions to handle aliasing and some specific edge-cases for MongoDB. constant_first_comparison ( self , arg ) \u00b6 constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) Source code in optimade/filtertransformers/mongo.py def constant_first_comparison ( self , arg ): # constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) return { arg [ 2 ]: { self . reversed_operator_map [ self . operator_map [ arg [ 1 ]]]: arg [ 0 ]}} expression ( self , arg ) \u00b6 expression: expression_clause ( OR expression_clause ) Source code in optimade/filtertransformers/mongo.py def expression ( self , arg ): # expression: expression_clause ( OR expression_clause ) # expression with and without 'OR' return { \"$or\" : arg } if len ( arg ) > 1 else arg [ 0 ] expression_clause ( self , arg ) \u00b6 expression_clause: expression_phrase ( AND expression_phrase )* Source code in optimade/filtertransformers/mongo.py def expression_clause ( self , arg ): # expression_clause: expression_phrase ( AND expression_phrase )* # expression_clause with and without 'AND' return { \"$and\" : arg } if len ( arg ) > 1 else arg [ 0 ] expression_phrase ( self , arg ) \u00b6 expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) Source code in optimade/filtertransformers/mongo.py def expression_phrase ( self , arg ): # expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) return self . _recursive_expression_phrase ( arg ) fuzzy_string_op_rhs ( self , arg ) \u00b6 fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value Source code in optimade/filtertransformers/mongo.py def fuzzy_string_op_rhs ( self , arg ): # fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value # The WITH keyword may be omitted. if isinstance ( arg [ 1 ], Token ) and arg [ 1 ] . type == \"WITH\" : pattern = arg [ 2 ] else : pattern = arg [ 1 ] # CONTAINS if arg [ 0 ] == \"CONTAINS\" : regex = f \" { pattern } \" elif arg [ 0 ] == \"STARTS\" : regex = f \"^ { pattern } \" elif arg [ 0 ] == \"ENDS\" : regex = f \" { pattern } $\" return { \"$regex\" : regex } known_op_rhs ( self , arg ) \u00b6 known_op_rhs: IS ( KNOWN | UNKNOWN ) Source code in optimade/filtertransformers/mongo.py def known_op_rhs ( self , arg ): # known_op_rhs: IS ( KNOWN | UNKNOWN ) # The OPTIMADE spec also required a type comparison with null, this must be post-processed # so here we use a special key \"#known\" which will get replaced in post-processing with the # expanded dict return { \"#known\" : arg [ 1 ] == \"KNOWN\" } length_op_rhs ( self , arg ) \u00b6 length_op_rhs: LENGTH [ OPERATOR ] value Source code in optimade/filtertransformers/mongo.py def length_op_rhs ( self , arg ): # length_op_rhs: LENGTH [ OPERATOR ] value if len ( arg ) == 2 or ( len ( arg ) == 3 and arg [ 1 ] == \"=\" ): return { \"$size\" : arg [ - 1 ]} elif arg [ 1 ] in self . operator_map and arg [ 1 ] != \"!=\" : # create an invalid query that needs to be post-processed # e.g. {'$size': {'$gt': 2}}, which is not allowed by Mongo. return { \"$size\" : { self . operator_map [ arg [ 1 ]]: arg [ - 1 ]}} raise NotImplementedError ( f \"Operator { arg [ 1 ] } not implemented for LENGTH filter.\" ) postprocess ( self , query ) \u00b6 Used to post-process the final parsed query. Source code in optimade/filtertransformers/mongo.py def postprocess ( self , query ): \"\"\" Used to post-process the final parsed query. \"\"\" if self . mapper : # important to apply length alias before normal aliases query = self . _apply_length_aliases ( query ) query = self . _apply_aliases ( query ) query = self . _apply_relationship_filtering ( query ) query = self . _apply_length_operators ( query ) query = self . _apply_unknown_or_null_filter ( query ) query = self . _apply_mongo_id_filter ( query ) query = self . _apply_mongo_date_filter ( query ) return query property_first_comparison ( self , arg ) \u00b6 property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | set_zip_op_rhs | length_op_rhs ) Source code in optimade/filtertransformers/mongo.py def property_first_comparison ( self , arg ): # property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | # set_zip_op_rhs | length_op_rhs ) return { arg [ 0 ]: arg [ 1 ]} property_zip_addon ( self , arg ) \u00b6 property_zip_addon: \":\" property (\":\" property)* Source code in optimade/filtertransformers/mongo.py def property_zip_addon ( self , arg ): # property_zip_addon: \":\" property (\":\" property)* raise NotImplementedError set_op_rhs ( self , arg ) \u00b6 set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) Source code in optimade/filtertransformers/mongo.py def set_op_rhs ( self , arg ): # set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) if len ( arg ) == 2 : # only value without OPERATOR return { \"$in\" : arg [ 1 :]} if arg [ 1 ] == \"ALL\" : return { \"$all\" : arg [ 2 ]} if arg [ 1 ] == \"ANY\" : return { \"$in\" : arg [ 2 ]} if arg [ 1 ] == \"ONLY\" : return { \"$all\" : arg [ 2 ], \"$size\" : len ( arg [ 2 ])} # value with OPERATOR raise NotImplementedError ( f \"set_op_rhs not implemented for use with OPERATOR. Given: { arg } \" ) set_zip_op_rhs ( self , arg ) \u00b6 set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) Source code in optimade/filtertransformers/mongo.py def set_zip_op_rhs ( self , arg ): # set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | # ANY value_zip_list ) raise NotImplementedError value_list ( self , arg ) \u00b6 value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* Source code in optimade/filtertransformers/mongo.py def value_list ( self , arg ): # value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* # NOTE: no support for optional OPERATOR, yet, so this takes the # parsed values and returns an error if that is being attempted for value in arg : if str ( value ) in self . operator_map . keys (): raise NotImplementedError ( f \"OPERATOR { value } inside value_list { arg } not implemented.\" ) return arg value_zip ( self , arg ) \u00b6 value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* Source code in optimade/filtertransformers/mongo.py def value_zip ( self , arg ): # value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* raise NotImplementedError value_zip_list ( self , arg ) \u00b6 value_zip_list: value_zip ( \",\" value_zip )* Source code in optimade/filtertransformers/mongo.py def value_zip_list ( self , arg ): # value_zip_list: value_zip ( \",\" value_zip )* raise NotImplementedError recursive_postprocessing ( filter_ , condition , replacement ) \u00b6 Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: Name Type Description Default filter_ list/dict the filter_ to process. required condition callable a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over filter_.items() . required replacement callable a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). required Examples: For the simple case of replacing one field name with another, the following functions could be used: def condition ( prop , expr ): return prop == \"field_name_old\" def replacement ( d , prop , expr ): d [ \"field_name_old\" ] = d . pop ( prop ) filter_ = recursive_postprocessing ( filter_ , condition , replacement ) Source code in optimade/filtertransformers/mongo.py def recursive_postprocessing ( filter_ , condition , replacement ): \"\"\"Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: filter_ (list/dict): the filter_ to process. condition (callable): a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over `filter_.items()`. replacement (callable): a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). Example: For the simple case of replacing one field name with another, the following functions could be used: ```python def condition(prop, expr): return prop == \"field_name_old\" def replacement(d, prop, expr): d[\"field_name_old\"] = d.pop(prop) filter_ = recursive_postprocessing( filter_, condition, replacement ) ``` \"\"\" if isinstance ( filter_ , list ): result = [ recursive_postprocessing ( q , condition , replacement ) for q in filter_ ] return result if isinstance ( filter_ , dict ): # this could potentially lead to memory leaks if the filter_ is *heavily* nested _cached_filter = copy . deepcopy ( filter_ ) for prop , expr in filter_ . items (): if condition ( prop , expr ): _cached_filter = replacement ( _cached_filter , prop , expr ) elif isinstance ( expr , list ): _cached_filter [ prop ] = [ recursive_postprocessing ( q , condition , replacement ) for q in expr ] return _cached_filter return filter_","title":"mongo"},{"location":"api_reference/filtertransformers/mongo/#mongo","text":"","title":"mongo"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer","text":"Transformer for MongoDB backend. Parses lark tree into a dictionary to be passed to pymongo/mongomock. Uses post-processing functions to handle aliasing and some specific edge-cases for MongoDB.","title":"MongoTransformer"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.constant_first_comparison","text":"constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) Source code in optimade/filtertransformers/mongo.py def constant_first_comparison ( self , arg ): # constant_first_comparison: constant OPERATOR ( non_string_value | not_implemented_string ) return { arg [ 2 ]: { self . reversed_operator_map [ self . operator_map [ arg [ 1 ]]]: arg [ 0 ]}}","title":"constant_first_comparison()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.expression","text":"expression: expression_clause ( OR expression_clause ) Source code in optimade/filtertransformers/mongo.py def expression ( self , arg ): # expression: expression_clause ( OR expression_clause ) # expression with and without 'OR' return { \"$or\" : arg } if len ( arg ) > 1 else arg [ 0 ]","title":"expression()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.expression_clause","text":"expression_clause: expression_phrase ( AND expression_phrase )* Source code in optimade/filtertransformers/mongo.py def expression_clause ( self , arg ): # expression_clause: expression_phrase ( AND expression_phrase )* # expression_clause with and without 'AND' return { \"$and\" : arg } if len ( arg ) > 1 else arg [ 0 ]","title":"expression_clause()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.expression_phrase","text":"expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) Source code in optimade/filtertransformers/mongo.py def expression_phrase ( self , arg ): # expression_phrase: [ NOT ] ( comparison | \"(\" expression \")\" ) return self . _recursive_expression_phrase ( arg )","title":"expression_phrase()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.fuzzy_string_op_rhs","text":"fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value Source code in optimade/filtertransformers/mongo.py def fuzzy_string_op_rhs ( self , arg ): # fuzzy_string_op_rhs: CONTAINS value | STARTS [ WITH ] value | ENDS [ WITH ] value # The WITH keyword may be omitted. if isinstance ( arg [ 1 ], Token ) and arg [ 1 ] . type == \"WITH\" : pattern = arg [ 2 ] else : pattern = arg [ 1 ] # CONTAINS if arg [ 0 ] == \"CONTAINS\" : regex = f \" { pattern } \" elif arg [ 0 ] == \"STARTS\" : regex = f \"^ { pattern } \" elif arg [ 0 ] == \"ENDS\" : regex = f \" { pattern } $\" return { \"$regex\" : regex }","title":"fuzzy_string_op_rhs()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.known_op_rhs","text":"known_op_rhs: IS ( KNOWN | UNKNOWN ) Source code in optimade/filtertransformers/mongo.py def known_op_rhs ( self , arg ): # known_op_rhs: IS ( KNOWN | UNKNOWN ) # The OPTIMADE spec also required a type comparison with null, this must be post-processed # so here we use a special key \"#known\" which will get replaced in post-processing with the # expanded dict return { \"#known\" : arg [ 1 ] == \"KNOWN\" }","title":"known_op_rhs()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.length_op_rhs","text":"length_op_rhs: LENGTH [ OPERATOR ] value Source code in optimade/filtertransformers/mongo.py def length_op_rhs ( self , arg ): # length_op_rhs: LENGTH [ OPERATOR ] value if len ( arg ) == 2 or ( len ( arg ) == 3 and arg [ 1 ] == \"=\" ): return { \"$size\" : arg [ - 1 ]} elif arg [ 1 ] in self . operator_map and arg [ 1 ] != \"!=\" : # create an invalid query that needs to be post-processed # e.g. {'$size': {'$gt': 2}}, which is not allowed by Mongo. return { \"$size\" : { self . operator_map [ arg [ 1 ]]: arg [ - 1 ]}} raise NotImplementedError ( f \"Operator { arg [ 1 ] } not implemented for LENGTH filter.\" )","title":"length_op_rhs()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.postprocess","text":"Used to post-process the final parsed query. Source code in optimade/filtertransformers/mongo.py def postprocess ( self , query ): \"\"\" Used to post-process the final parsed query. \"\"\" if self . mapper : # important to apply length alias before normal aliases query = self . _apply_length_aliases ( query ) query = self . _apply_aliases ( query ) query = self . _apply_relationship_filtering ( query ) query = self . _apply_length_operators ( query ) query = self . _apply_unknown_or_null_filter ( query ) query = self . _apply_mongo_id_filter ( query ) query = self . _apply_mongo_date_filter ( query ) return query","title":"postprocess()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.property_first_comparison","text":"property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | set_zip_op_rhs | length_op_rhs ) Source code in optimade/filtertransformers/mongo.py def property_first_comparison ( self , arg ): # property_first_comparison: property ( value_op_rhs | known_op_rhs | fuzzy_string_op_rhs | set_op_rhs | # set_zip_op_rhs | length_op_rhs ) return { arg [ 0 ]: arg [ 1 ]}","title":"property_first_comparison()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.property_zip_addon","text":"property_zip_addon: \":\" property (\":\" property)* Source code in optimade/filtertransformers/mongo.py def property_zip_addon ( self , arg ): # property_zip_addon: \":\" property (\":\" property)* raise NotImplementedError","title":"property_zip_addon()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.set_op_rhs","text":"set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) Source code in optimade/filtertransformers/mongo.py def set_op_rhs ( self , arg ): # set_op_rhs: HAS ( [ OPERATOR ] value | ALL value_list | ANY value_list | ONLY value_list ) if len ( arg ) == 2 : # only value without OPERATOR return { \"$in\" : arg [ 1 :]} if arg [ 1 ] == \"ALL\" : return { \"$all\" : arg [ 2 ]} if arg [ 1 ] == \"ANY\" : return { \"$in\" : arg [ 2 ]} if arg [ 1 ] == \"ONLY\" : return { \"$all\" : arg [ 2 ], \"$size\" : len ( arg [ 2 ])} # value with OPERATOR raise NotImplementedError ( f \"set_op_rhs not implemented for use with OPERATOR. Given: { arg } \" )","title":"set_op_rhs()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.set_zip_op_rhs","text":"set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | ANY value_zip_list ) Source code in optimade/filtertransformers/mongo.py def set_zip_op_rhs ( self , arg ): # set_zip_op_rhs: property_zip_addon HAS ( value_zip | ONLY value_zip_list | ALL value_zip_list | # ANY value_zip_list ) raise NotImplementedError","title":"set_zip_op_rhs()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.value_list","text":"value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* Source code in optimade/filtertransformers/mongo.py def value_list ( self , arg ): # value_list: [ OPERATOR ] value ( \",\" [ OPERATOR ] value )* # NOTE: no support for optional OPERATOR, yet, so this takes the # parsed values and returns an error if that is being attempted for value in arg : if str ( value ) in self . operator_map . keys (): raise NotImplementedError ( f \"OPERATOR { value } inside value_list { arg } not implemented.\" ) return arg","title":"value_list()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.value_zip","text":"value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* Source code in optimade/filtertransformers/mongo.py def value_zip ( self , arg ): # value_zip: [ OPERATOR ] value \":\" [ OPERATOR ] value (\":\" [ OPERATOR ] value)* raise NotImplementedError","title":"value_zip()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.value_zip_list","text":"value_zip_list: value_zip ( \",\" value_zip )* Source code in optimade/filtertransformers/mongo.py def value_zip_list ( self , arg ): # value_zip_list: value_zip ( \",\" value_zip )* raise NotImplementedError","title":"value_zip_list()"},{"location":"api_reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.recursive_postprocessing","text":"Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: Name Type Description Default filter_ list/dict the filter_ to process. required condition callable a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over filter_.items() . required replacement callable a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). required Examples: For the simple case of replacing one field name with another, the following functions could be used: def condition ( prop , expr ): return prop == \"field_name_old\" def replacement ( d , prop , expr ): d [ \"field_name_old\" ] = d . pop ( prop ) filter_ = recursive_postprocessing ( filter_ , condition , replacement ) Source code in optimade/filtertransformers/mongo.py def recursive_postprocessing ( filter_ , condition , replacement ): \"\"\"Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: filter_ (list/dict): the filter_ to process. condition (callable): a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over `filter_.items()`. replacement (callable): a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). Example: For the simple case of replacing one field name with another, the following functions could be used: ```python def condition(prop, expr): return prop == \"field_name_old\" def replacement(d, prop, expr): d[\"field_name_old\"] = d.pop(prop) filter_ = recursive_postprocessing( filter_, condition, replacement ) ``` \"\"\" if isinstance ( filter_ , list ): result = [ recursive_postprocessing ( q , condition , replacement ) for q in filter_ ] return result if isinstance ( filter_ , dict ): # this could potentially lead to memory leaks if the filter_ is *heavily* nested _cached_filter = copy . deepcopy ( filter_ ) for prop , expr in filter_ . items (): if condition ( prop , expr ): _cached_filter = replacement ( _cached_filter , prop , expr ) elif isinstance ( expr , list ): _cached_filter [ prop ] = [ recursive_postprocessing ( q , condition , replacement ) for q in expr ] return _cached_filter return filter_","title":"recursive_postprocessing()"},{"location":"api_reference/models/baseinfo/","text":"baseinfo \u00b6 AvailableApiVersion ( BaseModel ) pydantic-model \u00b6 A JSON object containing information about an available API version url : AnyHttpUrl pydantic-field required \u00b6 A string specifying a versioned base URL that MUST adhere to the rules in section Base URL version : SemanticVersion pydantic-field required \u00b6 A string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'. Examples: 1.0.0 , 1.0.0-rc.2 . crosscheck_url_and_version ( values ) classmethod \u00b6 Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) # as with version urls, we need to split any release tags or build metadata out of these URLs url_version = tuple ( int ( val ) for val in url_version . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values url_must_be_versioned_base_url ( v ) classmethod \u00b6 The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v BaseInfoAttributes ( BaseModel ) pydantic-model \u00b6 Attributes for Base URL Info endpoint api_version : SemanticVersion pydantic-field required \u00b6 Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 . available_api_versions : List [ optimade . models . baseinfo . AvailableApiVersion ] pydantic-field required \u00b6 A list of dictionaries of available API versions at other base URLs available_endpoints : List [ str ] pydantic-field required \u00b6 List of available endpoints (i.e., the string to be appended to the versioned base URL). entry_types_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 Available entry endpoints as a function of output formats. formats : List [ str ] pydantic-field \u00b6 List of available output formats. is_index : bool pydantic-field \u00b6 If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false ). formats_and_endpoints_must_be_valid ( v , values ) classmethod \u00b6 Source code in optimade/models/baseinfo.py @validator ( \"entry_types_by_format\" , check_fields = False ) def formats_and_endpoints_must_be_valid ( cls , v , values ): for format_ , endpoints in v . items (): if format_ not in values [ \"formats\" ]: raise ValueError ( f \"' { format_ } ' must be listed in formats to be valid\" ) for endpoint in endpoints : if endpoint not in values [ \"available_endpoints\" ]: raise ValueError ( f \"' { endpoint } ' must be listed in available_endpoints to be valid\" ) return v BaseInfoResource ( Resource ) pydantic-model \u00b6","title":"baseinfo"},{"location":"api_reference/models/baseinfo/#baseinfo","text":"","title":"baseinfo"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion","text":"A JSON object containing information about an available API version","title":"AvailableApiVersion"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.url","text":"A string specifying a versioned base URL that MUST adhere to the rules in section Base URL","title":"url"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.version","text":"A string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'. Examples: 1.0.0 , 1.0.0-rc.2 .","title":"version"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.crosscheck_url_and_version","text":"Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) # as with version urls, we need to split any release tags or build metadata out of these URLs url_version = tuple ( int ( val ) for val in url_version . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \"-\" )[ 0 ] . split ( \"+\" )[ 0 ] . split ( \".\" ) ) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values","title":"crosscheck_url_and_version()"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.url_must_be_versioned_base_url","text":"The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v","title":"url_must_be_versioned_base_url()"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes","text":"Attributes for Base URL Info endpoint","title":"BaseInfoAttributes"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.api_version","text":"Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 .","title":"api_version"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.available_api_versions","text":"A list of dictionaries of available API versions at other base URLs","title":"available_api_versions"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.available_endpoints","text":"List of available endpoints (i.e., the string to be appended to the versioned base URL).","title":"available_endpoints"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.entry_types_by_format","text":"Available entry endpoints as a function of output formats.","title":"entry_types_by_format"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.formats","text":"List of available output formats.","title":"formats"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.is_index","text":"If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false ).","title":"is_index"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.formats_and_endpoints_must_be_valid","text":"Source code in optimade/models/baseinfo.py @validator ( \"entry_types_by_format\" , check_fields = False ) def formats_and_endpoints_must_be_valid ( cls , v , values ): for format_ , endpoints in v . items (): if format_ not in values [ \"formats\" ]: raise ValueError ( f \"' { format_ } ' must be listed in formats to be valid\" ) for endpoint in endpoints : if endpoint not in values [ \"available_endpoints\" ]: raise ValueError ( f \"' { endpoint } ' must be listed in available_endpoints to be valid\" ) return v","title":"formats_and_endpoints_must_be_valid()"},{"location":"api_reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoResource","text":"","title":"BaseInfoResource"},{"location":"api_reference/models/entries/","text":"entries \u00b6 EntryInfoProperty ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 A human-readable description of the entry property sortable : bool pydantic-field \u00b6 Defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true . type : DataType pydantic-field \u00b6 The type of the property's value. This MUST be any of the types defined in the Data types section. For the purpose of compatibility with future versions of this specification, a client MUST accept values that are not string values specifying any of the OPTIMADE Data types, but MUST then also disregard the type field. Note, if the value is a nested type, only the outermost type should be reported. E.g., for the entry resource structures , the species property is defined as a list of dictionaries, hence its type value would be list . unit : str pydantic-field \u00b6 The physical unit of the entry property. This MUST be a valid representation of units according to version 2.1 of The Unified Code for Units of Measure . It is RECOMMENDED that non-standard (non-SI) units are described in the description for the property. EntryInfoResource ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 Description of the entry. formats : List [ str ] pydantic-field required \u00b6 List of output formats available for this type of entry. output_fields_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 Dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary. properties : Dict [ str , optimade . models . entries . EntryInfoProperty ] pydantic-field required \u00b6 A dictionary describing queryable properties for this entry type, where each key is a property name. EntryRelationships ( Relationships ) pydantic-model \u00b6 This model wraps the JSON API Relationships to include type-specific top level keys. references : ReferenceRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the references type. structures : StructureRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the structures type. EntryResource ( Resource ) pydantic-model \u00b6 The base model for an entry resource. EntryResourceAttributes ( Attributes ) pydantic-model \u00b6 Contains key-value pairs representing the entry's properties. immutable_id : str pydantic-field \u00b6 The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. Type : string. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.) last_modified : datetime pydantic-field required \u00b6 Date and time representing when the entry was last modified. Type : timestamp. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter response_fields is present and does not include this property. Example : As part of JSON response format: \"2007-04-05T14:30:20Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format string.) ReferenceRelationship ( TypedRelationship ) pydantic-model \u00b6 StructureRelationship ( TypedRelationship ) pydantic-model \u00b6 TypedRelationship ( Relationship ) pydantic-model \u00b6 check_rel_type ( data ) classmethod \u00b6 Source code in optimade/models/entries.py @validator ( \"data\" ) def check_rel_type ( cls , data ): if not isinstance ( data , list ): # All relationships at this point are empty-to-many relationships in JSON:API: # https://jsonapi.org/format/1.0/#document-resource-object-linkage raise ValueError ( \"`data` key in a relationship must always store a list.\" ) if hasattr ( cls , \"_req_type\" ) and any ( getattr ( obj , \"type\" , None ) != cls . _req_type for obj in data ): raise ValueError ( \"Object stored in relationship data has wrong type\" ) return data","title":"entries"},{"location":"api_reference/models/entries/#entries","text":"","title":"entries"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoProperty","text":"","title":"EntryInfoProperty"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoProperty.description","text":"A human-readable description of the entry property","title":"description"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoProperty.sortable","text":"Defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true .","title":"sortable"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoProperty.type","text":"The type of the property's value. This MUST be any of the types defined in the Data types section. For the purpose of compatibility with future versions of this specification, a client MUST accept values that are not string values specifying any of the OPTIMADE Data types, but MUST then also disregard the type field. Note, if the value is a nested type, only the outermost type should be reported. E.g., for the entry resource structures , the species property is defined as a list of dictionaries, hence its type value would be list .","title":"type"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoProperty.unit","text":"The physical unit of the entry property. This MUST be a valid representation of units according to version 2.1 of The Unified Code for Units of Measure . It is RECOMMENDED that non-standard (non-SI) units are described in the description for the property.","title":"unit"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoResource","text":"","title":"EntryInfoResource"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoResource.description","text":"Description of the entry.","title":"description"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoResource.formats","text":"List of output formats available for this type of entry.","title":"formats"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoResource.output_fields_by_format","text":"Dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary.","title":"output_fields_by_format"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryInfoResource.properties","text":"A dictionary describing queryable properties for this entry type, where each key is a property name.","title":"properties"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryRelationships","text":"This model wraps the JSON API Relationships to include type-specific top level keys.","title":"EntryRelationships"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryRelationships.references","text":"Object containing links to relationships with entries of the references type.","title":"references"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryRelationships.structures","text":"Object containing links to relationships with entries of the structures type.","title":"structures"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryResource","text":"The base model for an entry resource.","title":"EntryResource"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryResourceAttributes","text":"Contains key-value pairs representing the entry's properties.","title":"EntryResourceAttributes"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryResourceAttributes.immutable_id","text":"The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. Type : string. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.)","title":"immutable_id"},{"location":"api_reference/models/entries/#optimade.models.entries.EntryResourceAttributes.last_modified","text":"Date and time representing when the entry was last modified. Type : timestamp. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter response_fields is present and does not include this property. Example : As part of JSON response format: \"2007-04-05T14:30:20Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format string.)","title":"last_modified"},{"location":"api_reference/models/entries/#optimade.models.entries.ReferenceRelationship","text":"","title":"ReferenceRelationship"},{"location":"api_reference/models/entries/#optimade.models.entries.StructureRelationship","text":"","title":"StructureRelationship"},{"location":"api_reference/models/entries/#optimade.models.entries.TypedRelationship","text":"","title":"TypedRelationship"},{"location":"api_reference/models/entries/#optimade.models.entries.TypedRelationship.check_rel_type","text":"Source code in optimade/models/entries.py @validator ( \"data\" ) def check_rel_type ( cls , data ): if not isinstance ( data , list ): # All relationships at this point are empty-to-many relationships in JSON:API: # https://jsonapi.org/format/1.0/#document-resource-object-linkage raise ValueError ( \"`data` key in a relationship must always store a list.\" ) if hasattr ( cls , \"_req_type\" ) and any ( getattr ( obj , \"type\" , None ) != cls . _req_type for obj in data ): raise ValueError ( \"Object stored in relationship data has wrong type\" ) return data","title":"check_rel_type()"},{"location":"api_reference/models/index_metadb/","text":"index_metadb \u00b6 DefaultRelationship ( Enum ) \u00b6 Enumeration of key(s) for relationship dictionary in IndexInfoResource DEFAULT \u00b6 IndexInfoAttributes ( BaseInfoAttributes ) pydantic-model \u00b6 Attributes for Base URL Info endpoint for an Index Meta-Database IndexInfoResource ( BaseInfoResource ) pydantic-model \u00b6 Index Meta-Database Base URL Info endpoint resource IndexRelationship ( BaseModel ) pydantic-model \u00b6 Index Meta-Database relationship data : RelatedLinksResource pydantic-field required \u00b6 JSON API resource linkage . It MUST be either null or contain a single Links identifier object with the fields id and type RelatedLinksResource ( BaseResource ) pydantic-model \u00b6 A related Links resource object","title":"index_metadb"},{"location":"api_reference/models/index_metadb/#index_metadb","text":"","title":"index_metadb"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.DefaultRelationship","text":"Enumeration of key(s) for relationship dictionary in IndexInfoResource","title":"DefaultRelationship"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.DefaultRelationship.DEFAULT","text":"","title":"DEFAULT"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.IndexInfoAttributes","text":"Attributes for Base URL Info endpoint for an Index Meta-Database","title":"IndexInfoAttributes"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.IndexInfoResource","text":"Index Meta-Database Base URL Info endpoint resource","title":"IndexInfoResource"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.IndexRelationship","text":"Index Meta-Database relationship","title":"IndexRelationship"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.IndexRelationship.data","text":"JSON API resource linkage . It MUST be either null or contain a single Links identifier object with the fields id and type","title":"data"},{"location":"api_reference/models/index_metadb/#optimade.models.index_metadb.RelatedLinksResource","text":"A related Links resource object","title":"RelatedLinksResource"},{"location":"api_reference/models/jsonapi/","text":"jsonapi \u00b6 This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/ Attributes ( BaseModel ) pydantic-model \u00b6 Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type Config \u00b6 check_illegal_attributes_fields ( values ) classmethod \u00b6 Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def check_illegal_attributes_fields ( cls , values ): illegal_fields = ( \"relationships\" , \"links\" , \"id\" , \"type\" ) for field in illegal_fields : if field in values : raise ValueError ( f \" { illegal_fields } MUST NOT be fields under Attributes\" ) return values BaseResource ( BaseModel ) pydantic-model \u00b6 Minimum requirements to represent a Resource id : str pydantic-field required \u00b6 Resource ID type : str pydantic-field required \u00b6 Resource type Config \u00b6 schema_extra ( schema , model ) staticmethod \u00b6 Ensure id and type are the first two entries in the list required properties. Note This requires that id and type are the first model fields defined for all sub-models of BaseResource . Source code in optimade/models/jsonapi.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"BaseResource\" ]) -> None : \"\"\"Ensure `id` and `type` are the first two entries in the list required properties. Note: This _requires_ that `id` and `type` are the _first_ model fields defined for all sub-models of `BaseResource`. \"\"\" if \"id\" not in schema . get ( \"required\" , []): schema [ \"required\" ] = [ \"id\" ] + schema . get ( \"required\" , []) if \"type\" not in schema . get ( \"required\" , []): required = [] for field in schema . get ( \"required\" , []): required . append ( field ) if field == \"id\" : # To make sure the property order match the listed properties, # this ensures \"type\" is added immediately after \"id\". required . append ( \"type\" ) schema [ \"required\" ] = required Error ( BaseModel ) pydantic-model \u00b6 An error response code : str pydantic-field \u00b6 an application-specific error code, expressed as a string value. detail : str pydantic-field \u00b6 A human-readable explanation specific to this occurrence of the problem. id : str pydantic-field \u00b6 A unique identifier for this particular occurrence of the problem. links : ErrorLinks pydantic-field \u00b6 A links object storing about meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the error. source : ErrorSource pydantic-field \u00b6 An object containing references to the source of the error status : str pydantic-field \u00b6 the HTTP status code applicable to this problem, expressed as a string value. title : str pydantic-field \u00b6 A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization. __hash__ ( self ) special \u00b6 Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ()) ErrorLinks ( BaseModel ) pydantic-model \u00b6 A Links object specific to Error objects about : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that leads to further details about this particular occurrence of the problem. ErrorSource ( BaseModel ) pydantic-model \u00b6 an object containing references to the source of the error parameter : str pydantic-field \u00b6 a string indicating which URI query parameter caused the error. pointer : str pydantic-field \u00b6 a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute]. JsonApi ( BaseModel ) pydantic-model \u00b6 An object describing the server's implementation meta : Meta pydantic-field \u00b6 Non-standard meta information version : str pydantic-field \u00b6 Version of the json API used Link ( BaseModel ) pydantic-model \u00b6 A link MUST be represented as either: a string containing the link's URL or a link object. href : AnyUrl pydantic-field required \u00b6 a string containing the link\u2019s URL. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the link. Meta ( BaseModel ) pydantic-model \u00b6 Non-standard meta-information that can not be represented as an attribute or relationship. Config \u00b6 Relationship ( BaseModel ) pydantic-model \u00b6 Representation references from the resource object in which it\u2019s defined to other resource objects. data : Union [ optimade . models . jsonapi . BaseResource , List [ optimade . models . jsonapi . BaseResource ]] pydantic-field \u00b6 Resource linkage links : RelationshipLinks pydantic-field \u00b6 a links object containing at least one of the following: self, related meta : Meta pydantic-field \u00b6 a meta object that contains non-standard meta-information about the relationship. at_least_one_relationship_key_must_be_set ( values ) classmethod \u00b6 Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def at_least_one_relationship_key_must_be_set ( cls , values ): for value in values . values (): if value is not None : break else : raise ValueError ( \"Either 'links', 'data', or 'meta' MUST be specified for Relationship\" ) return values RelationshipLinks ( BaseModel ) pydantic-model \u00b6 A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object. related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link . self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link for the relationship itself (a 'relationship link'). This link allows the client to directly manipulate the relationship. When fetched successfully, this link returns the linkage for the related resources as its primary data. (See Fetching Relationships .) either_self_or_related_must_be_specified ( values ) classmethod \u00b6 Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def either_self_or_related_must_be_specified ( cls , values ): for value in values . values (): if value is not None : break else : raise ValueError ( \"Either 'self' or 'related' MUST be specified for RelationshipLinks\" ) return values Relationships ( BaseModel ) pydantic-model \u00b6 Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id check_illegal_relationships_fields ( values ) classmethod \u00b6 Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def check_illegal_relationships_fields ( cls , values ): illegal_fields = ( \"id\" , \"type\" ) for field in illegal_fields : if field in values : raise ValueError ( f \" { illegal_fields } MUST NOT be fields under Relationships\" ) return values Resource ( BaseResource ) pydantic-model \u00b6 Resource objects appear in a JSON API document to represent resources. attributes : Attributes pydantic-field \u00b6 an attributes object representing some of the resource\u2019s data. links : ResourceLinks pydantic-field \u00b6 a links object containing links related to the resource. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship. relationships : Relationships pydantic-field \u00b6 Relationships object describing relationships between the resource and other JSON API resources. ResourceLinks ( BaseModel ) pydantic-model \u00b6 A Resource Links object self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that identifies the resource represented by the resource object. Response ( BaseModel ) pydantic-model \u00b6 A top-level response data : Union [ NoneType , optimade . models . jsonapi . Resource , List [ optimade . models . jsonapi . Resource ]] pydantic-field \u00b6 Outputted Data errors : List [ optimade . models . jsonapi . Error ] pydantic-field \u00b6 A list of unique errors included : List [ optimade . models . jsonapi . Resource ] pydantic-field \u00b6 A list of unique included resources jsonapi : JsonApi pydantic-field \u00b6 Information about the JSON API used links : ToplevelLinks pydantic-field \u00b6 Links associated with the primary data or errors meta : Meta pydantic-field \u00b6 A meta object containing non-standard information related to the Success Config \u00b6 The specification mandates that datetimes must be encoded following RFC3339 , which does not support fractional seconds, thus they must be stripped in the response. This can cause issues when the underlying database contains fields that do include microseconds, as filters may return unexpected results. either_data_meta_or_errors_must_be_set ( values ) classmethod \u00b6 Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): required_fields = ( \"data\" , \"meta\" , \"errors\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) return values ToplevelLinks ( BaseModel ) pydantic-model \u00b6 A set of Links objects, possibly including pagination first : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The first page of data last : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The last page of data next : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The next page of data prev : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 The previous page of data related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link to itself Config \u00b6 check_additional_keys_are_links ( values ) classmethod \u00b6 The ToplevelLinks class allows any additional keys, as long as they are also Links or Urls themselves. Source code in optimade/models/jsonapi.py @root_validator ( pre = False ) def check_additional_keys_are_links ( cls , values ): \"\"\"The `ToplevelLinks` class allows any additional keys, as long as they are also Links or Urls themselves. \"\"\" for key , value in values . items (): if key not in cls . schema ()[ \"properties\" ]: values [ key ] = parse_obj_as ( Optional [ Union [ AnyUrl , Link ]], value ) return values","title":"jsonapi"},{"location":"api_reference/models/jsonapi/#jsonapi","text":"This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/","title":"jsonapi"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Attributes","text":"Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type","title":"Attributes"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Attributes.Config","text":"","title":"Config"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Attributes.check_illegal_attributes_fields","text":"Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def check_illegal_attributes_fields ( cls , values ): illegal_fields = ( \"relationships\" , \"links\" , \"id\" , \"type\" ) for field in illegal_fields : if field in values : raise ValueError ( f \" { illegal_fields } MUST NOT be fields under Attributes\" ) return values","title":"check_illegal_attributes_fields()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.BaseResource","text":"Minimum requirements to represent a Resource","title":"BaseResource"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.BaseResource.id","text":"Resource ID","title":"id"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.BaseResource.type","text":"Resource type","title":"type"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.BaseResource.Config","text":"","title":"Config"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.BaseResource.Config.schema_extra","text":"Ensure id and type are the first two entries in the list required properties. Note This requires that id and type are the first model fields defined for all sub-models of BaseResource . Source code in optimade/models/jsonapi.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"BaseResource\" ]) -> None : \"\"\"Ensure `id` and `type` are the first two entries in the list required properties. Note: This _requires_ that `id` and `type` are the _first_ model fields defined for all sub-models of `BaseResource`. \"\"\" if \"id\" not in schema . get ( \"required\" , []): schema [ \"required\" ] = [ \"id\" ] + schema . get ( \"required\" , []) if \"type\" not in schema . get ( \"required\" , []): required = [] for field in schema . get ( \"required\" , []): required . append ( field ) if field == \"id\" : # To make sure the property order match the listed properties, # this ensures \"type\" is added immediately after \"id\". required . append ( \"type\" ) schema [ \"required\" ] = required","title":"schema_extra()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error","text":"An error response","title":"Error"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.code","text":"an application-specific error code, expressed as a string value.","title":"code"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.detail","text":"A human-readable explanation specific to this occurrence of the problem.","title":"detail"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.id","text":"A unique identifier for this particular occurrence of the problem.","title":"id"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.links","text":"A links object storing about","title":"links"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.meta","text":"a meta object containing non-standard meta-information about the error.","title":"meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.source","text":"An object containing references to the source of the error","title":"source"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.status","text":"the HTTP status code applicable to this problem, expressed as a string value.","title":"status"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.title","text":"A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.","title":"title"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Error.__hash__","text":"Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ())","title":"__hash__()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ErrorLinks","text":"A Links object specific to Error objects","title":"ErrorLinks"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ErrorLinks.about","text":"A link that leads to further details about this particular occurrence of the problem.","title":"about"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ErrorSource","text":"an object containing references to the source of the error","title":"ErrorSource"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ErrorSource.parameter","text":"a string indicating which URI query parameter caused the error.","title":"parameter"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ErrorSource.pointer","text":"a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute].","title":"pointer"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.JsonApi","text":"An object describing the server's implementation","title":"JsonApi"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.JsonApi.meta","text":"Non-standard meta information","title":"meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.JsonApi.version","text":"Version of the json API used","title":"version"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Link","text":"A link MUST be represented as either: a string containing the link's URL or a link object.","title":"Link"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Link.href","text":"a string containing the link\u2019s URL.","title":"href"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Link.meta","text":"a meta object containing non-standard meta-information about the link.","title":"meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Meta","text":"Non-standard meta-information that can not be represented as an attribute or relationship.","title":"Meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Meta.Config","text":"","title":"Config"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationship","text":"Representation references from the resource object in which it\u2019s defined to other resource objects.","title":"Relationship"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationship.data","text":"Resource linkage","title":"data"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationship.links","text":"a links object containing at least one of the following: self, related","title":"links"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationship.meta","text":"a meta object that contains non-standard meta-information about the relationship.","title":"meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationship.at_least_one_relationship_key_must_be_set","text":"Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def at_least_one_relationship_key_must_be_set ( cls , values ): for value in values . values (): if value is not None : break else : raise ValueError ( \"Either 'links', 'data', or 'meta' MUST be specified for Relationship\" ) return values","title":"at_least_one_relationship_key_must_be_set()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks","text":"A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object.","title":"RelationshipLinks"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks.related","text":"A related resource link .","title":"related"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks.self","text":"A link for the relationship itself (a 'relationship link'). This link allows the client to directly manipulate the relationship. When fetched successfully, this link returns the linkage for the related resources as its primary data. (See Fetching Relationships .)","title":"self"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks.either_self_or_related_must_be_specified","text":"Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def either_self_or_related_must_be_specified ( cls , values ): for value in values . values (): if value is not None : break else : raise ValueError ( \"Either 'self' or 'related' MUST be specified for RelationshipLinks\" ) return values","title":"either_self_or_related_must_be_specified()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationships","text":"Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id","title":"Relationships"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Relationships.check_illegal_relationships_fields","text":"Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def check_illegal_relationships_fields ( cls , values ): illegal_fields = ( \"id\" , \"type\" ) for field in illegal_fields : if field in values : raise ValueError ( f \" { illegal_fields } MUST NOT be fields under Relationships\" ) return values","title":"check_illegal_relationships_fields()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Resource","text":"Resource objects appear in a JSON API document to represent resources.","title":"Resource"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Resource.attributes","text":"an attributes object representing some of the resource\u2019s data.","title":"attributes"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Resource.links","text":"a links object containing links related to the resource.","title":"links"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Resource.meta","text":"a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship.","title":"meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Resource.relationships","text":"Relationships object describing relationships between the resource and other JSON API resources.","title":"relationships"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ResourceLinks","text":"A Resource Links object","title":"ResourceLinks"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ResourceLinks.self","text":"A link that identifies the resource represented by the resource object.","title":"self"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response","text":"A top-level response","title":"Response"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.data","text":"Outputted Data","title":"data"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.errors","text":"A list of unique errors","title":"errors"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.included","text":"A list of unique included resources","title":"included"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.jsonapi","text":"Information about the JSON API used","title":"jsonapi"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.links","text":"Links associated with the primary data or errors","title":"links"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.meta","text":"A meta object containing non-standard information related to the Success","title":"meta"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.Config","text":"The specification mandates that datetimes must be encoded following RFC3339 , which does not support fractional seconds, thus they must be stripped in the response. This can cause issues when the underlying database contains fields that do include microseconds, as filters may return unexpected results.","title":"Config"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.Response.either_data_meta_or_errors_must_be_set","text":"Source code in optimade/models/jsonapi.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): required_fields = ( \"data\" , \"meta\" , \"errors\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) return values","title":"either_data_meta_or_errors_must_be_set()"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks","text":"A set of Links objects, possibly including pagination","title":"ToplevelLinks"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.first","text":"The first page of data","title":"first"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.last","text":"The last page of data","title":"last"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.next","text":"The next page of data","title":"next"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.prev","text":"The previous page of data","title":"prev"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.related","text":"A related resource link","title":"related"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.self","text":"A link to itself","title":"self"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.Config","text":"","title":"Config"},{"location":"api_reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.check_additional_keys_are_links","text":"The ToplevelLinks class allows any additional keys, as long as they are also Links or Urls themselves. Source code in optimade/models/jsonapi.py @root_validator ( pre = False ) def check_additional_keys_are_links ( cls , values ): \"\"\"The `ToplevelLinks` class allows any additional keys, as long as they are also Links or Urls themselves. \"\"\" for key , value in values . items (): if key not in cls . schema ()[ \"properties\" ]: values [ key ] = parse_obj_as ( Optional [ Union [ AnyUrl , Link ]], value ) return values","title":"check_additional_keys_are_links()"},{"location":"api_reference/models/links/","text":"links \u00b6 Aggregate ( Enum ) \u00b6 Enumeration of aggregate values NO \u00b6 OK \u00b6 STAGING \u00b6 TEST \u00b6 LinkType ( Enum ) \u00b6 Enumeration of link_type values CHILD \u00b6 EXTERNAL \u00b6 PROVIDERS \u00b6 ROOT \u00b6 LinksResource ( EntryResource ) pydantic-model \u00b6 A Links endpoint resource object relationships_must_not_be_present ( values ) classmethod \u00b6 Source code in optimade/models/links.py @root_validator ( pre = True ) def relationships_must_not_be_present ( cls , values ): if values . get ( \"relationships\" , None ) is not None : raise ValueError ( '\"relationships\" is not allowed for links resources' ) return values LinksResourceAttributes ( Attributes ) pydantic-model \u00b6 Links endpoint resource object attributes aggregate : Aggregate pydantic-field \u00b6 A string indicating whether a client that is following links to aggregate results from different OPTIMADE implementations should follow this link or not. This flag SHOULD NOT be indicated for links where link_type is not child . If not specified, clients MAY assume that the value is ok . If specified, and the value is anything different than ok , the client MUST assume that the server is suggesting not to follow the link during aggregation by default (also if the value is not among the known ones, in case a future specification adds new accepted values). Specific values indicate the reason why the server is providing the suggestion. A client MAY follow the link anyway if it has reason to do so (e.g., if the client is looking for all test databases, it MAY follow the links marked with aggregate = test ). If specified, it MUST be one of the values listed in section Link Aggregate Options. base_url : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to the base URL for this implementation description : str pydantic-field required \u00b6 Human-readable description for the OPTIMADE API implementation, e.g., for use in clients to show a description to the end-user. homepage : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to a homepage URL for this implementation link_type : LinkType pydantic-field required \u00b6 The type of the linked relation. MUST be one of these values: 'child', 'root', 'external', 'providers'. name : str pydantic-field required \u00b6 Human-readable name for the OPTIMADE API implementation, e.g., for use in clients to show the name to the end-user. no_aggregate_reason : str pydantic-field \u00b6 An OPTIONAL human-readable string indicating the reason for suggesting not to aggregate results following the link. It SHOULD NOT be present if aggregate = ok .","title":"links"},{"location":"api_reference/models/links/#links","text":"","title":"links"},{"location":"api_reference/models/links/#optimade.models.links.Aggregate","text":"Enumeration of aggregate values","title":"Aggregate"},{"location":"api_reference/models/links/#optimade.models.links.Aggregate.NO","text":"","title":"NO"},{"location":"api_reference/models/links/#optimade.models.links.Aggregate.OK","text":"","title":"OK"},{"location":"api_reference/models/links/#optimade.models.links.Aggregate.STAGING","text":"","title":"STAGING"},{"location":"api_reference/models/links/#optimade.models.links.Aggregate.TEST","text":"","title":"TEST"},{"location":"api_reference/models/links/#optimade.models.links.LinkType","text":"Enumeration of link_type values","title":"LinkType"},{"location":"api_reference/models/links/#optimade.models.links.LinkType.CHILD","text":"","title":"CHILD"},{"location":"api_reference/models/links/#optimade.models.links.LinkType.EXTERNAL","text":"","title":"EXTERNAL"},{"location":"api_reference/models/links/#optimade.models.links.LinkType.PROVIDERS","text":"","title":"PROVIDERS"},{"location":"api_reference/models/links/#optimade.models.links.LinkType.ROOT","text":"","title":"ROOT"},{"location":"api_reference/models/links/#optimade.models.links.LinksResource","text":"A Links endpoint resource object","title":"LinksResource"},{"location":"api_reference/models/links/#optimade.models.links.LinksResource.relationships_must_not_be_present","text":"Source code in optimade/models/links.py @root_validator ( pre = True ) def relationships_must_not_be_present ( cls , values ): if values . get ( \"relationships\" , None ) is not None : raise ValueError ( '\"relationships\" is not allowed for links resources' ) return values","title":"relationships_must_not_be_present()"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes","text":"Links endpoint resource object attributes","title":"LinksResourceAttributes"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.aggregate","text":"A string indicating whether a client that is following links to aggregate results from different OPTIMADE implementations should follow this link or not. This flag SHOULD NOT be indicated for links where link_type is not child . If not specified, clients MAY assume that the value is ok . If specified, and the value is anything different than ok , the client MUST assume that the server is suggesting not to follow the link during aggregation by default (also if the value is not among the known ones, in case a future specification adds new accepted values). Specific values indicate the reason why the server is providing the suggestion. A client MAY follow the link anyway if it has reason to do so (e.g., if the client is looking for all test databases, it MAY follow the links marked with aggregate = test ). If specified, it MUST be one of the values listed in section Link Aggregate Options.","title":"aggregate"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url","text":"JSON API links object, pointing to the base URL for this implementation","title":"base_url"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.description","text":"Human-readable description for the OPTIMADE API implementation, e.g., for use in clients to show a description to the end-user.","title":"description"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.homepage","text":"JSON API links object, pointing to a homepage URL for this implementation","title":"homepage"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.link_type","text":"The type of the linked relation. MUST be one of these values: 'child', 'root', 'external', 'providers'.","title":"link_type"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.name","text":"Human-readable name for the OPTIMADE API implementation, e.g., for use in clients to show the name to the end-user.","title":"name"},{"location":"api_reference/models/links/#optimade.models.links.LinksResourceAttributes.no_aggregate_reason","text":"An OPTIONAL human-readable string indicating the reason for suggesting not to aggregate results following the link. It SHOULD NOT be present if aggregate = ok .","title":"no_aggregate_reason"},{"location":"api_reference/models/optimade_json/","text":"optimade_json \u00b6 Modified JSON API v1.0 for OPTIMADE API BaseRelationshipMeta ( Meta ) pydantic-model \u00b6 Specific meta field for base relationship resource description : str pydantic-field required \u00b6 OPTIONAL human-readable description of the relationship BaseRelationshipResource ( BaseResource ) pydantic-model \u00b6 Minimum requirements to represent a relationship resource meta : BaseRelationshipMeta pydantic-field \u00b6 Relationship meta field. MUST contain 'description' if supplied. DataType ( Enum ) \u00b6 Optimade Data Types See the section \"Data types\" in the OPTIMADE API specification for more information. BOOLEAN \u00b6 DICTIONARY \u00b6 FLOAT \u00b6 INTEGER \u00b6 LIST \u00b6 STRING \u00b6 TIMESTAMP \u00b6 UNKNOWN \u00b6 Implementation ( BaseModel ) pydantic-model \u00b6 Information on the server implementation homepage : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A JSON API links object pointing to the homepage of the implementation. maintainer : ImplementationMaintainer pydantic-field \u00b6 A dictionary providing details about the maintainer of the implementation. name : str pydantic-field \u00b6 name of the implementation source_url : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A JSON API links object pointing to the implementation source, either downloadable archive or version control system. version : str pydantic-field \u00b6 version string of the current implementation ImplementationMaintainer ( BaseModel ) pydantic-model \u00b6 Details about the maintainer of the implementation email : EmailStr pydantic-field required \u00b6 the maintainer's email address OptimadeError ( Error ) pydantic-model \u00b6 detail MUST be present __hash__ ( self ) special \u00b6 Source code in optimade/models/optimade_json.py def __hash__ ( self ): return hash ( self . json ()) Provider ( BaseModel ) pydantic-model \u00b6 Information on the database provider of the implementation. description : str pydantic-field required \u00b6 a longer description of the database provider homepage : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object. name : str pydantic-field required \u00b6 a short name for the database provider prefix : ConstrainedStrValue pydantic-field required \u00b6 database-provider-specific prefix as found in section Database-Provider-Specific Namespace Prefixes. Relationship ( Relationship ) pydantic-model \u00b6 Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource ResponseMeta ( Meta ) pydantic-model \u00b6 A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix. api_version : SemanticVersion pydantic-field required \u00b6 Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 . data_available : int pydantic-field \u00b6 An integer containing the total number of data resource objects available in the database for the endpoint. data_returned : ConstrainedIntValue pydantic-field \u00b6 An integer containing the total number of data resource objects returned for the current filter query, independent of pagination. implementation : Implementation pydantic-field \u00b6 a dictionary describing the server implementation last_id : str pydantic-field \u00b6 a string containing the last ID returned more_data_available : bool pydantic-field required \u00b6 false if the response contains all data for the request (e.g., a request issued to a single entry endpoint, or a filter query at the last page of a paginated response) and true if the response is incomplete in the sense that multiple objects match the request, and not all of them have been included in the response (e.g., a query with multiple pages that is not at the last page). optimade_schema : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A JSON API links object that points to a schema for the response. If it is a string, or a dictionary containing no meta field, the provided URL MUST point at an OpenAPI schema. It is possible that future versions of this specification allows for alternative schema types. Hence, if the meta field of the JSON API links object is provided and contains a field schema_type that is not equal to the string OpenAPI the client MUST not handle failures to parse the schema or to validate the response against the schema as errors. provider : Provider pydantic-field \u00b6 information on the database provider of the implementation. query : ResponseMetaQuery pydantic-field required \u00b6 Information on the Query that was requested response_message : str pydantic-field \u00b6 response string from the server time_stamp : datetime pydantic-field \u00b6 A timestamp containing the date and time at which the query was executed. warnings : List [ optimade . models . optimade_json . Warnings ] pydantic-field \u00b6 A list of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \"warning\" . The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status , representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects. ResponseMetaQuery ( BaseModel ) pydantic-model \u00b6 Information on the query that was requested. representation : str pydantic-field required \u00b6 A string with the part of the URL following the versioned or unversioned base URL that serves the API. Query parameters that have not been used in processing the request MAY be omitted. In particular, if no query parameters have been involved in processing the request, the query part of the URL MAY be excluded. Example: /structures?filter=nelements=2 Success ( Response ) pydantic-model \u00b6 errors are not allowed either_data_meta_or_errors_must_be_set ( values ) classmethod \u00b6 Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values Warnings ( OptimadeError ) pydantic-model \u00b6 OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class. type : str pydantic-field \u00b6 Warnings must be of type \"warning\" Config \u00b6 schema_extra ( schema , model ) staticmethod \u00b6 Update OpenAPI JSON schema model for Warning . Ensure type is in the list required properties and in the correct place. Remove status property. This property is not allowed for Warning , nor is it a part of the OPTIMADE definition of the Warning object. Note Since type is the last model field defined, it will simply be appended. Source code in optimade/models/optimade_json.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"Warnings\" ]) -> None : \"\"\"Update OpenAPI JSON schema model for `Warning`. * Ensure `type` is in the list required properties and in the correct place. * Remove `status` property. This property is not allowed for `Warning`, nor is it a part of the OPTIMADE definition of the `Warning` object. Note: Since `type` is the _last_ model field defined, it will simply be appended. \"\"\" if \"required\" in schema : if \"type\" not in schema [ \"required\" ]: schema [ \"required\" ] . append ( \"type\" ) else : schema [ \"required\" ] = [ \"type\" ] schema . get ( \"properties\" , {}) . pop ( \"status\" , None ) __hash__ ( self ) special \u00b6 Source code in optimade/models/optimade_json.py def __hash__ ( self ): return hash ( self . json ()) status_must_not_be_specified ( values ) classmethod \u00b6 Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def status_must_not_be_specified ( cls , values ): if values . get ( \"status\" , None ) is not None : raise ValueError ( \"status MUST NOT be specified for warnings\" ) return values","title":"optimade_json"},{"location":"api_reference/models/optimade_json/#optimade_json","text":"Modified JSON API v1.0 for OPTIMADE API","title":"optimade_json"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipMeta","text":"Specific meta field for base relationship resource","title":"BaseRelationshipMeta"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipMeta.description","text":"OPTIONAL human-readable description of the relationship","title":"description"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipResource","text":"Minimum requirements to represent a relationship resource","title":"BaseRelationshipResource"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipResource.meta","text":"Relationship meta field. MUST contain 'description' if supplied.","title":"meta"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType","text":"Optimade Data Types See the section \"Data types\" in the OPTIMADE API specification for more information.","title":"DataType"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.BOOLEAN","text":"","title":"BOOLEAN"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.DICTIONARY","text":"","title":"DICTIONARY"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.FLOAT","text":"","title":"FLOAT"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.INTEGER","text":"","title":"INTEGER"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.LIST","text":"","title":"LIST"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.STRING","text":"","title":"STRING"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.TIMESTAMP","text":"","title":"TIMESTAMP"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.DataType.UNKNOWN","text":"","title":"UNKNOWN"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Implementation","text":"Information on the server implementation","title":"Implementation"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Implementation.homepage","text":"A JSON API links object pointing to the homepage of the implementation.","title":"homepage"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Implementation.maintainer","text":"A dictionary providing details about the maintainer of the implementation.","title":"maintainer"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Implementation.name","text":"name of the implementation","title":"name"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Implementation.source_url","text":"A JSON API links object pointing to the implementation source, either downloadable archive or version control system.","title":"source_url"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Implementation.version","text":"version string of the current implementation","title":"version"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ImplementationMaintainer","text":"Details about the maintainer of the implementation","title":"ImplementationMaintainer"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ImplementationMaintainer.email","text":"the maintainer's email address","title":"email"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.OptimadeError","text":"detail MUST be present","title":"OptimadeError"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.OptimadeError.__hash__","text":"Source code in optimade/models/optimade_json.py def __hash__ ( self ): return hash ( self . json ())","title":"__hash__()"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Provider","text":"Information on the database provider of the implementation.","title":"Provider"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Provider.description","text":"a longer description of the database provider","title":"description"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Provider.homepage","text":"a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object.","title":"homepage"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Provider.name","text":"a short name for the database provider","title":"name"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Provider.prefix","text":"database-provider-specific prefix as found in section Database-Provider-Specific Namespace Prefixes.","title":"prefix"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Relationship","text":"Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource","title":"Relationship"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta","text":"A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix.","title":"ResponseMeta"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.api_version","text":"Presently used full version of the OPTIMADE API. The version number string MUST NOT be prefixed by, e.g., \"v\". Examples: 1.0.0 , 1.0.0-rc.2 .","title":"api_version"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.data_available","text":"An integer containing the total number of data resource objects available in the database for the endpoint.","title":"data_available"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.data_returned","text":"An integer containing the total number of data resource objects returned for the current filter query, independent of pagination.","title":"data_returned"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.implementation","text":"a dictionary describing the server implementation","title":"implementation"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.last_id","text":"a string containing the last ID returned","title":"last_id"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.more_data_available","text":"false if the response contains all data for the request (e.g., a request issued to a single entry endpoint, or a filter query at the last page of a paginated response) and true if the response is incomplete in the sense that multiple objects match the request, and not all of them have been included in the response (e.g., a query with multiple pages that is not at the last page).","title":"more_data_available"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.optimade_schema","text":"A JSON API links object that points to a schema for the response. If it is a string, or a dictionary containing no meta field, the provided URL MUST point at an OpenAPI schema. It is possible that future versions of this specification allows for alternative schema types. Hence, if the meta field of the JSON API links object is provided and contains a field schema_type that is not equal to the string OpenAPI the client MUST not handle failures to parse the schema or to validate the response against the schema as errors.","title":"optimade_schema"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.provider","text":"information on the database provider of the implementation.","title":"provider"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.query","text":"Information on the Query that was requested","title":"query"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.response_message","text":"response string from the server","title":"response_message"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.time_stamp","text":"A timestamp containing the date and time at which the query was executed.","title":"time_stamp"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.warnings","text":"A list of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \"warning\" . The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status , representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects.","title":"warnings"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMetaQuery","text":"Information on the query that was requested.","title":"ResponseMetaQuery"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.ResponseMetaQuery.representation","text":"A string with the part of the URL following the versioned or unversioned base URL that serves the API. Query parameters that have not been used in processing the request MAY be omitted. In particular, if no query parameters have been involved in processing the request, the query part of the URL MAY be excluded. Example: /structures?filter=nelements=2","title":"representation"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Success","text":"errors are not allowed","title":"Success"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Success.either_data_meta_or_errors_must_be_set","text":"Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values","title":"either_data_meta_or_errors_must_be_set()"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Warnings","text":"OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class.","title":"Warnings"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Warnings.type","text":"Warnings must be of type \"warning\"","title":"type"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Warnings.Config","text":"","title":"Config"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Warnings.Config.schema_extra","text":"Update OpenAPI JSON schema model for Warning . Ensure type is in the list required properties and in the correct place. Remove status property. This property is not allowed for Warning , nor is it a part of the OPTIMADE definition of the Warning object. Note Since type is the last model field defined, it will simply be appended. Source code in optimade/models/optimade_json.py @staticmethod def schema_extra ( schema : Dict [ str , Any ], model : Type [ \"Warnings\" ]) -> None : \"\"\"Update OpenAPI JSON schema model for `Warning`. * Ensure `type` is in the list required properties and in the correct place. * Remove `status` property. This property is not allowed for `Warning`, nor is it a part of the OPTIMADE definition of the `Warning` object. Note: Since `type` is the _last_ model field defined, it will simply be appended. \"\"\" if \"required\" in schema : if \"type\" not in schema [ \"required\" ]: schema [ \"required\" ] . append ( \"type\" ) else : schema [ \"required\" ] = [ \"type\" ] schema . get ( \"properties\" , {}) . pop ( \"status\" , None )","title":"schema_extra()"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Warnings.__hash__","text":"Source code in optimade/models/optimade_json.py def __hash__ ( self ): return hash ( self . json ())","title":"__hash__()"},{"location":"api_reference/models/optimade_json/#optimade.models.optimade_json.Warnings.status_must_not_be_specified","text":"Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def status_must_not_be_specified ( cls , values ): if values . get ( \"status\" , None ) is not None : raise ValueError ( \"status MUST NOT be specified for warnings\" ) return values","title":"status_must_not_be_specified()"},{"location":"api_reference/models/references/","text":"references \u00b6 Person ( BaseModel ) pydantic-model \u00b6 A person, i.e., an author, editor or other. firstname : str pydantic-field \u00b6 First name of the person. lastname : str pydantic-field \u00b6 Last name of the person. name : str pydantic-field required \u00b6 Full name of the person, REQUIRED. ReferenceResource ( EntryResource ) pydantic-model \u00b6 The references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , volume , year : meanings of these properties match the BibTeX specification , values are strings; bib_type : type of the reference, corresponding to type property in the BibTeX specification, value is string; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., any of the properties MAY be null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties. validate_attributes ( v ) classmethod \u00b6 Source code in optimade/models/references.py @validator ( \"attributes\" ) def validate_attributes ( cls , v ): if not any ( prop [ 1 ] is not None for prop in v ): raise ValueError ( \"reference object must have at least one field defined\" ) return v ReferenceResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification . address : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. annote : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. authors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the authors of the reference. bib_type : str pydantic-field \u00b6 Type of the reference, corresponding to the type property in the BiBTeX specification. booktitle : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. chapter : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. crossref : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. doi : str pydantic-field \u00b6 The digital object identifier of the reference. edition : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. editors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the editors of the reference. howpublished : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. institution : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. journal : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. key : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. month : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. note : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. number : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. organization : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. pages : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. publisher : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. school : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. series : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. title : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. url : AnyUrl pydantic-field \u00b6 The URL of the reference. volume : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. year : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification.","title":"references"},{"location":"api_reference/models/references/#references","text":"","title":"references"},{"location":"api_reference/models/references/#optimade.models.references.Person","text":"A person, i.e., an author, editor or other.","title":"Person"},{"location":"api_reference/models/references/#optimade.models.references.Person.firstname","text":"First name of the person.","title":"firstname"},{"location":"api_reference/models/references/#optimade.models.references.Person.lastname","text":"Last name of the person.","title":"lastname"},{"location":"api_reference/models/references/#optimade.models.references.Person.name","text":"Full name of the person, REQUIRED.","title":"name"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResource","text":"The references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , volume , year : meanings of these properties match the BibTeX specification , values are strings; bib_type : type of the reference, corresponding to type property in the BibTeX specification, value is string; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., any of the properties MAY be null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties.","title":"ReferenceResource"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResource.validate_attributes","text":"Source code in optimade/models/references.py @validator ( \"attributes\" ) def validate_attributes ( cls , v ): if not any ( prop [ 1 ] is not None for prop in v ): raise ValueError ( \"reference object must have at least one field defined\" ) return v","title":"validate_attributes()"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes","text":"Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification .","title":"ReferenceResourceAttributes"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.address","text":"Meaning of property matches the BiBTeX specification.","title":"address"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.annote","text":"Meaning of property matches the BiBTeX specification.","title":"annote"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.authors","text":"List of person objects containing the authors of the reference.","title":"authors"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.bib_type","text":"Type of the reference, corresponding to the type property in the BiBTeX specification.","title":"bib_type"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.booktitle","text":"Meaning of property matches the BiBTeX specification.","title":"booktitle"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.chapter","text":"Meaning of property matches the BiBTeX specification.","title":"chapter"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.crossref","text":"Meaning of property matches the BiBTeX specification.","title":"crossref"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.doi","text":"The digital object identifier of the reference.","title":"doi"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.edition","text":"Meaning of property matches the BiBTeX specification.","title":"edition"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.editors","text":"List of person objects containing the editors of the reference.","title":"editors"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.howpublished","text":"Meaning of property matches the BiBTeX specification.","title":"howpublished"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.institution","text":"Meaning of property matches the BiBTeX specification.","title":"institution"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.journal","text":"Meaning of property matches the BiBTeX specification.","title":"journal"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.key","text":"Meaning of property matches the BiBTeX specification.","title":"key"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.month","text":"Meaning of property matches the BiBTeX specification.","title":"month"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.note","text":"Meaning of property matches the BiBTeX specification.","title":"note"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.number","text":"Meaning of property matches the BiBTeX specification.","title":"number"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.organization","text":"Meaning of property matches the BiBTeX specification.","title":"organization"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.pages","text":"Meaning of property matches the BiBTeX specification.","title":"pages"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.publisher","text":"Meaning of property matches the BiBTeX specification.","title":"publisher"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.school","text":"Meaning of property matches the BiBTeX specification.","title":"school"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.series","text":"Meaning of property matches the BiBTeX specification.","title":"series"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.title","text":"Meaning of property matches the BiBTeX specification.","title":"title"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.url","text":"The URL of the reference.","title":"url"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.volume","text":"Meaning of property matches the BiBTeX specification.","title":"volume"},{"location":"api_reference/models/references/#optimade.models.references.ReferenceResourceAttributes.year","text":"Meaning of property matches the BiBTeX specification.","title":"year"},{"location":"api_reference/models/responses/","text":"responses \u00b6 EntryInfoResponse ( Success ) pydantic-model \u00b6 EntryResponseMany ( Success ) pydantic-model \u00b6 EntryResponseOne ( Success ) pydantic-model \u00b6 ErrorResponse ( Response ) pydantic-model \u00b6 errors MUST be present and data MUST be skipped data_must_be_skipped ( values ) classmethod \u00b6 Source code in optimade/models/responses.py @root_validator ( pre = True ) def data_must_be_skipped ( cls , values ): if values . get ( \"data\" , None ) is not None : raise ValueError ( \"data MUST be skipped for failures reporting errors\" ) return values IndexInfoResponse ( Success ) pydantic-model \u00b6 InfoResponse ( Success ) pydantic-model \u00b6 LinksResponse ( EntryResponseMany ) pydantic-model \u00b6 ReferenceResponseMany ( EntryResponseMany ) pydantic-model \u00b6 ReferenceResponseOne ( EntryResponseOne ) pydantic-model \u00b6 StructureResponseMany ( EntryResponseMany ) pydantic-model \u00b6 StructureResponseOne ( EntryResponseOne ) pydantic-model \u00b6","title":"responses"},{"location":"api_reference/models/responses/#responses","text":"","title":"responses"},{"location":"api_reference/models/responses/#optimade.models.responses.EntryInfoResponse","text":"","title":"EntryInfoResponse"},{"location":"api_reference/models/responses/#optimade.models.responses.EntryResponseMany","text":"","title":"EntryResponseMany"},{"location":"api_reference/models/responses/#optimade.models.responses.EntryResponseOne","text":"","title":"EntryResponseOne"},{"location":"api_reference/models/responses/#optimade.models.responses.ErrorResponse","text":"errors MUST be present and data MUST be skipped","title":"ErrorResponse"},{"location":"api_reference/models/responses/#optimade.models.responses.ErrorResponse.data_must_be_skipped","text":"Source code in optimade/models/responses.py @root_validator ( pre = True ) def data_must_be_skipped ( cls , values ): if values . get ( \"data\" , None ) is not None : raise ValueError ( \"data MUST be skipped for failures reporting errors\" ) return values","title":"data_must_be_skipped()"},{"location":"api_reference/models/responses/#optimade.models.responses.IndexInfoResponse","text":"","title":"IndexInfoResponse"},{"location":"api_reference/models/responses/#optimade.models.responses.InfoResponse","text":"","title":"InfoResponse"},{"location":"api_reference/models/responses/#optimade.models.responses.LinksResponse","text":"","title":"LinksResponse"},{"location":"api_reference/models/responses/#optimade.models.responses.ReferenceResponseMany","text":"","title":"ReferenceResponseMany"},{"location":"api_reference/models/responses/#optimade.models.responses.ReferenceResponseOne","text":"","title":"ReferenceResponseOne"},{"location":"api_reference/models/responses/#optimade.models.responses.StructureResponseMany","text":"","title":"StructureResponseMany"},{"location":"api_reference/models/responses/#optimade.models.responses.StructureResponseOne","text":"","title":"StructureResponseOne"},{"location":"api_reference/models/structures/","text":"structures \u00b6 CORRELATED_STRUCTURE_FIELDS \u00b6 EPS \u00b6 EXTENDED_CHEMICAL_SYMBOLS \u00b6 Vector3D \u00b6 Vector3D_unknown \u00b6 Assembly ( BaseModel ) pydantic-model \u00b6 A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). group_probabilities : List [ float ] pydantic-field required \u00b6 Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species . sites_in_groups : List [ List [ int ]] pydantic-field required \u00b6 Index of the sites (0-based) that belong to each group for each assembly. Examples : [[1], [2]] : two groups, one with the second site, one with the third. [[1,2], [3]] : one group with the second and third site, one with the fourth. check_self_consistency ( v , values ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"group_probabilities\" ) def check_self_consistency ( cls , v , values ): if len ( v ) != len ( values . get ( \"sites_in_groups\" , [])): raise ValueError ( f \"sites_in_groups and group_probabilities MUST be of same length, \" f \"but are { len ( values . get ( 'sites_in_groups' , [])) } and { len ( v ) } , respectively\" ) return v validate_sites_in_groups ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"sites_in_groups\" ) def validate_sites_in_groups ( cls , v ): sites = [] for group in v : sites . extend ( group ) if len ( set ( sites )) != len ( sites ): raise ValueError ( f \"A site MUST NOT appear in more than one group. Given value: { v } \" ) return v Periodicity ( IntEnum ) \u00b6 Integer enumeration of dimension_types values APERIODIC \u00b6 PERIODIC \u00b6 Species ( BaseModel ) pydantic-model \u00b6 A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms. attached : List [ str ] pydantic-field \u00b6 If provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element. chemical_symbols : List [ str ] pydantic-field required \u00b6 MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features . concentration : List [ float ] pydantic-field required \u00b6 MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : List [ float ] pydantic-field \u00b6 If present MUST be a list of floats expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0. name : str pydantic-field required \u00b6 Gives the name of the species; the name value MUST be unique in the species list. nattached : List [ int ] pydantic-field \u00b6 If provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the :field: attached key. original_name : str pydantic-field \u00b6 Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. attached_nattached_mutually_exclusive ( values ) classmethod \u00b6 Source code in optimade/models/structures.py @root_validator def attached_nattached_mutually_exclusive ( cls , values ): attached , nattached = ( values . get ( \"attached\" , None ), values . get ( \"nattached\" , None ), ) if ( attached is None and nattached is not None ) or ( attached is not None and nattached is None ): raise ValueError ( f \"Either both or none of attached ( { attached } ) and nattached ( { nattached } ) MUST be set.\" ) if ( attached is not None and nattached is not None and len ( attached ) != len ( nattached ) ): raise ValueError ( f \"attached ( { attached } ) and nattached ( { nattached } ) MUST be lists of equal length.\" ) return values validate_chemical_symbols ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"chemical_symbols\" , each_item = True ) def validate_chemical_symbols ( cls , v ): if not ( v in EXTENDED_CHEMICAL_SYMBOLS ): raise ValueError ( f \" { v } MUST be in { EXTENDED_CHEMICAL_SYMBOLS } \" ) return v validate_concentration_and_mass ( v , values , field ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"concentration\" , \"mass\" ) def validate_concentration_and_mass ( cls , v , values , field ): if not v : return v if values . get ( \"chemical_symbols\" ): if len ( v ) != len ( values [ \"chemical_symbols\" ]): raise ValueError ( f \"Length of concentration ( { len ( v ) } ) MUST equal length of chemical_symbols \" f \"( { len ( values . get ( 'chemical_symbols' , [])) } )\" ) return v raise ValueError ( \"Could not validate {field.name} as 'chemical_symbols' is missing/invalid.\" ) validate_minimum_list_length ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"attached\" , \"nattached\" ) def validate_minimum_list_length ( cls , v ): if v is not None and len ( v ) < 1 : raise ValueError ( f \"The list's length MUST be 1 or more, instead it was found to be { len ( v ) } \" ) return v StructureFeatures ( Enum ) \u00b6 Enumeration of structure_features values ASSEMBLIES \u00b6 DISORDER \u00b6 IMPLICIT_ATOMS \u00b6 SITE_ATTACHMENTS \u00b6 StructureResource ( EntryResource ) pydantic-model \u00b6 Representing a structure. StructureResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions. assemblies : List [ optimade . models . structures . Assembly ] pydantic-field \u00b6 A description of groups of sites that are statistically correlated. Type : list of dictionary with keys: sites_in_groups : list of list of integers (REQUIRED) group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. The property SHOULD be null for entries that have no partial occupancies. If present, the correct flag MUST be set in the list structure_features . Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: [[1], [2]] : two groups, one with the second site, one with the third. Example: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species . If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: { \"cartesian_site_positions\" : [[ 0 , 0 , 0 ]], \"species_at_sites\" : [ \"SiGe-vac\" ], \"species\" : [ { \"name\" : \"SiGe-vac\" , \"chemical_symbols\" : [ \"Si\" , \"Ge\" , \"vacancy\" ], \"concentration\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } Using multiple species and the assemblies: { \"cartesian_site_positions\" : [ [ 0 , 0 , 0 ], [ 0 , 0 , 0 ], [ 0 , 0 , 0 ] ], \"species_at_sites\" : [ \"Si\" , \"Ge\" , \"vac\" ], \"species\" : [ { \"name\" : \"Si\" , \"chemical_symbols\" : [ \"Si\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"Ge\" , \"chemical_symbols\" : [ \"Ge\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"vac\" , \"chemical_symbols\" : [ \"vacancy\" ], \"concentration\" : [ 1.0 ] } }, \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ], [ 2 ] ], \"group_probabilities\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: { \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ] ], \"group_probabilities\" : [ 0.2 , 0.8 ], }, { \"sites_in_groups\" : [ [ 2 ], [ 3 ] ], \"group_probabilities\" : [ 0.3 , 0.7 ] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability). cartesian_site_positions : List [ types . ConstrainedListValue ] pydantic-field required \u00b6 Cartesian positions of each site in the structure. A site is usually used to describe positions of atoms; what atoms can be encountered at a given site is conveyed by the species_at_sites property, and the species themselves are described in the species property. Type : list of list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length equal to the number of sites in the structure, where every element is a list of the three Cartesian coordinates of a site expressed as float values in the unit angstrom (\u00c5). An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies ). Examples : [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin. chemical_formula_anonymous : ConstrainedStrValue pydantic-field required \u00b6 The anonymous formula is the chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : \"A2B\" \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is chemical_formula_anonymous=\"A2B\" . chemical_formula_descriptive : str pydantic-field required \u00b6 The chemical formula for a structure as a string in a form chosen by the API implementation. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry . Examples : \"(H2O)2 Na\" \"NaCl\" \"CaCO3\" \"CCaO3\" \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: chemical_formula_descriptive CONTAINS \"H2O\" . chemical_formula_hill : ConstrainedStrValue pydantic-field \u00b6 The chemical formula for a structure in Hill form with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, only a subset of the filter features MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, chemical_formula_hill is \"H2O2\" (i.e., not \"HO\" , nor \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in Hill order , followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : \"H2O2\" Query examples : A filter that matches an exactly given formula is chemical_formula_hill=\"H2O2\" . chemical_formula_reduced : ConstrainedStrValue pydantic-field required \u00b6 The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate queries on formula components are instead suggested to be formulated using set-type filter operators on the multi valued elements and elements_ratios properties. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : \"H2NaO\" \"ClNa\" \"CCaO3\" Query examples : A filter that matches an exactly given formula is chemical_formula_reduced=\"H2NaO\" . dimension_types : ConstrainedListValue pydantic-field \u00b6 List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ), this list indicates if the direction is periodic (value 1 ) or non-periodic (value 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in lattice_vectors and not the Cartesian x, y, z directions. Type : list of integers. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: [0, 0, 0] For a wire along the direction specified by the third lattice vector: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: [1, 0, 1] For a bulk 3D system: [1, 1, 1] elements : List [ str ] pydantic-field required \u00b6 Names of the different elements present in the structure. Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The strings are the chemical symbols, i.e., either a single uppercase letter or an uppercase letter followed by a number of lowercase letters. The order MUST be alphabetical. Note: This property SHOULD NOT contain the string \"X\" to indicate non-chemical elements or \"vacancy\" to indicate vacancies (in contrast to the field chemical_symbols for the species property). Examples : [\"Si\"] [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use elements HAS ALL \"Si\", \"Al\", \"O\" AND elements LENGTH 3 . elements_ratios : List [ float ] pydantic-field required \u00b6 Relative proportions of different elements in the structure. Type : list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : [1.0] [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: Useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally inadvisable. OPTIONAL: a filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 . lattice_vectors : ConstrainedListValue pydantic-field \u00b6 The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). Type : list of list of floats or unknown values. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. MUST always contain three vectors of three coordinates each, independently of the elements of property dimension_types . The vectors SHOULD by convention be chosen so the determinant of the lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. The coordinates of the lattice vectors of non-periodic dimensions (i.e., those dimensions for which dimension_types is 0 ) MAY be given as a list of all null values. If a lattice vector contains the value null , all coordinates of that lattice vector MUST be null . Examples : [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is (4, 0, 0) , i.e., a vector aligned along the x axis of length 4 \u00c5; the second vector is (0, 4, 0) ; and the third vector is (0, 1, 4) . nelements : int pydantic-field required \u00b6 Number of different elements in the structure as an integer. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 3 Querying : Note: queries on this property can equivalently be formulated using elements LENGTH . A filter that matches structures that have exactly 4 elements: nelements=4 . A filter that matches structures that have between 2 and 7 elements: nelements>=2 AND nelements<=7 . nperiodic_dimensions : int pydantic-field required \u00b6 An integer specifying the number of periodic dimensions in the structure, equivalent to the number of non-zero entries in dimension_types . Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The integer value MUST be between 0 and 3 inclusive and MUST be equal to the sum of the items in the dimension_types property. This property only reflects the treatment of the lattice vectors provided for the structure, and not any physical interpretation of the dimensionality of its contents. Examples : 2 should be indicated in cases where dimension_types is any of [1, 1, 0] , [1, 0, 1] , [0, 1, 1] . Query examples : Match only structures with exactly 3 periodic dimensions: nperiodic_dimensions=3 Match all structures with 2 or fewer periodic dimensions: nperiodic_dimensions<=2 nsites : int pydantic-field required \u00b6 An integer specifying the length of the cartesian_site_positions property. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 42 Query examples : Match only structures with exactly 4 sites: nsites=4 Match structures that have between 2 and 7 sites: nsites>=2 AND nsites<=7 species : List [ optimade . models . structures . Species ] pydantic-field required \u00b6 A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Type : list of dictionary with keys: name : string (REQUIRED) chemical_symbols : list of strings (REQUIRED) concentration : list of float (REQUIRED) attached : list of strings (REQUIRED) nattached : list of integers (OPTIONAL) mass : list of floats (OPTIONAL) original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features . concentration : REQUIRED; MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different sites (even of the same species). attached : OPTIONAL; if provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element. nattached : OPTIONAL; if provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the attached key. The implementation MUST include either both or none of the attached and nattached keys, and if they are provided, they MUST be of the same length. Furthermore, if they are provided, the structure_features property MUST include the string site_attachments . mass : OPTIONAL. If present MUST be a list of floats, with the same length as chemical_symbols , providing element masses expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites ). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., \"Ti\" for titanium, \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms. species_at_sites : List [ str ] pydantic-field required \u00b6 Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions ). Each species name mentioned in the species_at_sites list MUST be described in the list property species (i.e. for each value in the species_at_sites list there MUST exist exactly one dictionary in the species list with the name attribute equal to the corresponding species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled \"Ti\" and the second a species labeled \"O2\" . [\"Ac\", \"Ac\", \"Ag\", \"Ir\"] indicating the first two sites contains the \"Ac\" species, while the third and fourth sites contain the \"Ag\" and \"Ir\" species, respectively. structure_features : List [ optimade . models . structures . StructureFeatures ] pydantic-field required \u00b6 A list of strings that flag which special features are used by the structure. Type : list of strings Requirements/Conventions : Support : MUST be supported by all implementations, MUST NOT be null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : disorder : this flag MUST be present if any one entry in the species list has a chemical_symbols list that is longer than 1 element. implicit_atoms : this flag MUST be present if the structure contains atoms that are not assigned to sites via the property species_at_sites (e.g., because their positions are unknown). When this flag is present, the properties related to the chemical formula will likely not match the type and count of atoms represented by the species_at_sites , species and assemblies properties. site_attachments : this flag MUST be present if any one entry in the species list includes attached and nattached . assemblies : this flag MUST be present if the property assemblies is present. Examples : A structure having implicit atoms and using assemblies: [\"assemblies\", \"implicit_atoms\"] Config \u00b6 schema_extra ( schema , model ) \u00b6 Two things need to be added to the schema: Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, dimension_types and lattice_vectors , are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be nullable according to the OpenAPI definition. Source code in optimade/models/structures.py def schema_extra ( schema , model ): \"\"\"Two things need to be added to the schema: 1. Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, `dimension_types` and `lattice_vectors`, are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. 2. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be `nullable` according to the OpenAPI definition. \"\"\" schema [ \"required\" ] . insert ( 7 , \"dimension_types\" ) schema [ \"required\" ] . insert ( 9 , \"lattice_vectors\" ) nullable_props = ( prop for prop in schema [ \"required\" ] if schema [ \"properties\" ][ prop ] . get ( \"support\" ) == SupportLevel . SHOULD ) for prop in nullable_props : schema [ \"properties\" ][ prop ][ \"nullable\" ] = True check_anonymous_formula ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"chemical_formula_anonymous\" ) def check_anonymous_formula ( cls , v ): if v is None : return v elements = tuple ( re . findall ( r \"[A-Z][a-z]*\" , v )) numbers = [ int ( n . strip ()) for n in re . split ( r \"[A-Z][a-z]*\" , v ) if n . strip ()] if any ( n == 1 for n in numbers ): raise ValueError ( f \"'chemical_formula_anonymous' { v } must omit proportion '1'\" ) expected_labels = ANONYMOUS_ELEMENTS [: len ( elements )] expected_numbers = sorted ( numbers , reverse = True ) if expected_numbers != numbers : raise ValueError ( f \"'chemical_formula_anonymous' { v } has wrong order: elements with highest proportion should appear first: { numbers } vs expected { expected_numbers } \" ) if elements != expected_labels : raise ValueError ( f \"'chemical_formula_anonymous' { v } has wrong labels: { elements } vs expected { expected_labels } .\" ) return v check_ordered_formula ( v , field ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"chemical_formula_reduced\" , \"chemical_formula_hill\" ) def check_ordered_formula ( cls , v , field ): if v is None : return v numbers = re . findall ( r \"(\\d+\\.?)+\" , v ) elements = re . findall ( r \"[A-Z][a-z]?\" , v ) expected_elements = sorted ( elements ) if field . name == \"chemical_formula_hill\" : # Make sure C is first (and H is second, if present along with C). if \"C\" in expected_elements : expected_elements = sorted ( expected_elements , key = lambda elem : { \"C\" : \"0\" , \"H\" : \"1\" } . get ( elem , elem ), ) if any ( elem not in CHEMICAL_SYMBOLS for elem in elements ): raise ValueError ( f \"Cannot use unknown chemical symbols { [ elem for elem in elements if elem not in CHEMICAL_SYMBOLS ] } in { field . name !r} \" ) if \"1\" in numbers : raise ValueError ( f \"Must omit proportion '1' from formula { v } in { field . name !r} \" ) if expected_elements != elements : order = \"Hill\" if field . name == \"chemical_formula_hill\" else \"alphabetical\" raise ValueError ( f \"Elements in { field . name !r} must appear in { order } order: { expected_elements } not { elements } .\" ) return v check_periodic_dimensions ( v , values ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"nperiodic_dimensions\" ) def check_periodic_dimensions ( cls , v , values ): if v is None : return v if values . get ( \"dimension_types\" ) and v != sum ( values . get ( \"dimension_types\" )): raise ValueError ( f \"nperiodic_dimensions ( { v } ) does not match expected value of { sum ( values [ 'dimension_types' ]) } \" f \"from dimension_types ( { values [ 'dimension_types' ] } )\" ) return v element_must_be_chemical_symbol ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"elements\" , each_item = True ) def element_must_be_chemical_symbol ( cls , v ): if v not in CHEMICAL_SYMBOLS : raise ValueError ( f \"Only chemical symbols are allowed, you passed: { v } \" ) return v elements_must_be_alphabetical ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"elements\" ) def elements_must_be_alphabetical ( cls , v ): if v is None : return v if sorted ( v ) != v : raise ValueError ( f \"elements must be sorted alphabetically, but is: { v } \" ) return v null_values_for_whole_vector ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"lattice_vectors\" ) def null_values_for_whole_vector ( cls , v ): if v is None : return v for vector in v : if None in vector and any (( isinstance ( _ , float ) for _ in vector )): raise ValueError ( f \"A lattice vector MUST be either all `null` or all numbers (vector: { vector } , all vectors: { v } )\" ) return v ratios_must_sum_to_one ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"elements_ratios\" ) def ratios_must_sum_to_one ( cls , v ): if v is None : return v if abs ( sum ( v ) - 1 ) > EPS : raise ValueError ( f \"elements_ratios MUST sum to 1 within floating point accuracy. It sums to: { sum ( v ) } \" ) return v required_if_dimension_types_has_one ( v , values ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"lattice_vectors\" , always = True ) def required_if_dimension_types_has_one ( cls , v , values ): if v is None : return v if values . get ( \"dimension_types\" ): for dim_type , vector in zip ( values . get ( \"dimension_types\" , ( None ,) * 3 ), v ): if None in vector and dim_type == Periodicity . PERIODIC . value : raise ValueError ( f \"Null entries in lattice vectors are only permitted when the corresponding dimension type is { Periodicity . APERIODIC . value } . \" f \"Here: dimension_types = { tuple ( getattr ( _ , 'value' , None ) for _ in values . get ( 'dimension_types' , [])) } , lattice_vectors = { v } \" ) return v validate_nsites ( v , values ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"nsites\" ) def validate_nsites ( cls , v , values ): if v is None : return v if values . get ( \"cartesian_site_positions\" ) and v != len ( values . get ( \"cartesian_site_positions\" , []) ): raise ValueError ( f \"nsites (value: { v } ) MUST equal length of cartesian_site_positions \" f \"(value: { len ( values . get ( 'cartesian_site_positions' , [])) } )\" ) return v validate_species ( v ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"species\" ) def validate_species ( cls , v ): if v is None : return v all_species = [ _ . name for _ in v ] unique_species = set ( all_species ) if len ( all_species ) != len ( unique_species ): raise ValueError ( f \"Species MUST be unique based on their 'name'. Found species names: { all_species } \" ) return v validate_species_at_sites ( v , values ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"species_at_sites\" ) def validate_species_at_sites ( cls , v , values ): if v is None : return v if values . get ( \"nsites\" ) and len ( v ) != values . get ( \"nsites\" ): raise ValueError ( f \"Number of species_at_sites (value: { len ( v ) } ) MUST equal number of sites \" f \"(value: { values . get ( 'nsites' , 'Not specified' ) } )\" ) if values . get ( \"species\" ): all_species_names = { getattr ( _ , \"name\" , None ) for _ in values . get ( \"species\" , [{}]) } all_species_names -= { None } for value in v : if value not in all_species_names : raise ValueError ( \"species_at_sites MUST be represented by a species' name, \" f \"but { value } was not found in the list of species names: { all_species_names } \" ) return v validate_structure_features ( v , values ) classmethod \u00b6 Source code in optimade/models/structures.py @validator ( \"structure_features\" , always = True ) def validate_structure_features ( cls , v , values ): if [ StructureFeatures ( value ) for value in sorted (( _ . value for _ in v ))] != v : raise ValueError ( f \"structure_features MUST be sorted alphabetically, given value: { v } \" ) # assemblies if values . get ( \"assemblies\" ) is not None : if StructureFeatures . ASSEMBLIES not in v : raise ValueError ( f \" { StructureFeatures . ASSEMBLIES . value } MUST be present, since the property of the same name is present\" ) elif StructureFeatures . ASSEMBLIES in v : raise ValueError ( f \" { StructureFeatures . ASSEMBLIES . value } MUST NOT be present, \" \"since the property of the same name is not present\" ) if values . get ( \"species\" ): # disorder for species in values . get ( \"species\" , []): if len ( species . chemical_symbols ) > 1 : if StructureFeatures . DISORDER not in v : raise ValueError ( f \" { StructureFeatures . DISORDER . value } MUST be present when any one entry in species \" \"has a chemical_symbols list greater than one element\" ) break else : if StructureFeatures . DISORDER in v : raise ValueError ( f \" { StructureFeatures . DISORDER . value } MUST NOT be present, since all species' chemical_symbols \" \"lists are equal to or less than one element\" ) # site_attachments for species in values . get ( \"species\" , []): # There is no need to also test \"nattached\", # since a Species validator makes sure either both are present or both are None. if getattr ( species , \"attached\" , None ) is not None : if StructureFeatures . SITE_ATTACHMENTS not in v : raise ValueError ( f \" { StructureFeatures . SITE_ATTACHMENTS . value } MUST be present when any one entry \" \"in species includes attached and nattached\" ) break else : if StructureFeatures . SITE_ATTACHMENTS in v : raise ValueError ( f \" { StructureFeatures . SITE_ATTACHMENTS . value } MUST NOT be present, since no species includes \" \"the attached and nattached fields\" ) # implicit_atoms species_names = [ _ . name for _ in values . get ( \"species\" , [])] for name in species_names : if values . get ( \"species_at_sites\" ) is not None and name not in values . get ( \"species_at_sites\" , []): if StructureFeatures . IMPLICIT_ATOMS not in v : raise ValueError ( f \" { StructureFeatures . IMPLICIT_ATOMS . value } MUST be present when any one entry in species \" \"is not represented in species_at_sites\" ) break else : if StructureFeatures . IMPLICIT_ATOMS in v : raise ValueError ( f \" { StructureFeatures . IMPLICIT_ATOMS . value } MUST NOT be present, since all species are \" \"represented in species_at_sites\" ) return v warn_on_missing_correlated_fields ( values ) classmethod \u00b6 Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. Source code in optimade/models/structures.py @root_validator ( pre = True ) def warn_on_missing_correlated_fields ( cls , values ): \"\"\"Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. \"\"\" accumulated_warnings = [] for field_set in CORRELATED_STRUCTURE_FIELDS : missing_fields = { f for f in field_set if values . get ( f ) is None } if missing_fields and len ( missing_fields ) != len ( field_set ): accumulated_warnings += [ f \"Structure with values { values } is missing fields { missing_fields } which are required if { field_set - missing_fields } are present.\" ] for warn in accumulated_warnings : warnings . warn ( warn , MissingExpectedField ) return values","title":"structures"},{"location":"api_reference/models/structures/#structures","text":"","title":"structures"},{"location":"api_reference/models/structures/#optimade.models.structures.CORRELATED_STRUCTURE_FIELDS","text":"","title":"CORRELATED_STRUCTURE_FIELDS"},{"location":"api_reference/models/structures/#optimade.models.structures.EPS","text":"","title":"EPS"},{"location":"api_reference/models/structures/#optimade.models.structures.EXTENDED_CHEMICAL_SYMBOLS","text":"","title":"EXTENDED_CHEMICAL_SYMBOLS"},{"location":"api_reference/models/structures/#optimade.models.structures.Vector3D","text":"","title":"Vector3D"},{"location":"api_reference/models/structures/#optimade.models.structures.Vector3D_unknown","text":"","title":"Vector3D_unknown"},{"location":"api_reference/models/structures/#optimade.models.structures.Assembly","text":"A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent).","title":"Assembly"},{"location":"api_reference/models/structures/#optimade.models.structures.Assembly.group_probabilities","text":"Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species .","title":"group_probabilities"},{"location":"api_reference/models/structures/#optimade.models.structures.Assembly.sites_in_groups","text":"Index of the sites (0-based) that belong to each group for each assembly. Examples : [[1], [2]] : two groups, one with the second site, one with the third. [[1,2], [3]] : one group with the second and third site, one with the fourth.","title":"sites_in_groups"},{"location":"api_reference/models/structures/#optimade.models.structures.Assembly.check_self_consistency","text":"Source code in optimade/models/structures.py @validator ( \"group_probabilities\" ) def check_self_consistency ( cls , v , values ): if len ( v ) != len ( values . get ( \"sites_in_groups\" , [])): raise ValueError ( f \"sites_in_groups and group_probabilities MUST be of same length, \" f \"but are { len ( values . get ( 'sites_in_groups' , [])) } and { len ( v ) } , respectively\" ) return v","title":"check_self_consistency()"},{"location":"api_reference/models/structures/#optimade.models.structures.Assembly.validate_sites_in_groups","text":"Source code in optimade/models/structures.py @validator ( \"sites_in_groups\" ) def validate_sites_in_groups ( cls , v ): sites = [] for group in v : sites . extend ( group ) if len ( set ( sites )) != len ( sites ): raise ValueError ( f \"A site MUST NOT appear in more than one group. Given value: { v } \" ) return v","title":"validate_sites_in_groups()"},{"location":"api_reference/models/structures/#optimade.models.structures.Periodicity","text":"Integer enumeration of dimension_types values","title":"Periodicity"},{"location":"api_reference/models/structures/#optimade.models.structures.Periodicity.APERIODIC","text":"","title":"APERIODIC"},{"location":"api_reference/models/structures/#optimade.models.structures.Periodicity.PERIODIC","text":"","title":"PERIODIC"},{"location":"api_reference/models/structures/#optimade.models.structures.Species","text":"A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms.","title":"Species"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.attached","text":"If provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element.","title":"attached"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.chemical_symbols","text":"MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features .","title":"chemical_symbols"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.concentration","text":"MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species).","title":"concentration"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.mass","text":"If present MUST be a list of floats expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0.","title":"mass"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.name","text":"Gives the name of the species; the name value MUST be unique in the species list.","title":"name"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.nattached","text":"If provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the :field: attached key.","title":"nattached"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.original_name","text":"Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation.","title":"original_name"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.attached_nattached_mutually_exclusive","text":"Source code in optimade/models/structures.py @root_validator def attached_nattached_mutually_exclusive ( cls , values ): attached , nattached = ( values . get ( \"attached\" , None ), values . get ( \"nattached\" , None ), ) if ( attached is None and nattached is not None ) or ( attached is not None and nattached is None ): raise ValueError ( f \"Either both or none of attached ( { attached } ) and nattached ( { nattached } ) MUST be set.\" ) if ( attached is not None and nattached is not None and len ( attached ) != len ( nattached ) ): raise ValueError ( f \"attached ( { attached } ) and nattached ( { nattached } ) MUST be lists of equal length.\" ) return values","title":"attached_nattached_mutually_exclusive()"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.validate_chemical_symbols","text":"Source code in optimade/models/structures.py @validator ( \"chemical_symbols\" , each_item = True ) def validate_chemical_symbols ( cls , v ): if not ( v in EXTENDED_CHEMICAL_SYMBOLS ): raise ValueError ( f \" { v } MUST be in { EXTENDED_CHEMICAL_SYMBOLS } \" ) return v","title":"validate_chemical_symbols()"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.validate_concentration_and_mass","text":"Source code in optimade/models/structures.py @validator ( \"concentration\" , \"mass\" ) def validate_concentration_and_mass ( cls , v , values , field ): if not v : return v if values . get ( \"chemical_symbols\" ): if len ( v ) != len ( values [ \"chemical_symbols\" ]): raise ValueError ( f \"Length of concentration ( { len ( v ) } ) MUST equal length of chemical_symbols \" f \"( { len ( values . get ( 'chemical_symbols' , [])) } )\" ) return v raise ValueError ( \"Could not validate {field.name} as 'chemical_symbols' is missing/invalid.\" )","title":"validate_concentration_and_mass()"},{"location":"api_reference/models/structures/#optimade.models.structures.Species.validate_minimum_list_length","text":"Source code in optimade/models/structures.py @validator ( \"attached\" , \"nattached\" ) def validate_minimum_list_length ( cls , v ): if v is not None and len ( v ) < 1 : raise ValueError ( f \"The list's length MUST be 1 or more, instead it was found to be { len ( v ) } \" ) return v","title":"validate_minimum_list_length()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureFeatures","text":"Enumeration of structure_features values","title":"StructureFeatures"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureFeatures.ASSEMBLIES","text":"","title":"ASSEMBLIES"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureFeatures.DISORDER","text":"","title":"DISORDER"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureFeatures.IMPLICIT_ATOMS","text":"","title":"IMPLICIT_ATOMS"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureFeatures.SITE_ATTACHMENTS","text":"","title":"SITE_ATTACHMENTS"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResource","text":"Representing a structure.","title":"StructureResource"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes","text":"This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions.","title":"StructureResourceAttributes"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.assemblies","text":"A description of groups of sites that are statistically correlated. Type : list of dictionary with keys: sites_in_groups : list of list of integers (REQUIRED) group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. The property SHOULD be null for entries that have no partial occupancies. If present, the correct flag MUST be set in the list structure_features . Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: [[1], [2]] : two groups, one with the second site, one with the third. Example: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the concentration of each species . If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: { \"cartesian_site_positions\" : [[ 0 , 0 , 0 ]], \"species_at_sites\" : [ \"SiGe-vac\" ], \"species\" : [ { \"name\" : \"SiGe-vac\" , \"chemical_symbols\" : [ \"Si\" , \"Ge\" , \"vacancy\" ], \"concentration\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } Using multiple species and the assemblies: { \"cartesian_site_positions\" : [ [ 0 , 0 , 0 ], [ 0 , 0 , 0 ], [ 0 , 0 , 0 ] ], \"species_at_sites\" : [ \"Si\" , \"Ge\" , \"vac\" ], \"species\" : [ { \"name\" : \"Si\" , \"chemical_symbols\" : [ \"Si\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"Ge\" , \"chemical_symbols\" : [ \"Ge\" ], \"concentration\" : [ 1.0 ] }, { \"name\" : \"vac\" , \"chemical_symbols\" : [ \"vacancy\" ], \"concentration\" : [ 1.0 ] } }, \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ], [ 2 ] ], \"group_probabilities\" : [ 0.3 , 0.5 , 0.2 ] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: { \"assemblies\" : [ { \"sites_in_groups\" : [ [ 0 ], [ 1 ] ], \"group_probabilities\" : [ 0.2 , 0.8 ], }, { \"sites_in_groups\" : [ [ 2 ], [ 3 ] ], \"group_probabilities\" : [ 0.3 , 0.7 ] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability).","title":"assemblies"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.cartesian_site_positions","text":"Cartesian positions of each site in the structure. A site is usually used to describe positions of atoms; what atoms can be encountered at a given site is conveyed by the species_at_sites property, and the species themselves are described in the species property. Type : list of list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length equal to the number of sites in the structure, where every element is a list of the three Cartesian coordinates of a site expressed as float values in the unit angstrom (\u00c5). An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies ). Examples : [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin.","title":"cartesian_site_positions"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_anonymous","text":"The anonymous formula is the chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : \"A2B\" \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is chemical_formula_anonymous=\"A2B\" .","title":"chemical_formula_anonymous"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_descriptive","text":"The chemical formula for a structure as a string in a form chosen by the API implementation. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry . Examples : \"(H2O)2 Na\" \"NaCl\" \"CaCO3\" \"CCaO3\" \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: chemical_formula_descriptive CONTAINS \"H2O\" .","title":"chemical_formula_descriptive"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_hill","text":"The chemical formula for a structure in Hill form with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be null . Query : Support for queries on this property is OPTIONAL. If supported, only a subset of the filter features MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, chemical_formula_hill is \"H2O2\" (i.e., not \"HO\" , nor \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in Hill order , followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : \"H2O2\" Query examples : A filter that matches an exactly given formula is chemical_formula_hill=\"H2O2\" .","title":"chemical_formula_hill"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_reduced","text":"The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. Type : string Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate queries on formula components are instead suggested to be formulated using set-type filter operators on the multi valued elements and elements_ratios properties. Element names MUST have proper capitalization (e.g., \"Si\" , not \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : \"H2NaO\" \"ClNa\" \"CCaO3\" Query examples : A filter that matches an exactly given formula is chemical_formula_reduced=\"H2NaO\" .","title":"chemical_formula_reduced"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.dimension_types","text":"List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ), this list indicates if the direction is periodic (value 1 ) or non-periodic (value 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in lattice_vectors and not the Cartesian x, y, z directions. Type : list of integers. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: [0, 0, 0] For a wire along the direction specified by the third lattice vector: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: [1, 0, 1] For a bulk 3D system: [1, 1, 1]","title":"dimension_types"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.elements","text":"Names of the different elements present in the structure. Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The strings are the chemical symbols, i.e., either a single uppercase letter or an uppercase letter followed by a number of lowercase letters. The order MUST be alphabetical. Note: This property SHOULD NOT contain the string \"X\" to indicate non-chemical elements or \"vacancy\" to indicate vacancies (in contrast to the field chemical_symbols for the species property). Examples : [\"Si\"] [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use elements HAS ALL \"Si\", \"Al\", \"O\" AND elements LENGTH 3 .","title":"elements"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.elements_ratios","text":"Relative proportions of different elements in the structure. Type : list of floats Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : [1.0] [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: Useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally inadvisable. OPTIONAL: a filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 .","title":"elements_ratios"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.lattice_vectors","text":"The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). Type : list of list of floats or unknown values. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. MUST always contain three vectors of three coordinates each, independently of the elements of property dimension_types . The vectors SHOULD by convention be chosen so the determinant of the lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. The coordinates of the lattice vectors of non-periodic dimensions (i.e., those dimensions for which dimension_types is 0 ) MAY be given as a list of all null values. If a lattice vector contains the value null , all coordinates of that lattice vector MUST be null . Examples : [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is (4, 0, 0) , i.e., a vector aligned along the x axis of length 4 \u00c5; the second vector is (0, 4, 0) ; and the third vector is (0, 1, 4) .","title":"lattice_vectors"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.nelements","text":"Number of different elements in the structure as an integer. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 3 Querying : Note: queries on this property can equivalently be formulated using elements LENGTH . A filter that matches structures that have exactly 4 elements: nelements=4 . A filter that matches structures that have between 2 and 7 elements: nelements>=2 AND nelements<=7 .","title":"nelements"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.nperiodic_dimensions","text":"An integer specifying the number of periodic dimensions in the structure, equivalent to the number of non-zero entries in dimension_types . Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. The integer value MUST be between 0 and 3 inclusive and MUST be equal to the sum of the items in the dimension_types property. This property only reflects the treatment of the lattice vectors provided for the structure, and not any physical interpretation of the dimensionality of its contents. Examples : 2 should be indicated in cases where dimension_types is any of [1, 1, 0] , [1, 0, 1] , [0, 1, 1] . Query examples : Match only structures with exactly 3 periodic dimensions: nperiodic_dimensions=3 Match all structures with 2 or fewer periodic dimensions: nperiodic_dimensions<=2","title":"nperiodic_dimensions"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.nsites","text":"An integer specifying the length of the cartesian_site_positions property. Type : integer Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : 42 Query examples : Match only structures with exactly 4 sites: nsites=4 Match structures that have between 2 and 7 sites: nsites>=2 AND nsites<=7","title":"nsites"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.species","text":"A list describing the species of the sites of this structure. Species can represent pure chemical elements, virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements, and/or a location to which there are attached atoms, i.e., atoms whose precise location are unknown beyond that they are attached to that position (frequently used to indicate hydrogen atoms attached to another element, e.g., a carbon with three attached hydrogens might represent a methyl group, -CH3). Type : list of dictionary with keys: name : string (REQUIRED) chemical_symbols : list of strings (REQUIRED) concentration : list of float (REQUIRED) attached : list of strings (REQUIRED) nattached : list of integers (OPTIONAL) mass : list of floats (OPTIONAL) original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. Each item of the list MUST be one of the following: a valid chemical-element name, or the special value \"X\" to represent a non-chemical element, or the special value \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the concentration list, see below). If any one entry in the species list has a chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list structure_features . concentration : REQUIRED; MUST be a list of floats, with same length as chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations 1/3 and 2/3 , the concentration might look something like [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different sites (even of the same species). attached : OPTIONAL; if provided MUST be a list of length 1 or more of strings of chemical symbols for the elements attached to this site, or \"X\" for a non-chemical element. nattached : OPTIONAL; if provided MUST be a list of length 1 or more of integers indicating the number of attached atoms of the kind specified in the value of the attached key. The implementation MUST include either both or none of the attached and nattached keys, and if they are provided, they MUST be of the same length. Furthermore, if they are provided, the structure_features property MUST include the string site_attachments . mass : OPTIONAL. If present MUST be a list of floats, with the same length as chemical_symbols , providing element masses expressed in a.m.u. Elements denoting vacancies MUST have masses equal to 0. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites ). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., \"Ti\" for titanium, \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": [0.0, 137.327, 40.078]} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [12.0]} ] : any site with this species is occupied by a carbon isotope with mass 12. [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": [13.0]} ] : any site with this species is occupied by a carbon isotope with mass 13. [ {\"name\": \"CH3\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"attached\": [\"H\"], \"nattached\": [3]} ] : any site with this species is occupied by a methyl group, -CH3, which is represented without specifying precise positions of the hydrogen atoms.","title":"species"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.species_at_sites","text":"Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . Type : list of strings. Requirements/Conventions : Support : SHOULD be supported by all implementations, i.e., SHOULD NOT be null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions ). Each species name mentioned in the species_at_sites list MUST be described in the list property species (i.e. for each value in the species_at_sites list there MUST exist exactly one dictionary in the species list with the name attribute equal to the corresponding species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled \"Ti\" and the second a species labeled \"O2\" . [\"Ac\", \"Ac\", \"Ag\", \"Ir\"] indicating the first two sites contains the \"Ac\" species, while the third and fourth sites contain the \"Ag\" and \"Ir\" species, respectively.","title":"species_at_sites"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.structure_features","text":"A list of strings that flag which special features are used by the structure. Type : list of strings Requirements/Conventions : Support : MUST be supported by all implementations, MUST NOT be null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : disorder : this flag MUST be present if any one entry in the species list has a chemical_symbols list that is longer than 1 element. implicit_atoms : this flag MUST be present if the structure contains atoms that are not assigned to sites via the property species_at_sites (e.g., because their positions are unknown). When this flag is present, the properties related to the chemical formula will likely not match the type and count of atoms represented by the species_at_sites , species and assemblies properties. site_attachments : this flag MUST be present if any one entry in the species list includes attached and nattached . assemblies : this flag MUST be present if the property assemblies is present. Examples : A structure having implicit atoms and using assemblies: [\"assemblies\", \"implicit_atoms\"]","title":"structure_features"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.Config","text":"","title":"Config"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.Config.schema_extra","text":"Two things need to be added to the schema: Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, dimension_types and lattice_vectors , are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be nullable according to the OpenAPI definition. Source code in optimade/models/structures.py def schema_extra ( schema , model ): \"\"\"Two things need to be added to the schema: 1. Constrained types in pydantic do not currently play nicely with \"Required Optional\" fields, i.e. fields must be specified but can be null. The two contrained list fields, `dimension_types` and `lattice_vectors`, are OPTIMADE 'SHOULD' fields, which means that they are allowed to be null. 2. All OPTIMADE 'SHOULD' fields are allowed to be null, so we manually set them to be `nullable` according to the OpenAPI definition. \"\"\" schema [ \"required\" ] . insert ( 7 , \"dimension_types\" ) schema [ \"required\" ] . insert ( 9 , \"lattice_vectors\" ) nullable_props = ( prop for prop in schema [ \"required\" ] if schema [ \"properties\" ][ prop ] . get ( \"support\" ) == SupportLevel . SHOULD ) for prop in nullable_props : schema [ \"properties\" ][ prop ][ \"nullable\" ] = True","title":"schema_extra()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.check_anonymous_formula","text":"Source code in optimade/models/structures.py @validator ( \"chemical_formula_anonymous\" ) def check_anonymous_formula ( cls , v ): if v is None : return v elements = tuple ( re . findall ( r \"[A-Z][a-z]*\" , v )) numbers = [ int ( n . strip ()) for n in re . split ( r \"[A-Z][a-z]*\" , v ) if n . strip ()] if any ( n == 1 for n in numbers ): raise ValueError ( f \"'chemical_formula_anonymous' { v } must omit proportion '1'\" ) expected_labels = ANONYMOUS_ELEMENTS [: len ( elements )] expected_numbers = sorted ( numbers , reverse = True ) if expected_numbers != numbers : raise ValueError ( f \"'chemical_formula_anonymous' { v } has wrong order: elements with highest proportion should appear first: { numbers } vs expected { expected_numbers } \" ) if elements != expected_labels : raise ValueError ( f \"'chemical_formula_anonymous' { v } has wrong labels: { elements } vs expected { expected_labels } .\" ) return v","title":"check_anonymous_formula()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.check_ordered_formula","text":"Source code in optimade/models/structures.py @validator ( \"chemical_formula_reduced\" , \"chemical_formula_hill\" ) def check_ordered_formula ( cls , v , field ): if v is None : return v numbers = re . findall ( r \"(\\d+\\.?)+\" , v ) elements = re . findall ( r \"[A-Z][a-z]?\" , v ) expected_elements = sorted ( elements ) if field . name == \"chemical_formula_hill\" : # Make sure C is first (and H is second, if present along with C). if \"C\" in expected_elements : expected_elements = sorted ( expected_elements , key = lambda elem : { \"C\" : \"0\" , \"H\" : \"1\" } . get ( elem , elem ), ) if any ( elem not in CHEMICAL_SYMBOLS for elem in elements ): raise ValueError ( f \"Cannot use unknown chemical symbols { [ elem for elem in elements if elem not in CHEMICAL_SYMBOLS ] } in { field . name !r} \" ) if \"1\" in numbers : raise ValueError ( f \"Must omit proportion '1' from formula { v } in { field . name !r} \" ) if expected_elements != elements : order = \"Hill\" if field . name == \"chemical_formula_hill\" else \"alphabetical\" raise ValueError ( f \"Elements in { field . name !r} must appear in { order } order: { expected_elements } not { elements } .\" ) return v","title":"check_ordered_formula()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.check_periodic_dimensions","text":"Source code in optimade/models/structures.py @validator ( \"nperiodic_dimensions\" ) def check_periodic_dimensions ( cls , v , values ): if v is None : return v if values . get ( \"dimension_types\" ) and v != sum ( values . get ( \"dimension_types\" )): raise ValueError ( f \"nperiodic_dimensions ( { v } ) does not match expected value of { sum ( values [ 'dimension_types' ]) } \" f \"from dimension_types ( { values [ 'dimension_types' ] } )\" ) return v","title":"check_periodic_dimensions()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.element_must_be_chemical_symbol","text":"Source code in optimade/models/structures.py @validator ( \"elements\" , each_item = True ) def element_must_be_chemical_symbol ( cls , v ): if v not in CHEMICAL_SYMBOLS : raise ValueError ( f \"Only chemical symbols are allowed, you passed: { v } \" ) return v","title":"element_must_be_chemical_symbol()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.elements_must_be_alphabetical","text":"Source code in optimade/models/structures.py @validator ( \"elements\" ) def elements_must_be_alphabetical ( cls , v ): if v is None : return v if sorted ( v ) != v : raise ValueError ( f \"elements must be sorted alphabetically, but is: { v } \" ) return v","title":"elements_must_be_alphabetical()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.null_values_for_whole_vector","text":"Source code in optimade/models/structures.py @validator ( \"lattice_vectors\" ) def null_values_for_whole_vector ( cls , v ): if v is None : return v for vector in v : if None in vector and any (( isinstance ( _ , float ) for _ in vector )): raise ValueError ( f \"A lattice vector MUST be either all `null` or all numbers (vector: { vector } , all vectors: { v } )\" ) return v","title":"null_values_for_whole_vector()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.ratios_must_sum_to_one","text":"Source code in optimade/models/structures.py @validator ( \"elements_ratios\" ) def ratios_must_sum_to_one ( cls , v ): if v is None : return v if abs ( sum ( v ) - 1 ) > EPS : raise ValueError ( f \"elements_ratios MUST sum to 1 within floating point accuracy. It sums to: { sum ( v ) } \" ) return v","title":"ratios_must_sum_to_one()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.required_if_dimension_types_has_one","text":"Source code in optimade/models/structures.py @validator ( \"lattice_vectors\" , always = True ) def required_if_dimension_types_has_one ( cls , v , values ): if v is None : return v if values . get ( \"dimension_types\" ): for dim_type , vector in zip ( values . get ( \"dimension_types\" , ( None ,) * 3 ), v ): if None in vector and dim_type == Periodicity . PERIODIC . value : raise ValueError ( f \"Null entries in lattice vectors are only permitted when the corresponding dimension type is { Periodicity . APERIODIC . value } . \" f \"Here: dimension_types = { tuple ( getattr ( _ , 'value' , None ) for _ in values . get ( 'dimension_types' , [])) } , lattice_vectors = { v } \" ) return v","title":"required_if_dimension_types_has_one()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.validate_nsites","text":"Source code in optimade/models/structures.py @validator ( \"nsites\" ) def validate_nsites ( cls , v , values ): if v is None : return v if values . get ( \"cartesian_site_positions\" ) and v != len ( values . get ( \"cartesian_site_positions\" , []) ): raise ValueError ( f \"nsites (value: { v } ) MUST equal length of cartesian_site_positions \" f \"(value: { len ( values . get ( 'cartesian_site_positions' , [])) } )\" ) return v","title":"validate_nsites()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.validate_species","text":"Source code in optimade/models/structures.py @validator ( \"species\" ) def validate_species ( cls , v ): if v is None : return v all_species = [ _ . name for _ in v ] unique_species = set ( all_species ) if len ( all_species ) != len ( unique_species ): raise ValueError ( f \"Species MUST be unique based on their 'name'. Found species names: { all_species } \" ) return v","title":"validate_species()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.validate_species_at_sites","text":"Source code in optimade/models/structures.py @validator ( \"species_at_sites\" ) def validate_species_at_sites ( cls , v , values ): if v is None : return v if values . get ( \"nsites\" ) and len ( v ) != values . get ( \"nsites\" ): raise ValueError ( f \"Number of species_at_sites (value: { len ( v ) } ) MUST equal number of sites \" f \"(value: { values . get ( 'nsites' , 'Not specified' ) } )\" ) if values . get ( \"species\" ): all_species_names = { getattr ( _ , \"name\" , None ) for _ in values . get ( \"species\" , [{}]) } all_species_names -= { None } for value in v : if value not in all_species_names : raise ValueError ( \"species_at_sites MUST be represented by a species' name, \" f \"but { value } was not found in the list of species names: { all_species_names } \" ) return v","title":"validate_species_at_sites()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.validate_structure_features","text":"Source code in optimade/models/structures.py @validator ( \"structure_features\" , always = True ) def validate_structure_features ( cls , v , values ): if [ StructureFeatures ( value ) for value in sorted (( _ . value for _ in v ))] != v : raise ValueError ( f \"structure_features MUST be sorted alphabetically, given value: { v } \" ) # assemblies if values . get ( \"assemblies\" ) is not None : if StructureFeatures . ASSEMBLIES not in v : raise ValueError ( f \" { StructureFeatures . ASSEMBLIES . value } MUST be present, since the property of the same name is present\" ) elif StructureFeatures . ASSEMBLIES in v : raise ValueError ( f \" { StructureFeatures . ASSEMBLIES . value } MUST NOT be present, \" \"since the property of the same name is not present\" ) if values . get ( \"species\" ): # disorder for species in values . get ( \"species\" , []): if len ( species . chemical_symbols ) > 1 : if StructureFeatures . DISORDER not in v : raise ValueError ( f \" { StructureFeatures . DISORDER . value } MUST be present when any one entry in species \" \"has a chemical_symbols list greater than one element\" ) break else : if StructureFeatures . DISORDER in v : raise ValueError ( f \" { StructureFeatures . DISORDER . value } MUST NOT be present, since all species' chemical_symbols \" \"lists are equal to or less than one element\" ) # site_attachments for species in values . get ( \"species\" , []): # There is no need to also test \"nattached\", # since a Species validator makes sure either both are present or both are None. if getattr ( species , \"attached\" , None ) is not None : if StructureFeatures . SITE_ATTACHMENTS not in v : raise ValueError ( f \" { StructureFeatures . SITE_ATTACHMENTS . value } MUST be present when any one entry \" \"in species includes attached and nattached\" ) break else : if StructureFeatures . SITE_ATTACHMENTS in v : raise ValueError ( f \" { StructureFeatures . SITE_ATTACHMENTS . value } MUST NOT be present, since no species includes \" \"the attached and nattached fields\" ) # implicit_atoms species_names = [ _ . name for _ in values . get ( \"species\" , [])] for name in species_names : if values . get ( \"species_at_sites\" ) is not None and name not in values . get ( \"species_at_sites\" , []): if StructureFeatures . IMPLICIT_ATOMS not in v : raise ValueError ( f \" { StructureFeatures . IMPLICIT_ATOMS . value } MUST be present when any one entry in species \" \"is not represented in species_at_sites\" ) break else : if StructureFeatures . IMPLICIT_ATOMS in v : raise ValueError ( f \" { StructureFeatures . IMPLICIT_ATOMS . value } MUST NOT be present, since all species are \" \"represented in species_at_sites\" ) return v","title":"validate_structure_features()"},{"location":"api_reference/models/structures/#optimade.models.structures.StructureResourceAttributes.warn_on_missing_correlated_fields","text":"Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. Source code in optimade/models/structures.py @root_validator ( pre = True ) def warn_on_missing_correlated_fields ( cls , values ): \"\"\"Emit warnings if a field takes a null value when a value was expected based on the value/nullity of another field. \"\"\" accumulated_warnings = [] for field_set in CORRELATED_STRUCTURE_FIELDS : missing_fields = { f for f in field_set if values . get ( f ) is None } if missing_fields and len ( missing_fields ) != len ( field_set ): accumulated_warnings += [ f \"Structure with values { values } is missing fields { missing_fields } which are required if { field_set - missing_fields } are present.\" ] for warn in accumulated_warnings : warnings . warn ( warn , MissingExpectedField ) return values","title":"warn_on_missing_correlated_fields()"},{"location":"api_reference/models/utils/","text":"utils \u00b6 ANONYMOUS_ELEMENTS \u00b6 Returns the first 150 values of the anonymous element generator. ATOMIC_NUMBERS \u00b6 CHEMICAL_FORMULA_REGEXP \u00b6 CHEMICAL_SYMBOLS \u00b6 EXTRA_SYMBOLS \u00b6 SemanticVersion ( str ) \u00b6 A custom type for a semantic version, using the recommended semver regexp from https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string. base_version : str property readonly \u00b6 The base version string without patch and metadata info. build_metadata : str property readonly \u00b6 The build metadata. major : int property readonly \u00b6 The major version number. minor : int property readonly \u00b6 The minor version number. patch : int property readonly \u00b6 The patch version number. prerelease : str property readonly \u00b6 The pre-release tag. regex \u00b6 __get_validators__ () classmethod special \u00b6 Source code in optimade/models/utils.py @classmethod def __get_validators__ ( cls ): yield cls . validate __modify_schema__ ( field_schema ) classmethod special \u00b6 Source code in optimade/models/utils.py @classmethod def __modify_schema__ ( cls , field_schema ): field_schema . update ( pattern = cls . regex . pattern , examples = [ \"0.10.1\" , \"1.0.0-rc.2\" , \"1.2.3-rc.5+develop\" ], ) validate ( v ) classmethod \u00b6 Source code in optimade/models/utils.py @classmethod def validate ( cls , v : str ): if not cls . regex . match ( v ): raise ValueError ( f \"Unable to validate version { v } as a semver.\" ) return v SupportLevel ( Enum ) \u00b6 OPTIMADE property/field support levels MUST \u00b6 OPTIONAL \u00b6 SHOULD \u00b6 OptimadeField ( * args , * , support = None , queryable = None , unit = None , ** kwargs ) \u00b6 A wrapper around pydantic.Field that adds OPTIMADE-specific field paramters queryable , support and unit , indicating the corresponding support level in the specification and the physical unit of the field. Parameters: Name Type Description Default support Optional[optimade.models.utils.SupportLevel] The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. None queryable Optional[optimade.models.utils.SupportLevel] The support level corresponding to the queryablility of this field. None unit Optional[str] A string describing the unit of the field. None Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic field with extra validation provided by StrictField . Source code in optimade/models/utils.py def OptimadeField ( * args , support : Optional [ SupportLevel ] = None , queryable : Optional [ SupportLevel ] = None , unit : Optional [ str ] = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that adds OPTIMADE-specific field paramters `queryable`, `support` and `unit`, indicating the corresponding support level in the specification and the physical unit of the field. Arguments: support: The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. queryable: The support level corresponding to the queryablility of this field. unit: A string describing the unit of the field. Returns: The pydantic field with extra validation provided by [`StrictField`][optimade.models.utils.StrictField]. \"\"\" # Collect non-null keyword arguments to add to the Field schema if unit is not None : kwargs [ \"unit\" ] = unit if queryable is not None : if isinstance ( queryable , str ): queryable = SupportLevel ( queryable . lower ()) kwargs [ \"queryable\" ] = queryable if support is not None : if isinstance ( support , str ): support = SupportLevel ( support . lower ()) kwargs [ \"support\" ] = support return StrictField ( * args , ** kwargs ) StrictField ( * args , * , description = None , ** kwargs ) \u00b6 A wrapper around pydantic.Field that does the following: Forbids any \"extra\" keys that would be passed to pydantic.Field , except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". Emits a warning when no description is provided. Parameters: Name Type Description Default *args Positional arguments passed through to Field . () description str The description of the Field ; if this is not specified then a UserWarning will be emitted. None **kwargs Extra keyword arguments to be passed to Field . {} Exceptions: Type Description RuntimeError If **kwargs contains a key not found in the function signature of Field , or in the extensions used by models in this package (see above). Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic Field . Source code in optimade/models/utils.py def StrictField ( * args , description : str = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that does the following: - Forbids any \"extra\" keys that would be passed to `pydantic.Field`, except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". - Emits a warning when no description is provided. Arguments: *args: Positional arguments passed through to `Field`. description: The description of the `Field`; if this is not specified then a `UserWarning` will be emitted. **kwargs: Extra keyword arguments to be passed to `Field`. Raises: RuntimeError: If `**kwargs` contains a key not found in the function signature of `Field`, or in the extensions used by models in this package (see above). Returns: The pydantic `Field`. \"\"\" allowed_keys = [ \"unit\" , \"pattern\" , \"uniqueItems\" , \"support\" , \"queryable\" , \"sortable\" , ] _banned = [ k for k in kwargs if k not in set ( _PYDANTIC_FIELD_KWARGS + allowed_keys )] if _banned : raise RuntimeError ( f \"Not creating StrictField( { args } , { kwargs } ) with forbidden keywords { _banned } .\" ) if description is not None : kwargs [ \"description\" ] = description if description is None : warnings . warn ( f \"No description provided for StrictField specified by { args } , { kwargs } .\" ) return Field ( * args , ** kwargs ) anonymous_element_generator () \u00b6 Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. Source code in optimade/models/utils.py def anonymous_element_generator (): \"\"\" Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. \"\"\" from string import ascii_lowercase for size in itertools . count ( 1 ): for s in itertools . product ( ascii_lowercase , repeat = size ): s = list ( s ) s [ 0 ] = s [ 0 ] . upper () yield \"\" . join ( s )","title":"utils"},{"location":"api_reference/models/utils/#utils","text":"","title":"utils"},{"location":"api_reference/models/utils/#optimade.models.utils.ANONYMOUS_ELEMENTS","text":"Returns the first 150 values of the anonymous element generator.","title":"ANONYMOUS_ELEMENTS"},{"location":"api_reference/models/utils/#optimade.models.utils.ATOMIC_NUMBERS","text":"","title":"ATOMIC_NUMBERS"},{"location":"api_reference/models/utils/#optimade.models.utils.CHEMICAL_FORMULA_REGEXP","text":"","title":"CHEMICAL_FORMULA_REGEXP"},{"location":"api_reference/models/utils/#optimade.models.utils.CHEMICAL_SYMBOLS","text":"","title":"CHEMICAL_SYMBOLS"},{"location":"api_reference/models/utils/#optimade.models.utils.EXTRA_SYMBOLS","text":"","title":"EXTRA_SYMBOLS"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion","text":"A custom type for a semantic version, using the recommended semver regexp from https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string.","title":"SemanticVersion"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.base_version","text":"The base version string without patch and metadata info.","title":"base_version"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.build_metadata","text":"The build metadata.","title":"build_metadata"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.major","text":"The major version number.","title":"major"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.minor","text":"The minor version number.","title":"minor"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.patch","text":"The patch version number.","title":"patch"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.prerelease","text":"The pre-release tag.","title":"prerelease"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.regex","text":"","title":"regex"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.__get_validators__","text":"Source code in optimade/models/utils.py @classmethod def __get_validators__ ( cls ): yield cls . validate","title":"__get_validators__()"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.__modify_schema__","text":"Source code in optimade/models/utils.py @classmethod def __modify_schema__ ( cls , field_schema ): field_schema . update ( pattern = cls . regex . pattern , examples = [ \"0.10.1\" , \"1.0.0-rc.2\" , \"1.2.3-rc.5+develop\" ], )","title":"__modify_schema__()"},{"location":"api_reference/models/utils/#optimade.models.utils.SemanticVersion.validate","text":"Source code in optimade/models/utils.py @classmethod def validate ( cls , v : str ): if not cls . regex . match ( v ): raise ValueError ( f \"Unable to validate version { v } as a semver.\" ) return v","title":"validate()"},{"location":"api_reference/models/utils/#optimade.models.utils.SupportLevel","text":"OPTIMADE property/field support levels","title":"SupportLevel"},{"location":"api_reference/models/utils/#optimade.models.utils.SupportLevel.MUST","text":"","title":"MUST"},{"location":"api_reference/models/utils/#optimade.models.utils.SupportLevel.OPTIONAL","text":"","title":"OPTIONAL"},{"location":"api_reference/models/utils/#optimade.models.utils.SupportLevel.SHOULD","text":"","title":"SHOULD"},{"location":"api_reference/models/utils/#optimade.models.utils.OptimadeField","text":"A wrapper around pydantic.Field that adds OPTIMADE-specific field paramters queryable , support and unit , indicating the corresponding support level in the specification and the physical unit of the field. Parameters: Name Type Description Default support Optional[optimade.models.utils.SupportLevel] The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. None queryable Optional[optimade.models.utils.SupportLevel] The support level corresponding to the queryablility of this field. None unit Optional[str] A string describing the unit of the field. None Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic field with extra validation provided by StrictField . Source code in optimade/models/utils.py def OptimadeField ( * args , support : Optional [ SupportLevel ] = None , queryable : Optional [ SupportLevel ] = None , unit : Optional [ str ] = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that adds OPTIMADE-specific field paramters `queryable`, `support` and `unit`, indicating the corresponding support level in the specification and the physical unit of the field. Arguments: support: The support level of the field itself, i.e. whether the field can be null or omitted by an implementation. queryable: The support level corresponding to the queryablility of this field. unit: A string describing the unit of the field. Returns: The pydantic field with extra validation provided by [`StrictField`][optimade.models.utils.StrictField]. \"\"\" # Collect non-null keyword arguments to add to the Field schema if unit is not None : kwargs [ \"unit\" ] = unit if queryable is not None : if isinstance ( queryable , str ): queryable = SupportLevel ( queryable . lower ()) kwargs [ \"queryable\" ] = queryable if support is not None : if isinstance ( support , str ): support = SupportLevel ( support . lower ()) kwargs [ \"support\" ] = support return StrictField ( * args , ** kwargs )","title":"OptimadeField()"},{"location":"api_reference/models/utils/#optimade.models.utils.StrictField","text":"A wrapper around pydantic.Field that does the following: Forbids any \"extra\" keys that would be passed to pydantic.Field , except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". Emits a warning when no description is provided. Parameters: Name Type Description Default *args Positional arguments passed through to Field . () description str The description of the Field ; if this is not specified then a UserWarning will be emitted. None **kwargs Extra keyword arguments to be passed to Field . {} Exceptions: Type Description RuntimeError If **kwargs contains a key not found in the function signature of Field , or in the extensions used by models in this package (see above). Returns: Type Description <cyfunction Field at 0x7f3a75cd7790> The pydantic Field . Source code in optimade/models/utils.py def StrictField ( * args , description : str = None , ** kwargs , ) -> Field : \"\"\"A wrapper around `pydantic.Field` that does the following: - Forbids any \"extra\" keys that would be passed to `pydantic.Field`, except those used elsewhere to modify the schema in-place, e.g. \"uniqueItems\", \"pattern\" and those added by OptimadeField, e.g. \"unit\", \"queryable\" and \"sortable\". - Emits a warning when no description is provided. Arguments: *args: Positional arguments passed through to `Field`. description: The description of the `Field`; if this is not specified then a `UserWarning` will be emitted. **kwargs: Extra keyword arguments to be passed to `Field`. Raises: RuntimeError: If `**kwargs` contains a key not found in the function signature of `Field`, or in the extensions used by models in this package (see above). Returns: The pydantic `Field`. \"\"\" allowed_keys = [ \"unit\" , \"pattern\" , \"uniqueItems\" , \"support\" , \"queryable\" , \"sortable\" , ] _banned = [ k for k in kwargs if k not in set ( _PYDANTIC_FIELD_KWARGS + allowed_keys )] if _banned : raise RuntimeError ( f \"Not creating StrictField( { args } , { kwargs } ) with forbidden keywords { _banned } .\" ) if description is not None : kwargs [ \"description\" ] = description if description is None : warnings . warn ( f \"No description provided for StrictField specified by { args } , { kwargs } .\" ) return Field ( * args , ** kwargs )","title":"StrictField()"},{"location":"api_reference/models/utils/#optimade.models.utils.anonymous_element_generator","text":"Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. Source code in optimade/models/utils.py def anonymous_element_generator (): \"\"\" Generator that yields the next symbol in the A, B, Aa, ... Az naming scheme. \"\"\" from string import ascii_lowercase for size in itertools . count ( 1 ): for s in itertools . product ( ascii_lowercase , repeat = size ): s = list ( s ) s [ 0 ] = s [ 0 ] . upper () yield \"\" . join ( s )","title":"anonymous_element_generator()"},{"location":"api_reference/server/config/","text":"config \u00b6 LogLevel ( Enum ) \u00b6 Replication of logging LogLevels ServerConfig ( BaseSettings ) pydantic-model \u00b6 This class stores server config parameters in a way that can be easily extended for new config file types. aliases : Dict [ Literal [ 'links' , 'references' , 'structures' ], Dict [ str , str ]] pydantic-field \u00b6 A mapping between field names in the database with their corresponding OPTIMADE field names, broken down by endpoint. base_url : str pydantic-field \u00b6 Base URL for this implementation config_file : str pydantic-field \u00b6 File to load alternative defaults from debug : bool pydantic-field \u00b6 Turns on Debug Mode for the OPTIMADE Server implementation default_db : str pydantic-field \u00b6 ID of /links endpoint resource for the chosen default OPTIMADE implementation (only relevant for the index meta-database) implementation : Implementation pydantic-field \u00b6 Introspective information about this OPTIMADE implementation index_base_url : AnyHttpUrl pydantic-field \u00b6 An optional link to the base URL for the index meta-database of the provider. index_links_path : Path pydantic-field \u00b6 Absolute path to a JSON file containing the MongoDB collection of /links resources for the index meta-database length_aliases : Dict [ Literal [ 'links' , 'references' , 'structures' ], Dict [ str , str ]] pydantic-field \u00b6 A mapping between a list property (or otherwise) and an integer property that defines the length of that list, for example elements -> nelements. The standard aliases are applied first, so this dictionary must refer to the API fields, not the database fields. links_collection : str pydantic-field \u00b6 Mongo collection name for /links endpoint resources log_dir : Path pydantic-field \u00b6 Folder in which log files will be saved. log_level : LogLevel pydantic-field \u00b6 Logging level for the OPTIMADE server. mongo_database : str pydantic-field \u00b6 Mongo database for collection data mongo_uri : str pydantic-field \u00b6 URI for the Mongo server page_limit : int pydantic-field \u00b6 Default number of resources per page page_limit_max : int pydantic-field \u00b6 Max allowed number of resources per page provider : Provider pydantic-field \u00b6 General information about the provider of this OPTIMADE implementation provider_fields : Dict [ Literal [ 'links' , 'references' , 'structures' ], List [ str ]] pydantic-field \u00b6 A list of additional fields to be served with the provider's prefix attached, broken down by endpoint. references_collection : str pydantic-field \u00b6 Mongo collection name for /references endpoint resources root_path : str pydantic-field \u00b6 Sets the FastAPI app root_path parameter. This can be used to serve the API under a path prefix behind a proxy or as a sub-application of another FastAPI app. See https://fastapi.tiangolo.com/advanced/sub-applications/#technical-details-root_path for details. structures_collection : str pydantic-field \u00b6 Mongo collection name for /structures endpoint resources use_real_mongo : bool pydantic-field \u00b6 Use a real Mongo server rather than MongoMock Config \u00b6 This is a pydantic model Config object that modifies the behaviour of ServerConfig by adding a prefix to the environment variables that override config file values. It has nothing to do with the OPTIMADE config. load_settings ( values ) classmethod \u00b6 Loads settings from a JSON config file, if available, and uses them in place of the built-in defaults. Source code in optimade/server/config.py @root_validator ( pre = True ) def load_settings ( cls , values ): \"\"\" Loads settings from a JSON config file, if available, and uses them in place of the built-in defaults. \"\"\" config_file_path = Path ( values . get ( \"config_file\" , DEFAULT_CONFIG_FILE_PATH )) new_values = {} if config_file_path . is_file (): try : with open ( config_file_path ) as f : new_values = json . load ( f ) except json . JSONDecodeError as exc : warnings . warn ( f \"Unable to parse config file { config_file_path } as JSON. Error: { exc } .\" ) else : if DEFAULT_CONFIG_FILE_PATH != str ( config_file_path ): warnings . warn ( f \"Unable to find config file in requested location { config_file_path } , \" \"using the built-in default settings instead.\" ) else : warnings . warn ( f \"Unable to find config file in default location { DEFAULT_CONFIG_FILE_PATH } , \" \"using the built-in default settings instead.\" ) if not new_values : values [ \"config_file\" ] = None new_values . update ( values ) return new_values set_implementation_version ( v ) classmethod \u00b6 Set defaults and modify bypassed value(s) Source code in optimade/server/config.py @validator ( \"implementation\" , pre = True ) def set_implementation_version ( cls , v ): \"\"\"Set defaults and modify bypassed value(s)\"\"\" res = { \"version\" : __version__ } res . update ( v ) return res","title":"config"},{"location":"api_reference/server/config/#config","text":"","title":"config"},{"location":"api_reference/server/config/#optimade.server.config.LogLevel","text":"Replication of logging LogLevels","title":"LogLevel"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig","text":"This class stores server config parameters in a way that can be easily extended for new config file types.","title":"ServerConfig"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.aliases","text":"A mapping between field names in the database with their corresponding OPTIMADE field names, broken down by endpoint.","title":"aliases"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.base_url","text":"Base URL for this implementation","title":"base_url"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.config_file","text":"File to load alternative defaults from","title":"config_file"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.debug","text":"Turns on Debug Mode for the OPTIMADE Server implementation","title":"debug"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.default_db","text":"ID of /links endpoint resource for the chosen default OPTIMADE implementation (only relevant for the index meta-database)","title":"default_db"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.implementation","text":"Introspective information about this OPTIMADE implementation","title":"implementation"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.index_base_url","text":"An optional link to the base URL for the index meta-database of the provider.","title":"index_base_url"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.index_links_path","text":"Absolute path to a JSON file containing the MongoDB collection of /links resources for the index meta-database","title":"index_links_path"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.length_aliases","text":"A mapping between a list property (or otherwise) and an integer property that defines the length of that list, for example elements -> nelements. The standard aliases are applied first, so this dictionary must refer to the API fields, not the database fields.","title":"length_aliases"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.links_collection","text":"Mongo collection name for /links endpoint resources","title":"links_collection"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.log_dir","text":"Folder in which log files will be saved.","title":"log_dir"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.log_level","text":"Logging level for the OPTIMADE server.","title":"log_level"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.mongo_database","text":"Mongo database for collection data","title":"mongo_database"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.mongo_uri","text":"URI for the Mongo server","title":"mongo_uri"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.page_limit","text":"Default number of resources per page","title":"page_limit"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.page_limit_max","text":"Max allowed number of resources per page","title":"page_limit_max"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.provider","text":"General information about the provider of this OPTIMADE implementation","title":"provider"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.provider_fields","text":"A list of additional fields to be served with the provider's prefix attached, broken down by endpoint.","title":"provider_fields"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.references_collection","text":"Mongo collection name for /references endpoint resources","title":"references_collection"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.root_path","text":"Sets the FastAPI app root_path parameter. This can be used to serve the API under a path prefix behind a proxy or as a sub-application of another FastAPI app. See https://fastapi.tiangolo.com/advanced/sub-applications/#technical-details-root_path for details.","title":"root_path"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.structures_collection","text":"Mongo collection name for /structures endpoint resources","title":"structures_collection"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.use_real_mongo","text":"Use a real Mongo server rather than MongoMock","title":"use_real_mongo"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.Config","text":"This is a pydantic model Config object that modifies the behaviour of ServerConfig by adding a prefix to the environment variables that override config file values. It has nothing to do with the OPTIMADE config.","title":"Config"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.load_settings","text":"Loads settings from a JSON config file, if available, and uses them in place of the built-in defaults. Source code in optimade/server/config.py @root_validator ( pre = True ) def load_settings ( cls , values ): \"\"\" Loads settings from a JSON config file, if available, and uses them in place of the built-in defaults. \"\"\" config_file_path = Path ( values . get ( \"config_file\" , DEFAULT_CONFIG_FILE_PATH )) new_values = {} if config_file_path . is_file (): try : with open ( config_file_path ) as f : new_values = json . load ( f ) except json . JSONDecodeError as exc : warnings . warn ( f \"Unable to parse config file { config_file_path } as JSON. Error: { exc } .\" ) else : if DEFAULT_CONFIG_FILE_PATH != str ( config_file_path ): warnings . warn ( f \"Unable to find config file in requested location { config_file_path } , \" \"using the built-in default settings instead.\" ) else : warnings . warn ( f \"Unable to find config file in default location { DEFAULT_CONFIG_FILE_PATH } , \" \"using the built-in default settings instead.\" ) if not new_values : values [ \"config_file\" ] = None new_values . update ( values ) return new_values","title":"load_settings()"},{"location":"api_reference/server/config/#optimade.server.config.ServerConfig.set_implementation_version","text":"Set defaults and modify bypassed value(s) Source code in optimade/server/config.py @validator ( \"implementation\" , pre = True ) def set_implementation_version ( cls , v ): \"\"\"Set defaults and modify bypassed value(s)\"\"\" res = { \"version\" : __version__ } res . update ( v ) return res","title":"set_implementation_version()"},{"location":"api_reference/server/exception_handlers/","text":"exception_handlers \u00b6 OPTIMADE_EXCEPTIONS : Tuple [ Exception , Callable [[ starlette . requests . Request , Exception ], starlette . responses . JSONResponse ]] \u00b6 A tuple of all pairs of exceptions and handler functions that allow for appropriate responses to be returned in certain scenarios according to the OPTIMADE specification. To use these in FastAPI app code: from fastapi import FastAPI app = FastAPI () for exception , handler in OPTIMADE_EXCEPTIONS : app . add_exception_handler ( exception , handler )","title":"exception_handlers"},{"location":"api_reference/server/exception_handlers/#exception_handlers","text":"","title":"exception_handlers"},{"location":"api_reference/server/exception_handlers/#optimade.server.exception_handlers.OPTIMADE_EXCEPTIONS","text":"A tuple of all pairs of exceptions and handler functions that allow for appropriate responses to be returned in certain scenarios according to the OPTIMADE specification. To use these in FastAPI app code: from fastapi import FastAPI app = FastAPI () for exception , handler in OPTIMADE_EXCEPTIONS : app . add_exception_handler ( exception , handler )","title":"OPTIMADE_EXCEPTIONS"},{"location":"api_reference/server/exceptions/","text":"exceptions \u00b6 BadRequest ( StrReprMixin , HTTPException ) \u00b6 400 Bad Request Forbidden ( StrReprMixin , HTTPException ) \u00b6 403 Forbidden StrReprMixin ( HTTPException ) \u00b6 This mixin can be useful when testing requires a string representation of an exception that contains the HTTPException detail string, rather than the standard Python exception message. VersionNotSupported ( StrReprMixin , HTTPException ) \u00b6 553 Version Not Supported","title":"exceptions"},{"location":"api_reference/server/exceptions/#exceptions","text":"","title":"exceptions"},{"location":"api_reference/server/exceptions/#optimade.server.exceptions.BadRequest","text":"400 Bad Request","title":"BadRequest"},{"location":"api_reference/server/exceptions/#optimade.server.exceptions.Forbidden","text":"403 Forbidden","title":"Forbidden"},{"location":"api_reference/server/exceptions/#optimade.server.exceptions.StrReprMixin","text":"This mixin can be useful when testing requires a string representation of an exception that contains the HTTPException detail string, rather than the standard Python exception message.","title":"StrReprMixin"},{"location":"api_reference/server/exceptions/#optimade.server.exceptions.VersionNotSupported","text":"553 Version Not Supported","title":"VersionNotSupported"},{"location":"api_reference/server/logger/","text":"logger \u00b6 Logging to both file and terminal","title":"logger"},{"location":"api_reference/server/logger/#logger","text":"Logging to both file and terminal","title":"logger"},{"location":"api_reference/server/main/","text":"main \u00b6 The OPTIMADE server The server is based on MongoDB, using either pymongo or mongomock . This is an example implementation with example data. To implement your own server see the documentation at https://optimade.org/optimade-python-tools. add_major_version_base_url ( app ) \u00b6 Add mandatory vMajor endpoints, i.e. all except versions. Source code in optimade/server/main.py def add_major_version_base_url ( app : FastAPI ): \"\"\" Add mandatory vMajor endpoints, i.e. all except versions. \"\"\" for endpoint in ( info , links , references , structures , landing ): app . include_router ( endpoint . router , prefix = BASE_URL_PREFIXES [ \"major\" ]) add_optional_versioned_base_urls ( app ) \u00b6 Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): for endpoint in ( info , links , references , structures , landing ): app . include_router ( endpoint . router , prefix = BASE_URL_PREFIXES [ version ])","title":"main"},{"location":"api_reference/server/main/#main","text":"The OPTIMADE server The server is based on MongoDB, using either pymongo or mongomock . This is an example implementation with example data. To implement your own server see the documentation at https://optimade.org/optimade-python-tools.","title":"main"},{"location":"api_reference/server/main/#optimade.server.main.add_major_version_base_url","text":"Add mandatory vMajor endpoints, i.e. all except versions. Source code in optimade/server/main.py def add_major_version_base_url ( app : FastAPI ): \"\"\" Add mandatory vMajor endpoints, i.e. all except versions. \"\"\" for endpoint in ( info , links , references , structures , landing ): app . include_router ( endpoint . router , prefix = BASE_URL_PREFIXES [ \"major\" ])","title":"add_major_version_base_url()"},{"location":"api_reference/server/main/#optimade.server.main.add_optional_versioned_base_urls","text":"Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): for endpoint in ( info , links , references , structures , landing ): app . include_router ( endpoint . router , prefix = BASE_URL_PREFIXES [ version ])","title":"add_optional_versioned_base_urls()"},{"location":"api_reference/server/main_index/","text":"main_index \u00b6 The OPTIMADE Index Meta-Database server The server is based on MongoDB, using either pymongo or mongomock . This is an example implementation with example data. To implement your own index meta-database server see the documentation at https://optimade.org/optimade-python-tools. add_major_version_base_url ( app ) \u00b6 Add mandatory endpoints to /vMAJOR base URL. Source code in optimade/server/main_index.py def add_major_version_base_url ( app : FastAPI ): \"\"\" Add mandatory endpoints to `/vMAJOR` base URL. \"\"\" for endpoint in ( index_info , links ): app . include_router ( endpoint . router , prefix = BASE_URL_PREFIXES [ \"major\" ]) add_optional_versioned_base_urls ( app ) \u00b6 Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main_index.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): app . include_router ( index_info . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( links . router , prefix = BASE_URL_PREFIXES [ version ])","title":"main_index"},{"location":"api_reference/server/main_index/#main_index","text":"The OPTIMADE Index Meta-Database server The server is based on MongoDB, using either pymongo or mongomock . This is an example implementation with example data. To implement your own index meta-database server see the documentation at https://optimade.org/optimade-python-tools.","title":"main_index"},{"location":"api_reference/server/main_index/#optimade.server.main_index.add_major_version_base_url","text":"Add mandatory endpoints to /vMAJOR base URL. Source code in optimade/server/main_index.py def add_major_version_base_url ( app : FastAPI ): \"\"\" Add mandatory endpoints to `/vMAJOR` base URL. \"\"\" for endpoint in ( index_info , links ): app . include_router ( endpoint . router , prefix = BASE_URL_PREFIXES [ \"major\" ])","title":"add_major_version_base_url()"},{"location":"api_reference/server/main_index/#optimade.server.main_index.add_optional_versioned_base_urls","text":"Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main_index.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): app . include_router ( index_info . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( links . router , prefix = BASE_URL_PREFIXES [ version ])","title":"add_optional_versioned_base_urls()"},{"location":"api_reference/server/middleware/","text":"middleware \u00b6 Custom ASGI app middleware. These middleware are based on Starlette 's BaseHTTPMiddleware . See the specific Starlette documentation page for more information on it's middleware implementation. OPTIMADE_MIDDLEWARE : Tuple [ starlette . middleware . base . BaseHTTPMiddleware ] \u00b6 A tuple of all the middleware classes that implement certain required features of the OPTIMADE specification, e.g. warnings and URL versioning. Note The order in which middleware is added to an application matters. As discussed in the docstring of AddWarnings , this middleware is the final entry to this list so that it is the first to be applied by the server. Any other middleware should therefore be added before iterating through this variable. This is the opposite way around to the example in the Starlette documentation which initialises the application with a pre-built middleware list in the reverse order to OPTIMADE_MIDDLEWARE . To use this variable in FastAPI app code after initialisation: from fastapi import FastAPI app = FastAPI () for middleware in OPTIMADE_MIDDLEWARE : app . add_middleware ( middleware ) Alternatively, to use this variable on initialisation: from fastapi import FastAPI from starlette.middleware import Middleware app = FastAPI ( ... , middleware = [ Middleware ( m ) for m in reversed ( OPTIMADE_MIDDLEWARE )] ) AddWarnings ( BaseHTTPMiddleware ) \u00b6 Add OptimadeWarning s to the response. All sub-classes of OptimadeWarning will also be added to the response's meta.warnings list. By overriding the warnings.showwarning() function with the showwarning method , all usages of warnings.warn() will result in the regular printing of the warning message to stderr , but also its addition to an in-memory list of warnings. This middleware will, after the URL request has been handled, add the list of accumulated warnings to the JSON response under the meta.warnings field. To make sure the last part happens correctly and a Starlette StreamingResponse is returned, as is expected from a BaseHTTPMiddleware sub-class, one is instantiated with the updated Content-Length header, as well as making sure the response's body content is actually streamable, by breaking it down into chunks of the original response's chunk size. Important It is recommended to add this middleware as the last one to your application. This is to ensure it is invoked first , updating warnings.showwarning() and catching all warnings that should be added to the response. This can be achieved by applying AddWarnings after all other middleware with the .add_middleware() method, or by initialising the app with a middleware list in which AddWarnings appears first . More information can be found in the docstring of OPTIMADE_MIDDLEWARE . Attributes: Name Type Description _warnings List[Warnings] List of Warnings added through usages of warnings.warn() via showwarning . chunk_it_up ( content , chunk_size ) staticmethod \u00b6 Return generator for string in chunks of size chunk_size . Parameters: Name Type Description Default content str String-content to separate into chunks. required chunk_size int The size of the chunks, i.e. the length of the string-chunks. required Returns: Type Description Generator A Python generator to be converted later to an asyncio generator. Source code in optimade/server/middleware.py @staticmethod def chunk_it_up ( content : str , chunk_size : int ) -> Generator : \"\"\"Return generator for string in chunks of size `chunk_size`. Parameters: content: String-content to separate into chunks. chunk_size: The size of the chunks, i.e. the length of the string-chunks. Returns: A Python generator to be converted later to an `asyncio` generator. \"\"\" if chunk_size <= 0 : chunk_size = 1 return ( content [ i : chunk_size + i ] for i in range ( 0 , len ( content ), chunk_size )) showwarning ( self , message , category , filename , lineno , file = None , line = None ) \u00b6 Hook to write a warning to a file using the built-in warnings lib. In the documentation for the built-in warnings library, there are a few recommended ways of customizing the printing of warning messages. This method can override the warnings.showwarning function, which is called as part of the warnings library's workflow to print warning messages, e.g., when using warnings.warn() . Originally, it prints warning messages to stderr . This method will also print warning messages to stderr by calling warnings._showwarning_orig() or warnings._showwarnmsg_impl() . The first function will be called if the issued warning is not recognized as an OptimadeWarning . This is equivalent to \"standard behaviour\". The second function will be called after an OptimadeWarning has been handled. An OptimadeWarning will be translated into an OPTIMADE Warnings JSON object in accordance with the specification . This process is similar to the Exception handlers . Parameters: Name Type Description Default message Warning The Warning object to show and possibly handle. required category Type[Warning] Warning type being warned about. This amounts to type(message) . required filename str Name of the file, where the warning was issued. required lineno int Line number in the file, where the warning was issued. required file Optional[IO] A file-like object to which the warning should be written. None line Optional[str] Source content of the line that issued the warning. None Source code in optimade/server/middleware.py def showwarning ( self , message : Warning , category : Type [ Warning ], filename : str , lineno : int , file : Optional [ IO ] = None , line : Optional [ str ] = None , ) -> None : \"\"\" Hook to write a warning to a file using the built-in `warnings` lib. In [the documentation](https://docs.python.org/3/library/warnings.html) for the built-in `warnings` library, there are a few recommended ways of customizing the printing of warning messages. This method can override the `warnings.showwarning` function, which is called as part of the `warnings` library's workflow to print warning messages, e.g., when using `warnings.warn()`. Originally, it prints warning messages to `stderr`. This method will also print warning messages to `stderr` by calling `warnings._showwarning_orig()` or `warnings._showwarnmsg_impl()`. The first function will be called if the issued warning is not recognized as an [`OptimadeWarning`][optimade.server.warnings.OptimadeWarning]. This is equivalent to \"standard behaviour\". The second function will be called _after_ an [`OptimadeWarning`][optimade.server.warnings.OptimadeWarning] has been handled. An [`OptimadeWarning`][optimade.server.warnings.OptimadeWarning] will be translated into an OPTIMADE Warnings JSON object in accordance with [the specification](https://github.com/Materials-Consortia/OPTIMADE/blob/v1.0.0/optimade.rst#json-response-schema-common-fields). This process is similar to the [Exception handlers][optimade.server.exception_handlers]. Parameters: message: The `Warning` object to show and possibly handle. category: `Warning` type being warned about. This amounts to `type(message)`. filename: Name of the file, where the warning was issued. lineno: Line number in the file, where the warning was issued. file: A file-like object to which the warning should be written. line: Source content of the line that issued the warning. \"\"\" assert isinstance ( message , Warning ), \"'message' is expected to be a Warning or subclass thereof.\" if not isinstance ( message , OptimadeWarning ): # If the Warning is not an OptimadeWarning or subclass thereof, # use the regular 'showwarning' function. warnings . _showwarning_orig ( message , category , filename , lineno , file , line ) return # Format warning try : title = str ( message . title ) except AttributeError : title = str ( message . __class__ . __name__ ) try : detail = str ( message . detail ) except AttributeError : detail = str ( message ) if CONFIG . debug : if line is None : # All this is taken directly from the warnings library. # See 'warnings._formatwarnmsg_impl()' for the original code. try : import linecache line = linecache . getline ( filename , lineno ) except Exception : # When a warning is logged during Python shutdown, linecache # and the import machinery don't work anymore line = None linecache = None meta = { \"filename\" : filename , \"lineno\" : lineno , } if line : meta [ \"line\" ] = line . strip () if CONFIG . debug : new_warning = Warnings ( title = title , detail = detail , meta = meta ) else : new_warning = Warnings ( title = title , detail = detail ) # Add new warning to self._warnings self . _warnings . append ( new_warning . dict ( exclude_unset = True )) # Show warning message as normal in sys.stderr warnings . _showwarnmsg_impl ( warnings . WarningMessage ( message , category , filename , lineno , file , line ) ) CheckWronglyVersionedBaseUrls ( BaseHTTPMiddleware ) \u00b6 If a non-supported versioned base URL is supplied return 553 Version Not Supported . check_url ( url ) staticmethod \u00b6 Check URL path for versioned part. Parameters: Name Type Description Default url URL A complete urllib-parsed raw URL. required Exceptions: Type Description VersionNotSupported If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. Source code in optimade/server/middleware.py @staticmethod def check_url ( url : StarletteURL ): \"\"\"Check URL path for versioned part. Parameters: url: A complete urllib-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] if re . match ( r \"^/v[0-9]+\" , optimade_path ): for version_prefix in BASE_URL_PREFIXES . values (): if optimade_path . startswith ( f \" { version_prefix } /\" ): break else : version_prefix = re . findall ( r \"(/v[0-9]+(\\.[0-9]+){0,2})\" , optimade_path ) raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { version_prefix [ 0 ][ 0 ] !r} from \" f \" { url } is not supported by this implementation. \" f \"Supported versioned base URLs are: { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) ) EnsureQueryParamIntegrity ( BaseHTTPMiddleware ) \u00b6 Ensure all query parameters are followed by an equal sign ( = ). check_url ( url_query ) staticmethod \u00b6 Check parsed URL query part for parameters not followed by = . URL query parameters are considered to be split by ampersand ( & ) and semi-colon ( ; ). Parameters: Name Type Description Default url_query str The raw urllib-parsed query part. required Exceptions: Type Description BadRequest If a query parameter does not come with a value. Returns: Type Description set The set of individual query parameters and their values. This is mainly for testing and not actually neeeded by the middleware, since if the URL exhibits an invalid query part a 400 Bad Request response will be returned. Source code in optimade/server/middleware.py @staticmethod def check_url ( url_query : str ) -> set : \"\"\"Check parsed URL query part for parameters not followed by `=`. URL query parameters are considered to be split by ampersand (`&`) and semi-colon (`;`). Parameters: url_query: The raw urllib-parsed query part. Raises: BadRequest: If a query parameter does not come with a value. Returns: The set of individual query parameters and their values. This is mainly for testing and not actually neeeded by the middleware, since if the URL exhibits an invalid query part a `400 Bad Request` response will be returned. \"\"\" queries_amp = set ( url_query . split ( \"&\" )) queries = set () for query in queries_amp : queries . update ( set ( query . split ( \";\" ))) for query in queries : if \"=\" not in query and query != \"\" : raise BadRequest ( detail = \"A query parameter without an equal sign (=) is not supported by this server\" ) return queries # Useful for testing HandleApiHint ( BaseHTTPMiddleware ) \u00b6 Handle api_hint query parameter. handle_api_hint ( api_hint ) staticmethod \u00b6 Handle api_hint parameter value. There are several scenarios that can play out, when handling the api_hint query parameter: If several api_hint query parameters have been used, or a \"standard\" JSON list ( , -separated value) has been supplied, a warning will be added to the response and the api_hint query parameter will not be applied. If the passed value does not comply with the rules set out in the specification , a warning will be added to the response and the api_hint query parameter will not be applied. If the value is part of the implementation's accepted versioned base URLs, it will be returned as is. If the value represents a major version that is newer than what is supported by the implementation, a 553 Version Not Supported response will be returned, as is stated by the specification . On the other hand, if the value represents a major version equal to or lower than the implementation's supported major version, then the implementation's supported major version will be returned and tried for the request. Parameters: Name Type Description Default api_hint List[str] The urllib-parsed query parameter value for api_hint . required Exceptions: Type Description VersionNotSupported If the requested major version is newer than the supported major version of the implementation. Returns: Type Description Union[NoneType, str] Either a valid api_hint value or None . Source code in optimade/server/middleware.py @staticmethod def handle_api_hint ( api_hint : List [ str ]) -> Union [ None , str ]: \"\"\"Handle `api_hint` parameter value. There are several scenarios that can play out, when handling the `api_hint` query parameter: If several `api_hint` query parameters have been used, or a \"standard\" JSON list (`,`-separated value) has been supplied, a warning will be added to the response and the `api_hint` query parameter will not be applied. If the passed value does not comply with the rules set out in [the specification](https://github.com/Materials-Consortia/OPTIMADE/blob/v1.0.0/optimade.rst#version-negotiation), a warning will be added to the response and the `api_hint` query parameter will not be applied. If the value is part of the implementation's accepted versioned base URLs, it will be returned as is. If the value represents a major version that is newer than what is supported by the implementation, a `553 Version Not Supported` response will be returned, as is stated by [the specification](https://github.com/Materials-Consortia/OPTIMADE/blob/v1.0.0/optimade.rst#version-negotiation). On the other hand, if the value represents a major version equal to or lower than the implementation's supported major version, then the implementation's supported major version will be returned and tried for the request. Parameters: api_hint: The urllib-parsed query parameter value for `api_hint`. Raises: VersionNotSupported: If the requested major version is newer than the supported major version of the implementation. Returns: Either a valid `api_hint` value or `None`. \"\"\" # Try to split by `,` if value is provided once, but in JSON-type \"list\" format _api_hint = [] for value in api_hint : values = value . split ( \",\" ) _api_hint . extend ( values ) api_hint = _api_hint if len ( api_hint ) > 1 : warnings . warn ( TooManyValues ( detail = \"`api_hint` should only be supplied once, with a single value.\" ) ) return None api_hint = f \"/ { api_hint [ 0 ] } \" if re . match ( r \"^/v[0-9]+(\\.[0-9]+)?$\" , api_hint ) is None : warnings . warn ( FieldValueNotRecognized ( detail = f \" { api_hint [ 1 :] !r} is not recognized as a valid `api_hint` value.\" ) ) return None if api_hint in BASE_URL_PREFIXES . values (): return api_hint major_api_hint = int ( re . findall ( r \"/v([0-9]+)\" , api_hint )[ 0 ]) major_implementation = int ( BASE_URL_PREFIXES [ \"major\" ][ len ( \"/v\" ) :]) if major_api_hint > major_implementation : # Let's not try to handle a request for a newer major version raise VersionNotSupported ( detail = ( f \"The provided `api_hint` ( { api_hint [ 1 :] !r} ) is not supported by this implementation. \" f \"Supported versions include: { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) ) if major_api_hint <= major_implementation : # If less than: # Use the current implementation in hope that it can still handle older requests # # If equal: # Go to /v<MAJOR>, since this should point to the latest available return BASE_URL_PREFIXES [ \"major\" ] is_versioned_base_url ( url ) staticmethod \u00b6 Determine whether a request is for a versioned base URL. First, simply check whether a /vMAJOR(.MINOR.PATCH) part exists in the URL. If not, return False , else, remove unversioned base URL from the URL and check again. Return bool of final result. Parameters: Name Type Description Default url str The full URL to check. required Returns: Type Description bool Whether or not the full URL represents an OPTIMADE versioned base URL. Source code in optimade/server/middleware.py @staticmethod def is_versioned_base_url ( url : str ) -> bool : \"\"\"Determine whether a request is for a versioned base URL. First, simply check whether a `/vMAJOR(.MINOR.PATCH)` part exists in the URL. If not, return `False`, else, remove unversioned base URL from the URL and check again. Return `bool` of final result. Parameters: url: The full URL to check. Returns: Whether or not the full URL represents an OPTIMADE versioned base URL. \"\"\" if not re . findall ( r \"(/v[0-9]+(\\.[0-9]+){0,2})\" , url ): return False base_url = get_base_url ( url ) return bool ( re . findall ( r \"(/v[0-9]+(\\.[0-9]+){0,2})\" , url [ len ( base_url ) :]))","title":"middleware"},{"location":"api_reference/server/middleware/#middleware","text":"Custom ASGI app middleware. These middleware are based on Starlette 's BaseHTTPMiddleware . See the specific Starlette documentation page for more information on it's middleware implementation.","title":"middleware"},{"location":"api_reference/server/middleware/#optimade.server.middleware.OPTIMADE_MIDDLEWARE","text":"A tuple of all the middleware classes that implement certain required features of the OPTIMADE specification, e.g. warnings and URL versioning. Note The order in which middleware is added to an application matters. As discussed in the docstring of AddWarnings , this middleware is the final entry to this list so that it is the first to be applied by the server. Any other middleware should therefore be added before iterating through this variable. This is the opposite way around to the example in the Starlette documentation which initialises the application with a pre-built middleware list in the reverse order to OPTIMADE_MIDDLEWARE . To use this variable in FastAPI app code after initialisation: from fastapi import FastAPI app = FastAPI () for middleware in OPTIMADE_MIDDLEWARE : app . add_middleware ( middleware ) Alternatively, to use this variable on initialisation: from fastapi import FastAPI from starlette.middleware import Middleware app = FastAPI ( ... , middleware = [ Middleware ( m ) for m in reversed ( OPTIMADE_MIDDLEWARE )] )","title":"OPTIMADE_MIDDLEWARE"},{"location":"api_reference/server/middleware/#optimade.server.middleware.AddWarnings","text":"Add OptimadeWarning s to the response. All sub-classes of OptimadeWarning will also be added to the response's meta.warnings list. By overriding the warnings.showwarning() function with the showwarning method , all usages of warnings.warn() will result in the regular printing of the warning message to stderr , but also its addition to an in-memory list of warnings. This middleware will, after the URL request has been handled, add the list of accumulated warnings to the JSON response under the meta.warnings field. To make sure the last part happens correctly and a Starlette StreamingResponse is returned, as is expected from a BaseHTTPMiddleware sub-class, one is instantiated with the updated Content-Length header, as well as making sure the response's body content is actually streamable, by breaking it down into chunks of the original response's chunk size. Important It is recommended to add this middleware as the last one to your application. This is to ensure it is invoked first , updating warnings.showwarning() and catching all warnings that should be added to the response. This can be achieved by applying AddWarnings after all other middleware with the .add_middleware() method, or by initialising the app with a middleware list in which AddWarnings appears first . More information can be found in the docstring of OPTIMADE_MIDDLEWARE . Attributes: Name Type Description _warnings List[Warnings] List of Warnings added through usages of warnings.warn() via showwarning .","title":"AddWarnings"},{"location":"api_reference/server/middleware/#optimade.server.middleware.AddWarnings.chunk_it_up","text":"Return generator for string in chunks of size chunk_size . Parameters: Name Type Description Default content str String-content to separate into chunks. required chunk_size int The size of the chunks, i.e. the length of the string-chunks. required Returns: Type Description Generator A Python generator to be converted later to an asyncio generator. Source code in optimade/server/middleware.py @staticmethod def chunk_it_up ( content : str , chunk_size : int ) -> Generator : \"\"\"Return generator for string in chunks of size `chunk_size`. Parameters: content: String-content to separate into chunks. chunk_size: The size of the chunks, i.e. the length of the string-chunks. Returns: A Python generator to be converted later to an `asyncio` generator. \"\"\" if chunk_size <= 0 : chunk_size = 1 return ( content [ i : chunk_size + i ] for i in range ( 0 , len ( content ), chunk_size ))","title":"chunk_it_up()"},{"location":"api_reference/server/middleware/#optimade.server.middleware.AddWarnings.showwarning","text":"Hook to write a warning to a file using the built-in warnings lib. In the documentation for the built-in warnings library, there are a few recommended ways of customizing the printing of warning messages. This method can override the warnings.showwarning function, which is called as part of the warnings library's workflow to print warning messages, e.g., when using warnings.warn() . Originally, it prints warning messages to stderr . This method will also print warning messages to stderr by calling warnings._showwarning_orig() or warnings._showwarnmsg_impl() . The first function will be called if the issued warning is not recognized as an OptimadeWarning . This is equivalent to \"standard behaviour\". The second function will be called after an OptimadeWarning has been handled. An OptimadeWarning will be translated into an OPTIMADE Warnings JSON object in accordance with the specification . This process is similar to the Exception handlers . Parameters: Name Type Description Default message Warning The Warning object to show and possibly handle. required category Type[Warning] Warning type being warned about. This amounts to type(message) . required filename str Name of the file, where the warning was issued. required lineno int Line number in the file, where the warning was issued. required file Optional[IO] A file-like object to which the warning should be written. None line Optional[str] Source content of the line that issued the warning. None Source code in optimade/server/middleware.py def showwarning ( self , message : Warning , category : Type [ Warning ], filename : str , lineno : int , file : Optional [ IO ] = None , line : Optional [ str ] = None , ) -> None : \"\"\" Hook to write a warning to a file using the built-in `warnings` lib. In [the documentation](https://docs.python.org/3/library/warnings.html) for the built-in `warnings` library, there are a few recommended ways of customizing the printing of warning messages. This method can override the `warnings.showwarning` function, which is called as part of the `warnings` library's workflow to print warning messages, e.g., when using `warnings.warn()`. Originally, it prints warning messages to `stderr`. This method will also print warning messages to `stderr` by calling `warnings._showwarning_orig()` or `warnings._showwarnmsg_impl()`. The first function will be called if the issued warning is not recognized as an [`OptimadeWarning`][optimade.server.warnings.OptimadeWarning]. This is equivalent to \"standard behaviour\". The second function will be called _after_ an [`OptimadeWarning`][optimade.server.warnings.OptimadeWarning] has been handled. An [`OptimadeWarning`][optimade.server.warnings.OptimadeWarning] will be translated into an OPTIMADE Warnings JSON object in accordance with [the specification](https://github.com/Materials-Consortia/OPTIMADE/blob/v1.0.0/optimade.rst#json-response-schema-common-fields). This process is similar to the [Exception handlers][optimade.server.exception_handlers]. Parameters: message: The `Warning` object to show and possibly handle. category: `Warning` type being warned about. This amounts to `type(message)`. filename: Name of the file, where the warning was issued. lineno: Line number in the file, where the warning was issued. file: A file-like object to which the warning should be written. line: Source content of the line that issued the warning. \"\"\" assert isinstance ( message , Warning ), \"'message' is expected to be a Warning or subclass thereof.\" if not isinstance ( message , OptimadeWarning ): # If the Warning is not an OptimadeWarning or subclass thereof, # use the regular 'showwarning' function. warnings . _showwarning_orig ( message , category , filename , lineno , file , line ) return # Format warning try : title = str ( message . title ) except AttributeError : title = str ( message . __class__ . __name__ ) try : detail = str ( message . detail ) except AttributeError : detail = str ( message ) if CONFIG . debug : if line is None : # All this is taken directly from the warnings library. # See 'warnings._formatwarnmsg_impl()' for the original code. try : import linecache line = linecache . getline ( filename , lineno ) except Exception : # When a warning is logged during Python shutdown, linecache # and the import machinery don't work anymore line = None linecache = None meta = { \"filename\" : filename , \"lineno\" : lineno , } if line : meta [ \"line\" ] = line . strip () if CONFIG . debug : new_warning = Warnings ( title = title , detail = detail , meta = meta ) else : new_warning = Warnings ( title = title , detail = detail ) # Add new warning to self._warnings self . _warnings . append ( new_warning . dict ( exclude_unset = True )) # Show warning message as normal in sys.stderr warnings . _showwarnmsg_impl ( warnings . WarningMessage ( message , category , filename , lineno , file , line ) )","title":"showwarning()"},{"location":"api_reference/server/middleware/#optimade.server.middleware.CheckWronglyVersionedBaseUrls","text":"If a non-supported versioned base URL is supplied return 553 Version Not Supported .","title":"CheckWronglyVersionedBaseUrls"},{"location":"api_reference/server/middleware/#optimade.server.middleware.CheckWronglyVersionedBaseUrls.check_url","text":"Check URL path for versioned part. Parameters: Name Type Description Default url URL A complete urllib-parsed raw URL. required Exceptions: Type Description VersionNotSupported If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. Source code in optimade/server/middleware.py @staticmethod def check_url ( url : StarletteURL ): \"\"\"Check URL path for versioned part. Parameters: url: A complete urllib-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] if re . match ( r \"^/v[0-9]+\" , optimade_path ): for version_prefix in BASE_URL_PREFIXES . values (): if optimade_path . startswith ( f \" { version_prefix } /\" ): break else : version_prefix = re . findall ( r \"(/v[0-9]+(\\.[0-9]+){0,2})\" , optimade_path ) raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { version_prefix [ 0 ][ 0 ] !r} from \" f \" { url } is not supported by this implementation. \" f \"Supported versioned base URLs are: { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) )","title":"check_url()"},{"location":"api_reference/server/middleware/#optimade.server.middleware.EnsureQueryParamIntegrity","text":"Ensure all query parameters are followed by an equal sign ( = ).","title":"EnsureQueryParamIntegrity"},{"location":"api_reference/server/middleware/#optimade.server.middleware.EnsureQueryParamIntegrity.check_url","text":"Check parsed URL query part for parameters not followed by = . URL query parameters are considered to be split by ampersand ( & ) and semi-colon ( ; ). Parameters: Name Type Description Default url_query str The raw urllib-parsed query part. required Exceptions: Type Description BadRequest If a query parameter does not come with a value. Returns: Type Description set The set of individual query parameters and their values. This is mainly for testing and not actually neeeded by the middleware, since if the URL exhibits an invalid query part a 400 Bad Request response will be returned. Source code in optimade/server/middleware.py @staticmethod def check_url ( url_query : str ) -> set : \"\"\"Check parsed URL query part for parameters not followed by `=`. URL query parameters are considered to be split by ampersand (`&`) and semi-colon (`;`). Parameters: url_query: The raw urllib-parsed query part. Raises: BadRequest: If a query parameter does not come with a value. Returns: The set of individual query parameters and their values. This is mainly for testing and not actually neeeded by the middleware, since if the URL exhibits an invalid query part a `400 Bad Request` response will be returned. \"\"\" queries_amp = set ( url_query . split ( \"&\" )) queries = set () for query in queries_amp : queries . update ( set ( query . split ( \";\" ))) for query in queries : if \"=\" not in query and query != \"\" : raise BadRequest ( detail = \"A query parameter without an equal sign (=) is not supported by this server\" ) return queries # Useful for testing","title":"check_url()"},{"location":"api_reference/server/middleware/#optimade.server.middleware.HandleApiHint","text":"Handle api_hint query parameter.","title":"HandleApiHint"},{"location":"api_reference/server/middleware/#optimade.server.middleware.HandleApiHint.handle_api_hint","text":"Handle api_hint parameter value. There are several scenarios that can play out, when handling the api_hint query parameter: If several api_hint query parameters have been used, or a \"standard\" JSON list ( , -separated value) has been supplied, a warning will be added to the response and the api_hint query parameter will not be applied. If the passed value does not comply with the rules set out in the specification , a warning will be added to the response and the api_hint query parameter will not be applied. If the value is part of the implementation's accepted versioned base URLs, it will be returned as is. If the value represents a major version that is newer than what is supported by the implementation, a 553 Version Not Supported response will be returned, as is stated by the specification . On the other hand, if the value represents a major version equal to or lower than the implementation's supported major version, then the implementation's supported major version will be returned and tried for the request. Parameters: Name Type Description Default api_hint List[str] The urllib-parsed query parameter value for api_hint . required Exceptions: Type Description VersionNotSupported If the requested major version is newer than the supported major version of the implementation. Returns: Type Description Union[NoneType, str] Either a valid api_hint value or None . Source code in optimade/server/middleware.py @staticmethod def handle_api_hint ( api_hint : List [ str ]) -> Union [ None , str ]: \"\"\"Handle `api_hint` parameter value. There are several scenarios that can play out, when handling the `api_hint` query parameter: If several `api_hint` query parameters have been used, or a \"standard\" JSON list (`,`-separated value) has been supplied, a warning will be added to the response and the `api_hint` query parameter will not be applied. If the passed value does not comply with the rules set out in [the specification](https://github.com/Materials-Consortia/OPTIMADE/blob/v1.0.0/optimade.rst#version-negotiation), a warning will be added to the response and the `api_hint` query parameter will not be applied. If the value is part of the implementation's accepted versioned base URLs, it will be returned as is. If the value represents a major version that is newer than what is supported by the implementation, a `553 Version Not Supported` response will be returned, as is stated by [the specification](https://github.com/Materials-Consortia/OPTIMADE/blob/v1.0.0/optimade.rst#version-negotiation). On the other hand, if the value represents a major version equal to or lower than the implementation's supported major version, then the implementation's supported major version will be returned and tried for the request. Parameters: api_hint: The urllib-parsed query parameter value for `api_hint`. Raises: VersionNotSupported: If the requested major version is newer than the supported major version of the implementation. Returns: Either a valid `api_hint` value or `None`. \"\"\" # Try to split by `,` if value is provided once, but in JSON-type \"list\" format _api_hint = [] for value in api_hint : values = value . split ( \",\" ) _api_hint . extend ( values ) api_hint = _api_hint if len ( api_hint ) > 1 : warnings . warn ( TooManyValues ( detail = \"`api_hint` should only be supplied once, with a single value.\" ) ) return None api_hint = f \"/ { api_hint [ 0 ] } \" if re . match ( r \"^/v[0-9]+(\\.[0-9]+)?$\" , api_hint ) is None : warnings . warn ( FieldValueNotRecognized ( detail = f \" { api_hint [ 1 :] !r} is not recognized as a valid `api_hint` value.\" ) ) return None if api_hint in BASE_URL_PREFIXES . values (): return api_hint major_api_hint = int ( re . findall ( r \"/v([0-9]+)\" , api_hint )[ 0 ]) major_implementation = int ( BASE_URL_PREFIXES [ \"major\" ][ len ( \"/v\" ) :]) if major_api_hint > major_implementation : # Let's not try to handle a request for a newer major version raise VersionNotSupported ( detail = ( f \"The provided `api_hint` ( { api_hint [ 1 :] !r} ) is not supported by this implementation. \" f \"Supported versions include: { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) ) if major_api_hint <= major_implementation : # If less than: # Use the current implementation in hope that it can still handle older requests # # If equal: # Go to /v<MAJOR>, since this should point to the latest available return BASE_URL_PREFIXES [ \"major\" ]","title":"handle_api_hint()"},{"location":"api_reference/server/middleware/#optimade.server.middleware.HandleApiHint.is_versioned_base_url","text":"Determine whether a request is for a versioned base URL. First, simply check whether a /vMAJOR(.MINOR.PATCH) part exists in the URL. If not, return False , else, remove unversioned base URL from the URL and check again. Return bool of final result. Parameters: Name Type Description Default url str The full URL to check. required Returns: Type Description bool Whether or not the full URL represents an OPTIMADE versioned base URL. Source code in optimade/server/middleware.py @staticmethod def is_versioned_base_url ( url : str ) -> bool : \"\"\"Determine whether a request is for a versioned base URL. First, simply check whether a `/vMAJOR(.MINOR.PATCH)` part exists in the URL. If not, return `False`, else, remove unversioned base URL from the URL and check again. Return `bool` of final result. Parameters: url: The full URL to check. Returns: Whether or not the full URL represents an OPTIMADE versioned base URL. \"\"\" if not re . findall ( r \"(/v[0-9]+(\\.[0-9]+){0,2})\" , url ): return False base_url = get_base_url ( url ) return bool ( re . findall ( r \"(/v[0-9]+(\\.[0-9]+){0,2})\" , url [ len ( base_url ) :]))","title":"is_versioned_base_url()"},{"location":"api_reference/server/query_params/","text":"query_params \u00b6 EntryListingQueryParams \u00b6 Common query params for all Entry listing endpoints. Attributes: Name Type Description filter str A filter string, in the format described in section API Filtering Format Specification of the specification. response_format str The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example : http://example.com/v1/structures?response_format=xml email_address EmailStr An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example : http://example.com/v1/structures?email_address=user@example.com response_fields str A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example : http://example.com/v1/structures?response_fields=last_modified,nsites sort str If supporting sortable queries, an implementation MUST use the sort query parameter with format as specified by JSON API 1.0 . An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification. If an implementation supports sorting for an entry listing endpoint, then the /info/<entries> endpoint MUST include, for each field name <fieldname> in its data.properties.<fieldname> response value that can be used for sorting, the key sortable with value true . If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the sortable key or set it equal to false for the specific field name. The set of field names, with sortable equal to true are allowed to be used in the \"sort fields\" list according to its definition in the JSON API 1.0 specification. The field sortable is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. page_limit int Sets a numerical limit on the number of entries returned. See JSON API 1.0 . The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example : http://example.com/optimade/v1/structures?page_limit=100 page_offset int RECOMMENDED for use with offset-based pagination: using page_offset and page_limit is RECOMMENDED. Example : Skip 50 structures and fetch up to 100: /structures?page_offset=50&page_limit=100 . page_number int RECOMMENDED for use with page-based pagination: using page_number and page_limit is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that page_number is 1-based. Example : Fetch page 2 of up to 50 structures per page: /structures?page_number=2&page_limit=50 . page_cursor int RECOMMENDED for use with cursor-based pagination: using page_cursor and page_limit is RECOMMENDED. page_above int RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. Example : Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing id , so page_above value refers to an id value): /structures?page_above=4000&page_limit=100 . page_below int RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. include str A server MAY implement the JSON API concept of returning compound documents by utilizing the include query parameter as specified by JSON API 1.0 . All related resource objects MUST be returned as part of an array value for the top-level included field, see the section JSON Response Schema: Common Fields. The value of include MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API . If relationship paths are not supported, or a server is unable to identify a relationship path a 400 Bad Request response MUST be made. The default value for include is references . This means references entries MUST always be included under the top-level field included as default, since a server assumes if include is not specified by a client in the request, it is still specified as include=references . Note, if a client explicitly specifies include and leaves out references , references resource objects MUST NOT be included under the top-level field included , as per the definition of included , see section JSON Response Schema: Common Fields. Note : A query with the parameter include set to the empty string means no related resource objects are to be returned under the top-level field included . api_hint str If the client provides the parameter, the value SHOULD have the format vMAJOR or vMAJOR.MINOR , where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends api_hint=v1.0 to the query string, the hint provided is for major version 1 and minor version 0. SingleEntryQueryParams \u00b6 Common query params for single entry endpoints. Attributes: Name Type Description response_format str The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example : http://example.com/v1/structures?response_format=xml email_address EmailStr An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example : http://example.com/v1/structures?email_address=user@example.com response_fields str A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example : http://example.com/v1/structures?response_fields=last_modified,nsites include str A server MAY implement the JSON API concept of returning compound documents by utilizing the include query parameter as specified by JSON API 1.0 . All related resource objects MUST be returned as part of an array value for the top-level included field, see the section JSON Response Schema: Common Fields. The value of include MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API . If relationship paths are not supported, or a server is unable to identify a relationship path a 400 Bad Request response MUST be made. The default value for include is references . This means references entries MUST always be included under the top-level field included as default, since a server assumes if include is not specified by a client in the request, it is still specified as include=references . Note, if a client explicitly specifies include and leaves out references , references resource objects MUST NOT be included under the top-level field included , as per the definition of included , see section JSON Response Schema: Common Fields. Note : A query with the parameter include set to the empty string means no related resource objects are to be returned under the top-level field included . api_hint str If the client provides the parameter, the value SHOULD have the format vMAJOR or vMAJOR.MINOR , where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends api_hint=v1.0 to the query string, the hint provided is for major version 1 and minor version 0.","title":"query_params"},{"location":"api_reference/server/query_params/#query_params","text":"","title":"query_params"},{"location":"api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams","text":"Common query params for all Entry listing endpoints. Attributes: Name Type Description filter str A filter string, in the format described in section API Filtering Format Specification of the specification. response_format str The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example : http://example.com/v1/structures?response_format=xml email_address EmailStr An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example : http://example.com/v1/structures?email_address=user@example.com response_fields str A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example : http://example.com/v1/structures?response_fields=last_modified,nsites sort str If supporting sortable queries, an implementation MUST use the sort query parameter with format as specified by JSON API 1.0 . An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification. If an implementation supports sorting for an entry listing endpoint, then the /info/<entries> endpoint MUST include, for each field name <fieldname> in its data.properties.<fieldname> response value that can be used for sorting, the key sortable with value true . If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the sortable key or set it equal to false for the specific field name. The set of field names, with sortable equal to true are allowed to be used in the \"sort fields\" list according to its definition in the JSON API 1.0 specification. The field sortable is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. page_limit int Sets a numerical limit on the number of entries returned. See JSON API 1.0 . The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example : http://example.com/optimade/v1/structures?page_limit=100 page_offset int RECOMMENDED for use with offset-based pagination: using page_offset and page_limit is RECOMMENDED. Example : Skip 50 structures and fetch up to 100: /structures?page_offset=50&page_limit=100 . page_number int RECOMMENDED for use with page-based pagination: using page_number and page_limit is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that page_number is 1-based. Example : Fetch page 2 of up to 50 structures per page: /structures?page_number=2&page_limit=50 . page_cursor int RECOMMENDED for use with cursor-based pagination: using page_cursor and page_limit is RECOMMENDED. page_above int RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. Example : Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing id , so page_above value refers to an id value): /structures?page_above=4000&page_limit=100 . page_below int RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. include str A server MAY implement the JSON API concept of returning compound documents by utilizing the include query parameter as specified by JSON API 1.0 . All related resource objects MUST be returned as part of an array value for the top-level included field, see the section JSON Response Schema: Common Fields. The value of include MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API . If relationship paths are not supported, or a server is unable to identify a relationship path a 400 Bad Request response MUST be made. The default value for include is references . This means references entries MUST always be included under the top-level field included as default, since a server assumes if include is not specified by a client in the request, it is still specified as include=references . Note, if a client explicitly specifies include and leaves out references , references resource objects MUST NOT be included under the top-level field included , as per the definition of included , see section JSON Response Schema: Common Fields. Note : A query with the parameter include set to the empty string means no related resource objects are to be returned under the top-level field included . api_hint str If the client provides the parameter, the value SHOULD have the format vMAJOR or vMAJOR.MINOR , where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends api_hint=v1.0 to the query string, the hint provided is for major version 1 and minor version 0.","title":"EntryListingQueryParams"},{"location":"api_reference/server/query_params/#optimade.server.query_params.SingleEntryQueryParams","text":"Common query params for single entry endpoints. Attributes: Name Type Description response_format str The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example : http://example.com/v1/structures?response_format=xml email_address EmailStr An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example : http://example.com/v1/structures?email_address=user@example.com response_fields str A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example : http://example.com/v1/structures?response_fields=last_modified,nsites include str A server MAY implement the JSON API concept of returning compound documents by utilizing the include query parameter as specified by JSON API 1.0 . All related resource objects MUST be returned as part of an array value for the top-level included field, see the section JSON Response Schema: Common Fields. The value of include MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API . If relationship paths are not supported, or a server is unable to identify a relationship path a 400 Bad Request response MUST be made. The default value for include is references . This means references entries MUST always be included under the top-level field included as default, since a server assumes if include is not specified by a client in the request, it is still specified as include=references . Note, if a client explicitly specifies include and leaves out references , references resource objects MUST NOT be included under the top-level field included , as per the definition of included , see section JSON Response Schema: Common Fields. Note : A query with the parameter include set to the empty string means no related resource objects are to be returned under the top-level field included . api_hint str If the client provides the parameter, the value SHOULD have the format vMAJOR or vMAJOR.MINOR , where MAJOR is a major version and MINOR is a minor version of the API. For example, if a client appends api_hint=v1.0 to the query string, the hint provided is for major version 1 and minor version 0.","title":"SingleEntryQueryParams"},{"location":"api_reference/server/schemas/","text":"schemas \u00b6 retrieve_queryable_properties ( schema , queryable_properties ) \u00b6 Recurisvely loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: Name Type Description Default schema dict The schema of the pydantic model. required queryable_properties list The list of properties to find in the schema. required Returns: Type Description dict A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. Source code in optimade/server/schemas.py def retrieve_queryable_properties ( schema : dict , queryable_properties : list ) -> dict : \"\"\"Recurisvely loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: schema: The schema of the pydantic model. queryable_properties: The list of properties to find in the schema. Returns: A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. \"\"\" properties = {} for name , value in schema [ \"properties\" ] . items (): if name in queryable_properties : if \"$ref\" in value : path = value [ \"$ref\" ] . split ( \"/\" )[ 1 :] sub_schema = schema . copy () while path : next_key = path . pop ( 0 ) sub_schema = sub_schema [ next_key ] sub_queryable_properties = sub_schema [ \"properties\" ] . keys () properties . update ( retrieve_queryable_properties ( sub_schema , sub_queryable_properties ) ) else : properties [ name ] = { \"description\" : value . get ( \"description\" , \"\" )} # Update schema with extension keys provided they are not None for key in [ _ for _ in ( \"unit\" , \"queryable\" , \"support\" ) if _ in value ]: properties [ name ][ key ] = value [ key ] # All properties are sortable with the MongoDB backend. # While the result for sorting lists may not be as expected, they are still sorted. properties [ name ][ \"sortable\" ] = value . get ( \"sortable\" , True ) # Try to get OpenAPI-specific \"format\" if possible, else get \"type\"; a mandatory OpenAPI key. properties [ name ][ \"type\" ] = DataType . from_json_type ( value . get ( \"format\" , value [ \"type\" ]) ) return properties","title":"schemas"},{"location":"api_reference/server/schemas/#schemas","text":"","title":"schemas"},{"location":"api_reference/server/schemas/#optimade.server.schemas.retrieve_queryable_properties","text":"Recurisvely loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: Name Type Description Default schema dict The schema of the pydantic model. required queryable_properties list The list of properties to find in the schema. required Returns: Type Description dict A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. Source code in optimade/server/schemas.py def retrieve_queryable_properties ( schema : dict , queryable_properties : list ) -> dict : \"\"\"Recurisvely loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: schema: The schema of the pydantic model. queryable_properties: The list of properties to find in the schema. Returns: A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. \"\"\" properties = {} for name , value in schema [ \"properties\" ] . items (): if name in queryable_properties : if \"$ref\" in value : path = value [ \"$ref\" ] . split ( \"/\" )[ 1 :] sub_schema = schema . copy () while path : next_key = path . pop ( 0 ) sub_schema = sub_schema [ next_key ] sub_queryable_properties = sub_schema [ \"properties\" ] . keys () properties . update ( retrieve_queryable_properties ( sub_schema , sub_queryable_properties ) ) else : properties [ name ] = { \"description\" : value . get ( \"description\" , \"\" )} # Update schema with extension keys provided they are not None for key in [ _ for _ in ( \"unit\" , \"queryable\" , \"support\" ) if _ in value ]: properties [ name ][ key ] = value [ key ] # All properties are sortable with the MongoDB backend. # While the result for sorting lists may not be as expected, they are still sorted. properties [ name ][ \"sortable\" ] = value . get ( \"sortable\" , True ) # Try to get OpenAPI-specific \"format\" if possible, else get \"type\"; a mandatory OpenAPI key. properties [ name ][ \"type\" ] = DataType . from_json_type ( value . get ( \"format\" , value [ \"type\" ]) ) return properties","title":"retrieve_queryable_properties()"},{"location":"api_reference/server/warnings/","text":"warnings \u00b6 FieldValueNotRecognized ( OptimadeWarning ) \u00b6 A field or value used in the request is not recognised by this implementation. MissingExpectedField ( OptimadeWarning ) \u00b6 A field was provided with a null value when a related field was provided with a value. OptimadeWarning ( Warning ) \u00b6 Base Warning for the optimade package QueryParamNotUsed ( OptimadeWarning ) \u00b6 A query parameter is not used in this request. TimestampNotRFCCompliant ( OptimadeWarning ) \u00b6 A timestamp has been used in a filter that contains microseconds and is thus not RFC 3339 compliant. This may cause undefined behaviour in the query results. TooManyValues ( OptimadeWarning ) \u00b6 A field or query parameter has too many values to be handled by this implementation.","title":"warnings"},{"location":"api_reference/server/warnings/#warnings","text":"","title":"warnings"},{"location":"api_reference/server/warnings/#optimade.server.warnings.FieldValueNotRecognized","text":"A field or value used in the request is not recognised by this implementation.","title":"FieldValueNotRecognized"},{"location":"api_reference/server/warnings/#optimade.server.warnings.MissingExpectedField","text":"A field was provided with a null value when a related field was provided with a value.","title":"MissingExpectedField"},{"location":"api_reference/server/warnings/#optimade.server.warnings.OptimadeWarning","text":"Base Warning for the optimade package","title":"OptimadeWarning"},{"location":"api_reference/server/warnings/#optimade.server.warnings.QueryParamNotUsed","text":"A query parameter is not used in this request.","title":"QueryParamNotUsed"},{"location":"api_reference/server/warnings/#optimade.server.warnings.TimestampNotRFCCompliant","text":"A timestamp has been used in a filter that contains microseconds and is thus not RFC 3339 compliant. This may cause undefined behaviour in the query results.","title":"TimestampNotRFCCompliant"},{"location":"api_reference/server/warnings/#optimade.server.warnings.TooManyValues","text":"A field or query parameter has too many values to be handled by this implementation.","title":"TooManyValues"},{"location":"api_reference/server/entry_collections/entry_collections/","text":"entry_collections \u00b6 EntryCollection ( ABC ) \u00b6 Backend-agnostic base class for querying collections of EntryResource s. all_fields : set property readonly \u00b6 Get the set of all fields handled in this collection, from attribute fields in the schema, provider fields and top-level OPTIMADE fields. Returns: Type Description set All fields handled in this collection. __init__ ( self , collection , resource_cls , resource_mapper , transformer ) special \u00b6 Initialize the collection for the given parameters. Parameters: Name Type Description Default collection The backend-specific collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required transformer Transformer The Lark Transformer used to interpret the filter. required Source code in optimade/server/entry_collections/entry_collections.py def __init__ ( self , collection , resource_cls : EntryResource , resource_mapper : BaseResourceMapper , transformer : Transformer , ): \"\"\"Initialize the collection for the given parameters. Parameters: collection: The backend-specific collection. resource_cls (EntryResource): The `EntryResource` model that is stored by the collection. resource_mapper (BaseResourceMapper): A resource mapper object that handles aliases and format changes between deserialization and response. transformer (Transformer): The Lark `Transformer` used to interpret the filter. \"\"\" self . collection = collection self . parser = LarkParser () self . resource_cls = resource_cls self . resource_mapper = resource_mapper self . transformer = transformer self . provider_prefix = CONFIG . provider . prefix self . provider_fields = CONFIG . provider_fields . get ( resource_mapper . ENDPOINT , []) __len__ ( self ) special \u00b6 Returns the total number of entries in the collection. Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def __len__ ( self ) -> int : \"\"\" Returns the total number of entries in the collection. \"\"\" count ( self , ** kwargs ) \u00b6 Returns the number of entries matching the query specified by the keyword arguments. Parameters: Name Type Description Default kwargs dict Query parameters as keyword arguments. {} Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def count ( self , ** kwargs ) -> int : \"\"\"Returns the number of entries matching the query specified by the keyword arguments. Parameters: kwargs (dict): Query parameters as keyword arguments. \"\"\" find ( self , params ) \u00b6 Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit . See EntryListingQueryParams for more information. Parameters: Name Type Description Default params EntryListingQueryParams entry listing URL query params required Returns: Type Description Tuple[List[optimade.models.entries.EntryResource], int, bool, set] ( results , data_returned , more_data_available , fields ). Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def find ( self , params : EntryListingQueryParams ) -> Tuple [ List [ EntryResource ], int , bool , set ]: \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of `page_limit`. See [`EntryListingQueryParams`][optimade.server.query_params.EntryListingQueryParams] for more information. Parameters: params (EntryListingQueryParams): entry listing URL query params Returns: (`results`, `data_returned`, `more_data_available`, `fields`). \"\"\" get_attribute_fields ( self ) \u00b6 Get the set of attribute fields Return only the first-level attribute fields from the schema of the resource class, resolving references along the way if needed. Note It is not needed to take care of other special OpenAPI schema keys than allOf , since only allOf will be found in this context. Other special keys can be found in the Swagger documentation . Returns: Type Description set Property names. Source code in optimade/server/entry_collections/entry_collections.py def get_attribute_fields ( self ) -> set : \"\"\"Get the set of attribute fields Return only the _first-level_ attribute fields from the schema of the resource class, resolving references along the way if needed. Note: It is not needed to take care of other special OpenAPI schema keys than `allOf`, since only `allOf` will be found in this context. Other special keys can be found in [the Swagger documentation](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/). Returns: Property names. \"\"\" schema = self . resource_cls . schema () attributes = schema [ \"properties\" ][ \"attributes\" ] if \"allOf\" in attributes : allOf = attributes . pop ( \"allOf\" ) for dict_ in allOf : attributes . update ( dict_ ) if \"$ref\" in attributes : path = attributes [ \"$ref\" ] . split ( \"/\" )[ 1 :] attributes = schema . copy () while path : next_key = path . pop ( 0 ) attributes = attributes [ next_key ] return set ( attributes [ \"properties\" ] . keys ()) handle_query_params ( self , params ) \u00b6 Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] The initialized query parameter model from the server. required Exceptions: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description dict A dictionary representation of the query parameters, ready to be used by pymongo. Source code in optimade/server/entry_collections/entry_collections.py def handle_query_params ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> dict : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params (Union[EntryListingQueryParams, SingleEntryQueryParams]): The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters, ready to be used by pymongo. \"\"\" cursor_kwargs = {} if getattr ( params , \"filter\" , False ): tree = self . parser . parse ( params . filter ) cursor_kwargs [ \"filter\" ] = self . transformer . transform ( tree ) else : cursor_kwargs [ \"filter\" ] = {} if ( getattr ( params , \"response_format\" , False ) and params . response_format != \"json\" ): raise BadRequest ( detail = f \"Response format { params . response_format } is not supported, please use response_format='json'\" ) if getattr ( params , \"page_limit\" , False ): limit = params . page_limit if limit > CONFIG . page_limit_max : raise Forbidden ( detail = f \"Max allowed page_limit is { CONFIG . page_limit_max } , you requested { limit } \" , ) cursor_kwargs [ \"limit\" ] = limit else : cursor_kwargs [ \"limit\" ] = CONFIG . page_limit cursor_kwargs [ \"fields\" ] = self . all_fields cursor_kwargs [ \"projection\" ] = { f \" { self . resource_mapper . alias_for ( f ) } \" : True for f in self . all_fields } if \"_id\" not in cursor_kwargs [ \"projection\" ]: cursor_kwargs [ \"projection\" ][ \"_id\" ] = False if getattr ( params , \"sort\" , False ): cursor_kwargs [ \"sort\" ] = self . parse_sort_params ( params . sort ) if getattr ( params , \"page_offset\" , False ): cursor_kwargs [ \"skip\" ] = params . page_offset return cursor_kwargs parse_sort_params ( self , sort_params ) \u00b6 Handles any sort parameters passed to the collection, resolving aliases and dealing with any invalid fields. Exceptions: Type Description BadRequest if an invalid sort is requested. Returns: Type Description List[Tuple[str, int]] A list of tuples containing the aliased field name and sort direction encoded as 1 (ascending) or -1 (descending). Source code in optimade/server/entry_collections/entry_collections.py def parse_sort_params ( self , sort_params ) -> List [ Tuple [ str , int ]]: \"\"\"Handles any sort parameters passed to the collection, resolving aliases and dealing with any invalid fields. Raises: BadRequest: if an invalid sort is requested. Returns: A list of tuples containing the aliased field name and sort direction encoded as 1 (ascending) or -1 (descending). \"\"\" sort_spec = [] for field in sort_params . split ( \",\" ): sort_dir = 1 if field . startswith ( \"-\" ): field = field [ 1 :] sort_dir = - 1 aliased_field = self . resource_mapper . alias_for ( field ) sort_spec . append (( aliased_field , sort_dir )) unknown_fields = [ field for field , _ in sort_spec if self . resource_mapper . alias_of ( field ) not in self . all_fields ] if unknown_fields : error_detail = \"Unable to sort on unknown field {} ' {} '\" . format ( \"s\" if len ( unknown_fields ) > 1 else \"\" , \"', '\" . join ( unknown_fields ), ) # If all unknown fields are \"other\" provider-specific, then only provide a warning if all ( ( re . match ( r \"_[a-z_0-9]+_[a-z_0-9]*\" , field ) and not field . startswith ( f \"_ { self . provider_prefix } _\" ) ) for field in unknown_fields ): warnings . warn ( error_detail , FieldValueNotRecognized ) # Otherwise, if all fields are unknown, or some fields are unknown and do not # have other provider prefixes, then return 400: Bad Request else : raise BadRequest ( detail = error_detail ) # If at least one valid field has been provided for sorting, then use that sort_spec = tuple ( ( field , sort_dir ) for field , sort_dir in sort_spec if field not in unknown_fields ) return sort_spec","title":"entry_collections"},{"location":"api_reference/server/entry_collections/entry_collections/#entry_collections","text":"","title":"entry_collections"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection","text":"Backend-agnostic base class for querying collections of EntryResource s.","title":"EntryCollection"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.all_fields","text":"Get the set of all fields handled in this collection, from attribute fields in the schema, provider fields and top-level OPTIMADE fields. Returns: Type Description set All fields handled in this collection.","title":"all_fields"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.__init__","text":"Initialize the collection for the given parameters. Parameters: Name Type Description Default collection The backend-specific collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required transformer Transformer The Lark Transformer used to interpret the filter. required Source code in optimade/server/entry_collections/entry_collections.py def __init__ ( self , collection , resource_cls : EntryResource , resource_mapper : BaseResourceMapper , transformer : Transformer , ): \"\"\"Initialize the collection for the given parameters. Parameters: collection: The backend-specific collection. resource_cls (EntryResource): The `EntryResource` model that is stored by the collection. resource_mapper (BaseResourceMapper): A resource mapper object that handles aliases and format changes between deserialization and response. transformer (Transformer): The Lark `Transformer` used to interpret the filter. \"\"\" self . collection = collection self . parser = LarkParser () self . resource_cls = resource_cls self . resource_mapper = resource_mapper self . transformer = transformer self . provider_prefix = CONFIG . provider . prefix self . provider_fields = CONFIG . provider_fields . get ( resource_mapper . ENDPOINT , [])","title":"__init__()"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.__len__","text":"Returns the total number of entries in the collection. Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def __len__ ( self ) -> int : \"\"\" Returns the total number of entries in the collection. \"\"\"","title":"__len__()"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.count","text":"Returns the number of entries matching the query specified by the keyword arguments. Parameters: Name Type Description Default kwargs dict Query parameters as keyword arguments. {} Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def count ( self , ** kwargs ) -> int : \"\"\"Returns the number of entries matching the query specified by the keyword arguments. Parameters: kwargs (dict): Query parameters as keyword arguments. \"\"\"","title":"count()"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.find","text":"Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit . See EntryListingQueryParams for more information. Parameters: Name Type Description Default params EntryListingQueryParams entry listing URL query params required Returns: Type Description Tuple[List[optimade.models.entries.EntryResource], int, bool, set] ( results , data_returned , more_data_available , fields ). Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def find ( self , params : EntryListingQueryParams ) -> Tuple [ List [ EntryResource ], int , bool , set ]: \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of `page_limit`. See [`EntryListingQueryParams`][optimade.server.query_params.EntryListingQueryParams] for more information. Parameters: params (EntryListingQueryParams): entry listing URL query params Returns: (`results`, `data_returned`, `more_data_available`, `fields`). \"\"\"","title":"find()"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.get_attribute_fields","text":"Get the set of attribute fields Return only the first-level attribute fields from the schema of the resource class, resolving references along the way if needed. Note It is not needed to take care of other special OpenAPI schema keys than allOf , since only allOf will be found in this context. Other special keys can be found in the Swagger documentation . Returns: Type Description set Property names. Source code in optimade/server/entry_collections/entry_collections.py def get_attribute_fields ( self ) -> set : \"\"\"Get the set of attribute fields Return only the _first-level_ attribute fields from the schema of the resource class, resolving references along the way if needed. Note: It is not needed to take care of other special OpenAPI schema keys than `allOf`, since only `allOf` will be found in this context. Other special keys can be found in [the Swagger documentation](https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/). Returns: Property names. \"\"\" schema = self . resource_cls . schema () attributes = schema [ \"properties\" ][ \"attributes\" ] if \"allOf\" in attributes : allOf = attributes . pop ( \"allOf\" ) for dict_ in allOf : attributes . update ( dict_ ) if \"$ref\" in attributes : path = attributes [ \"$ref\" ] . split ( \"/\" )[ 1 :] attributes = schema . copy () while path : next_key = path . pop ( 0 ) attributes = attributes [ next_key ] return set ( attributes [ \"properties\" ] . keys ())","title":"get_attribute_fields()"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.handle_query_params","text":"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] The initialized query parameter model from the server. required Exceptions: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description dict A dictionary representation of the query parameters, ready to be used by pymongo. Source code in optimade/server/entry_collections/entry_collections.py def handle_query_params ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> dict : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params (Union[EntryListingQueryParams, SingleEntryQueryParams]): The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters, ready to be used by pymongo. \"\"\" cursor_kwargs = {} if getattr ( params , \"filter\" , False ): tree = self . parser . parse ( params . filter ) cursor_kwargs [ \"filter\" ] = self . transformer . transform ( tree ) else : cursor_kwargs [ \"filter\" ] = {} if ( getattr ( params , \"response_format\" , False ) and params . response_format != \"json\" ): raise BadRequest ( detail = f \"Response format { params . response_format } is not supported, please use response_format='json'\" ) if getattr ( params , \"page_limit\" , False ): limit = params . page_limit if limit > CONFIG . page_limit_max : raise Forbidden ( detail = f \"Max allowed page_limit is { CONFIG . page_limit_max } , you requested { limit } \" , ) cursor_kwargs [ \"limit\" ] = limit else : cursor_kwargs [ \"limit\" ] = CONFIG . page_limit cursor_kwargs [ \"fields\" ] = self . all_fields cursor_kwargs [ \"projection\" ] = { f \" { self . resource_mapper . alias_for ( f ) } \" : True for f in self . all_fields } if \"_id\" not in cursor_kwargs [ \"projection\" ]: cursor_kwargs [ \"projection\" ][ \"_id\" ] = False if getattr ( params , \"sort\" , False ): cursor_kwargs [ \"sort\" ] = self . parse_sort_params ( params . sort ) if getattr ( params , \"page_offset\" , False ): cursor_kwargs [ \"skip\" ] = params . page_offset return cursor_kwargs","title":"handle_query_params()"},{"location":"api_reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.parse_sort_params","text":"Handles any sort parameters passed to the collection, resolving aliases and dealing with any invalid fields. Exceptions: Type Description BadRequest if an invalid sort is requested. Returns: Type Description List[Tuple[str, int]] A list of tuples containing the aliased field name and sort direction encoded as 1 (ascending) or -1 (descending). Source code in optimade/server/entry_collections/entry_collections.py def parse_sort_params ( self , sort_params ) -> List [ Tuple [ str , int ]]: \"\"\"Handles any sort parameters passed to the collection, resolving aliases and dealing with any invalid fields. Raises: BadRequest: if an invalid sort is requested. Returns: A list of tuples containing the aliased field name and sort direction encoded as 1 (ascending) or -1 (descending). \"\"\" sort_spec = [] for field in sort_params . split ( \",\" ): sort_dir = 1 if field . startswith ( \"-\" ): field = field [ 1 :] sort_dir = - 1 aliased_field = self . resource_mapper . alias_for ( field ) sort_spec . append (( aliased_field , sort_dir )) unknown_fields = [ field for field , _ in sort_spec if self . resource_mapper . alias_of ( field ) not in self . all_fields ] if unknown_fields : error_detail = \"Unable to sort on unknown field {} ' {} '\" . format ( \"s\" if len ( unknown_fields ) > 1 else \"\" , \"', '\" . join ( unknown_fields ), ) # If all unknown fields are \"other\" provider-specific, then only provide a warning if all ( ( re . match ( r \"_[a-z_0-9]+_[a-z_0-9]*\" , field ) and not field . startswith ( f \"_ { self . provider_prefix } _\" ) ) for field in unknown_fields ): warnings . warn ( error_detail , FieldValueNotRecognized ) # Otherwise, if all fields are unknown, or some fields are unknown and do not # have other provider prefixes, then return 400: Bad Request else : raise BadRequest ( detail = error_detail ) # If at least one valid field has been provided for sorting, then use that sort_spec = tuple ( ( field , sort_dir ) for field , sort_dir in sort_spec if field not in unknown_fields ) return sort_spec","title":"parse_sort_params()"},{"location":"api_reference/server/entry_collections/mongo/","text":"mongo \u00b6 MongoCollection ( EntryCollection ) \u00b6 Class for querying MongoDB collections (implemented by either pymongo or mongomock) containing serialized EntryResource s objects. __init__ ( self , collection , resource_cls , resource_mapper ) special \u00b6 Initialize the MongoCollection for the given parameters. Parameters: Name Type Description Default collection Union[pymongo.collection.Collection, mongomock.collection.Collection] The backend-specific collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required Source code in optimade/server/entry_collections/mongo.py def __init__ ( self , collection : Collection , resource_cls : EntryResource , resource_mapper : BaseResourceMapper , ): \"\"\"Initialize the MongoCollection for the given parameters. Parameters: collection (Union[pymongo.collection.Collection, mongomock.collection.Collection]): The backend-specific collection. resource_cls (EntryResource): The `EntryResource` model that is stored by the collection. resource_mapper (BaseResourceMapper): A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" super () . __init__ ( collection , resource_cls , resource_mapper , MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) # check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ()) count ( self , ** kwargs ) \u00b6 Returns the number of entries matching the query specified by the keyword arguments. Parameters: Name Type Description Default kwargs dict Query parameters as keyword arguments. The keys 'filter', 'skip', 'limit', 'hint' and 'maxTimeMS' will be passed to the pymongo.collection.Collection.count_documents method. {} Source code in optimade/server/entry_collections/mongo.py def count ( self , ** kwargs ) -> int : \"\"\"Returns the number of entries matching the query specified by the keyword arguments. Parameters: kwargs (dict): Query parameters as keyword arguments. The keys 'filter', 'skip', 'limit', 'hint' and 'maxTimeMS' will be passed to the `pymongo.collection.Collection.count_documents` method. \"\"\" for k in list ( kwargs . keys ()): if k not in ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" ): del kwargs [ k ] if \"filter\" not in kwargs : # \"filter\" is needed for count_documents() kwargs [ \"filter\" ] = {} return self . collection . count_documents ( ** kwargs ) find ( self , params ) \u00b6 Perform the query on the underlying MongoCollection, handling projection and pagination of the output. Returns: Type Description Tuple[List[EntryResource], int, bool, set] A list of entry resource objects, the number of returned entries, whether more are available with pagination, fields. Source code in optimade/server/entry_collections/mongo.py def find ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> Tuple [ List [ EntryResource ], int , bool , set ]: \"\"\"Perform the query on the underlying MongoCollection, handling projection and pagination of the output. Returns: Tuple[List[EntryResource], int, bool, set]: A list of entry resource objects, the number of returned entries, whether more are available with pagination, fields. \"\"\" criteria = self . handle_query_params ( params ) all_fields = criteria . pop ( \"fields\" ) if getattr ( params , \"response_fields\" , False ): fields = set ( params . response_fields . split ( \",\" )) fields |= self . resource_mapper . get_required_fields () else : fields = all_fields . copy () results = [] for doc in self . collection . find ( ** criteria ): if criteria . get ( \"projection\" , {}) . get ( \"_id\" ): doc [ \"_id\" ] = str ( doc [ \"_id\" ]) results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( doc ))) nresults_now = len ( results ) if isinstance ( params , EntryListingQueryParams ): criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) data_returned = self . count ( ** criteria_nolimit ) more_data_available = nresults_now < data_returned else : # SingleEntryQueryParams, e.g., /structures/{entry_id} data_returned = nresults_now more_data_available = False if nresults_now > 1 : raise HTTPException ( status_code = 404 , detail = f \"Instead of a single entry, { nresults_now } entries were found\" , ) results = results [ 0 ] if results else None return results , data_returned , more_data_available , all_fields - fields","title":"mongo"},{"location":"api_reference/server/entry_collections/mongo/#mongo","text":"","title":"mongo"},{"location":"api_reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection","text":"Class for querying MongoDB collections (implemented by either pymongo or mongomock) containing serialized EntryResource s objects.","title":"MongoCollection"},{"location":"api_reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection.__init__","text":"Initialize the MongoCollection for the given parameters. Parameters: Name Type Description Default collection Union[pymongo.collection.Collection, mongomock.collection.Collection] The backend-specific collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required Source code in optimade/server/entry_collections/mongo.py def __init__ ( self , collection : Collection , resource_cls : EntryResource , resource_mapper : BaseResourceMapper , ): \"\"\"Initialize the MongoCollection for the given parameters. Parameters: collection (Union[pymongo.collection.Collection, mongomock.collection.Collection]): The backend-specific collection. resource_cls (EntryResource): The `EntryResource` model that is stored by the collection. resource_mapper (BaseResourceMapper): A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" super () . __init__ ( collection , resource_cls , resource_mapper , MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) # check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ())","title":"__init__()"},{"location":"api_reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection.count","text":"Returns the number of entries matching the query specified by the keyword arguments. Parameters: Name Type Description Default kwargs dict Query parameters as keyword arguments. The keys 'filter', 'skip', 'limit', 'hint' and 'maxTimeMS' will be passed to the pymongo.collection.Collection.count_documents method. {} Source code in optimade/server/entry_collections/mongo.py def count ( self , ** kwargs ) -> int : \"\"\"Returns the number of entries matching the query specified by the keyword arguments. Parameters: kwargs (dict): Query parameters as keyword arguments. The keys 'filter', 'skip', 'limit', 'hint' and 'maxTimeMS' will be passed to the `pymongo.collection.Collection.count_documents` method. \"\"\" for k in list ( kwargs . keys ()): if k not in ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" ): del kwargs [ k ] if \"filter\" not in kwargs : # \"filter\" is needed for count_documents() kwargs [ \"filter\" ] = {} return self . collection . count_documents ( ** kwargs )","title":"count()"},{"location":"api_reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection.find","text":"Perform the query on the underlying MongoCollection, handling projection and pagination of the output. Returns: Type Description Tuple[List[EntryResource], int, bool, set] A list of entry resource objects, the number of returned entries, whether more are available with pagination, fields. Source code in optimade/server/entry_collections/mongo.py def find ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> Tuple [ List [ EntryResource ], int , bool , set ]: \"\"\"Perform the query on the underlying MongoCollection, handling projection and pagination of the output. Returns: Tuple[List[EntryResource], int, bool, set]: A list of entry resource objects, the number of returned entries, whether more are available with pagination, fields. \"\"\" criteria = self . handle_query_params ( params ) all_fields = criteria . pop ( \"fields\" ) if getattr ( params , \"response_fields\" , False ): fields = set ( params . response_fields . split ( \",\" )) fields |= self . resource_mapper . get_required_fields () else : fields = all_fields . copy () results = [] for doc in self . collection . find ( ** criteria ): if criteria . get ( \"projection\" , {}) . get ( \"_id\" ): doc [ \"_id\" ] = str ( doc [ \"_id\" ]) results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( doc ))) nresults_now = len ( results ) if isinstance ( params , EntryListingQueryParams ): criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) data_returned = self . count ( ** criteria_nolimit ) more_data_available = nresults_now < data_returned else : # SingleEntryQueryParams, e.g., /structures/{entry_id} data_returned = nresults_now more_data_available = False if nresults_now > 1 : raise HTTPException ( status_code = 404 , detail = f \"Instead of a single entry, { nresults_now } entries were found\" , ) results = results [ 0 ] if results else None return results , data_returned , more_data_available , all_fields - fields","title":"find()"},{"location":"api_reference/server/mappers/entries/","text":"entries \u00b6 BaseResourceMapper \u00b6 Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Attributes: Name Type Description ENDPOINT str defines the endpoint for which to apply this mapper. ALIASES Tuple[Tuple[str, str]] a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. ((\"elements\", \"custom_elements_field\")) . LENGTH_ALIASES Tuple[Tuple[str, str]] a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. ((\"elements\", \"nelements\")) . e.g. ((\"elements\", \"custom_elements_field\")) . PROVIDER_FIELDS Tuple[str] a tuple of extra field names that this mapper should support when querying with the database prefix. REQUIRED_FIELDS set[str] the set of fieldnames to return when mapping to the OPTIMADE format. TOP_LEVEL_NON_ATTRIBUTES_FIELDS set[str] the set of top-level field names common to all endpoints. alias_for ( field ) classmethod \u00b6 Return aliased field name. Parameters: Name Type Description Default field str OPTIMADE field name. required Returns: Type Description str Aliased field as found in all_aliases() . Source code in optimade/server/mappers/entries.py @classmethod def alias_for ( cls , field : str ) -> str : \"\"\"Return aliased field name. Parameters: field: OPTIMADE field name. Returns: Aliased field as found in [`all_aliases()`][optimade.server.mappers.entries.BaseResourceMapper.all_aliases]. \"\"\" split = field . split ( \".\" ) alias = dict ( cls . all_aliases ()) . get ( split [ 0 ], None ) if alias is not None : return alias + ( \".\" + \".\" . join ( split [ 1 :]) if len ( split ) > 1 else \"\" ) return field alias_of ( field ) classmethod \u00b6 Return de-aliased field name, if it exists, otherwise return the input field name. Parameters: Name Type Description Default field str Field name to be de-aliased. required Returns: Type Description str De-aliased field name, falling back to returning field . Source code in optimade/server/mappers/entries.py @classmethod def alias_of ( cls , field : str ) -> str : \"\"\"Return de-aliased field name, if it exists, otherwise return the input field name. Args: field: Field name to be de-aliased. Returns: De-aliased field name, falling back to returning `field`. \"\"\" field = field . split ( \".\" )[ 0 ] return { alias : real for real , alias in cls . all_aliases ()} . get ( field , field ) all_aliases () classmethod \u00b6 Returns all of the associated aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] A tuple of alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\"Returns all of the associated aliases for this class, including those defined by the server config. Returns: A tuple of alias tuples. \"\"\" from optimade.server.config import CONFIG return ( tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in CONFIG . provider_fields . get ( cls . ENDPOINT , []) ) + tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in cls . PROVIDER_FIELDS ) + tuple ( CONFIG . aliases . get ( cls . ENDPOINT , {}) . items ()) + cls . ALIASES ) all_length_aliases () classmethod \u00b6 Returns all of the associated length aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] A tuple of length alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_length_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\"Returns all of the associated length aliases for this class, including those defined by the server config. Returns: A tuple of length alias tuples. \"\"\" from optimade.server.config import CONFIG return cls . LENGTH_ALIASES + tuple ( CONFIG . length_aliases . get ( cls . ENDPOINT , {}) . items () ) get_required_fields () classmethod \u00b6 Get REQUIRED response fields. Returns: Type Description set REQUIRED response fields. Source code in optimade/server/mappers/entries.py @classmethod def get_required_fields ( cls ) -> set : \"\"\"Get REQUIRED response fields. Returns: REQUIRED response fields. \"\"\" res = cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS . copy () res . update ( cls . REQUIRED_FIELDS ) return res length_alias_for ( field ) classmethod \u00b6 Returns the length alias for the particular field, or None if no such alias is found. Parameters: Name Type Description Default field str OPTIMADE field name. required Returns: Type Description Optional[str] Aliased field as found in all_length_aliases() . Source code in optimade/server/mappers/entries.py @classmethod def length_alias_for ( cls , field : str ) -> Optional [ str ]: \"\"\"Returns the length alias for the particular field, or `None` if no such alias is found. Parameters: field: OPTIMADE field name. Returns: Aliased field as found in [`all_length_aliases()`][optimade.server.mappers.entries.BaseResourceMapper.all_length_aliases]. \"\"\" return dict ( cls . all_length_aliases ()) . get ( field , None ) map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . Parameters: Name Type Description Default doc dict A resource object in MongoDB format. required Returns: Type Description dict A resource object in OPTIMADE format. Source code in optimade/server/mappers/entries.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document `doc`, map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in `cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS`. All fields not in `cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS` + \"attributes\" will be removed. Finally, the `type` is given the value of the specified `cls.ENDPOINT`. Parameters: doc: A resource object in MongoDB format. Returns: A resource object in OPTIMADE format. \"\"\" mapping = (( real , alias ) for alias , real in cls . all_aliases ()) newdoc = {} reals = { real for alias , real in cls . all_aliases ()} for key in doc : if key not in reals : newdoc [ key ] = doc [ key ] for real , alias in mapping : if real in doc : newdoc [ alias ] = doc [ real ] if \"attributes\" in newdoc : raise Exception ( \"Will overwrite doc field!\" ) attributes = newdoc . copy () for field in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : value = attributes . pop ( field , None ) if value is not None : newdoc [ field ] = value for field in list ( newdoc . keys ()): if field not in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : del newdoc [ field ] newdoc [ \"type\" ] = cls . ENDPOINT newdoc [ \"attributes\" ] = attributes return newdoc","title":"entries"},{"location":"api_reference/server/mappers/entries/#entries","text":"","title":"entries"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper","text":"Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Attributes: Name Type Description ENDPOINT str defines the endpoint for which to apply this mapper. ALIASES Tuple[Tuple[str, str]] a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. ((\"elements\", \"custom_elements_field\")) . LENGTH_ALIASES Tuple[Tuple[str, str]] a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. ((\"elements\", \"nelements\")) . e.g. ((\"elements\", \"custom_elements_field\")) . PROVIDER_FIELDS Tuple[str] a tuple of extra field names that this mapper should support when querying with the database prefix. REQUIRED_FIELDS set[str] the set of fieldnames to return when mapping to the OPTIMADE format. TOP_LEVEL_NON_ATTRIBUTES_FIELDS set[str] the set of top-level field names common to all endpoints.","title":"BaseResourceMapper"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.alias_for","text":"Return aliased field name. Parameters: Name Type Description Default field str OPTIMADE field name. required Returns: Type Description str Aliased field as found in all_aliases() . Source code in optimade/server/mappers/entries.py @classmethod def alias_for ( cls , field : str ) -> str : \"\"\"Return aliased field name. Parameters: field: OPTIMADE field name. Returns: Aliased field as found in [`all_aliases()`][optimade.server.mappers.entries.BaseResourceMapper.all_aliases]. \"\"\" split = field . split ( \".\" ) alias = dict ( cls . all_aliases ()) . get ( split [ 0 ], None ) if alias is not None : return alias + ( \".\" + \".\" . join ( split [ 1 :]) if len ( split ) > 1 else \"\" ) return field","title":"alias_for()"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.alias_of","text":"Return de-aliased field name, if it exists, otherwise return the input field name. Parameters: Name Type Description Default field str Field name to be de-aliased. required Returns: Type Description str De-aliased field name, falling back to returning field . Source code in optimade/server/mappers/entries.py @classmethod def alias_of ( cls , field : str ) -> str : \"\"\"Return de-aliased field name, if it exists, otherwise return the input field name. Args: field: Field name to be de-aliased. Returns: De-aliased field name, falling back to returning `field`. \"\"\" field = field . split ( \".\" )[ 0 ] return { alias : real for real , alias in cls . all_aliases ()} . get ( field , field )","title":"alias_of()"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.all_aliases","text":"Returns all of the associated aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] A tuple of alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\"Returns all of the associated aliases for this class, including those defined by the server config. Returns: A tuple of alias tuples. \"\"\" from optimade.server.config import CONFIG return ( tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in CONFIG . provider_fields . get ( cls . ENDPOINT , []) ) + tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in cls . PROVIDER_FIELDS ) + tuple ( CONFIG . aliases . get ( cls . ENDPOINT , {}) . items ()) + cls . ALIASES )","title":"all_aliases()"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.all_length_aliases","text":"Returns all of the associated length aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] A tuple of length alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_length_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\"Returns all of the associated length aliases for this class, including those defined by the server config. Returns: A tuple of length alias tuples. \"\"\" from optimade.server.config import CONFIG return cls . LENGTH_ALIASES + tuple ( CONFIG . length_aliases . get ( cls . ENDPOINT , {}) . items () )","title":"all_length_aliases()"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.get_required_fields","text":"Get REQUIRED response fields. Returns: Type Description set REQUIRED response fields. Source code in optimade/server/mappers/entries.py @classmethod def get_required_fields ( cls ) -> set : \"\"\"Get REQUIRED response fields. Returns: REQUIRED response fields. \"\"\" res = cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS . copy () res . update ( cls . REQUIRED_FIELDS ) return res","title":"get_required_fields()"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.length_alias_for","text":"Returns the length alias for the particular field, or None if no such alias is found. Parameters: Name Type Description Default field str OPTIMADE field name. required Returns: Type Description Optional[str] Aliased field as found in all_length_aliases() . Source code in optimade/server/mappers/entries.py @classmethod def length_alias_for ( cls , field : str ) -> Optional [ str ]: \"\"\"Returns the length alias for the particular field, or `None` if no such alias is found. Parameters: field: OPTIMADE field name. Returns: Aliased field as found in [`all_length_aliases()`][optimade.server.mappers.entries.BaseResourceMapper.all_length_aliases]. \"\"\" return dict ( cls . all_length_aliases ()) . get ( field , None )","title":"length_alias_for()"},{"location":"api_reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.map_back","text":"Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . Parameters: Name Type Description Default doc dict A resource object in MongoDB format. required Returns: Type Description dict A resource object in OPTIMADE format. Source code in optimade/server/mappers/entries.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document `doc`, map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in `cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS`. All fields not in `cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS` + \"attributes\" will be removed. Finally, the `type` is given the value of the specified `cls.ENDPOINT`. Parameters: doc: A resource object in MongoDB format. Returns: A resource object in OPTIMADE format. \"\"\" mapping = (( real , alias ) for alias , real in cls . all_aliases ()) newdoc = {} reals = { real for alias , real in cls . all_aliases ()} for key in doc : if key not in reals : newdoc [ key ] = doc [ key ] for real , alias in mapping : if real in doc : newdoc [ alias ] = doc [ real ] if \"attributes\" in newdoc : raise Exception ( \"Will overwrite doc field!\" ) attributes = newdoc . copy () for field in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : value = attributes . pop ( field , None ) if value is not None : newdoc [ field ] = value for field in list ( newdoc . keys ()): if field not in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : del newdoc [ field ] newdoc [ \"type\" ] = cls . ENDPOINT newdoc [ \"attributes\" ] = attributes return newdoc","title":"map_back()"},{"location":"api_reference/server/mappers/links/","text":"links \u00b6 LinksMapper ( BaseResourceMapper ) \u00b6 map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade/server/mappers/links.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict \"\"\" type_ = doc [ \"type\" ] newdoc = super () . map_back ( doc ) newdoc [ \"type\" ] = type_ return newdoc","title":"links"},{"location":"api_reference/server/mappers/links/#links","text":"","title":"links"},{"location":"api_reference/server/mappers/links/#optimade.server.mappers.links.LinksMapper","text":"","title":"LinksMapper"},{"location":"api_reference/server/mappers/links/#optimade.server.mappers.links.LinksMapper.map_back","text":"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade/server/mappers/links.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict \"\"\" type_ = doc [ \"type\" ] newdoc = super () . map_back ( doc ) newdoc [ \"type\" ] = type_ return newdoc","title":"map_back()"},{"location":"api_reference/server/mappers/references/","text":"references \u00b6","title":"references"},{"location":"api_reference/server/mappers/references/#references","text":"","title":"references"},{"location":"api_reference/server/mappers/structures/","text":"structures \u00b6","title":"structures"},{"location":"api_reference/server/mappers/structures/#structures","text":"","title":"structures"},{"location":"api_reference/server/routers/index_info/","text":"index_info \u00b6","title":"index_info"},{"location":"api_reference/server/routers/index_info/#index_info","text":"","title":"index_info"},{"location":"api_reference/server/routers/info/","text":"info \u00b6","title":"info"},{"location":"api_reference/server/routers/info/#info","text":"","title":"info"},{"location":"api_reference/server/routers/landing/","text":"landing \u00b6 OPTIMADE landing page, rendered as a Jinja2 template. landing ( request ) async \u00b6 Show a human-readable landing page when the base URL is accessed. Source code in optimade/server/routers/landing.py async def landing ( request : Request ): \"\"\" Show a human-readable landing page when the base URL is accessed. \"\"\" meta = meta_values ( request . url , 1 , 1 , more_data_available = False ) major_version = __api_version__ . split ( \".\" )[ 0 ] versioned_url = f \" { get_base_url ( request . url ) } /v { major_version } /\" context = { \"request\" : request , \"request_url\" : request . url , \"api_version\" : __api_version__ , \"implementation\" : meta . implementation , \"versioned_url\" : versioned_url , \"provider\" : meta . provider , \"index_base_url\" : CONFIG . index_base_url , \"endpoints\" : list ( ENTRY_COLLECTIONS . keys ()) + [ \"info\" ], } return TEMPLATES . TemplateResponse ( \"landing_page.html\" , context )","title":"landing"},{"location":"api_reference/server/routers/landing/#landing","text":"OPTIMADE landing page, rendered as a Jinja2 template.","title":"landing"},{"location":"api_reference/server/routers/landing/#optimade.server.routers.landing.landing","text":"Show a human-readable landing page when the base URL is accessed. Source code in optimade/server/routers/landing.py async def landing ( request : Request ): \"\"\" Show a human-readable landing page when the base URL is accessed. \"\"\" meta = meta_values ( request . url , 1 , 1 , more_data_available = False ) major_version = __api_version__ . split ( \".\" )[ 0 ] versioned_url = f \" { get_base_url ( request . url ) } /v { major_version } /\" context = { \"request\" : request , \"request_url\" : request . url , \"api_version\" : __api_version__ , \"implementation\" : meta . implementation , \"versioned_url\" : versioned_url , \"provider\" : meta . provider , \"index_base_url\" : CONFIG . index_base_url , \"endpoints\" : list ( ENTRY_COLLECTIONS . keys ()) + [ \"info\" ], } return TEMPLATES . TemplateResponse ( \"landing_page.html\" , context )","title":"landing()"},{"location":"api_reference/server/routers/links/","text":"links \u00b6","title":"links"},{"location":"api_reference/server/routers/links/#links","text":"","title":"links"},{"location":"api_reference/server/routers/references/","text":"references \u00b6","title":"references"},{"location":"api_reference/server/routers/references/#references","text":"","title":"references"},{"location":"api_reference/server/routers/structures/","text":"structures \u00b6","title":"structures"},{"location":"api_reference/server/routers/structures/#structures","text":"","title":"structures"},{"location":"api_reference/server/routers/utils/","text":"utils \u00b6 get_base_url ( parsed_url_request ) \u00b6 Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. Source code in optimade/server/routers/utils.py def get_base_url ( parsed_url_request : Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ] ) -> str : \"\"\"Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. \"\"\" parsed_url_request = ( urllib . parse . urlparse ( parsed_url_request ) if isinstance ( parsed_url_request , str ) else parsed_url_request ) return ( CONFIG . base_url . rstrip ( \"/\" ) if CONFIG . base_url else f \" { parsed_url_request . scheme } :// { parsed_url_request . netloc } \" ) get_entries ( collection , response , request , params ) \u00b6 Generalized /{entry} endpoint getter Source code in optimade/server/routers/utils.py def get_entries ( collection : EntryCollection , response : EntryResponseMany , request : Request , params : EntryListingQueryParams , ) -> EntryResponseMany : \"\"\"Generalized /{entry} endpoint getter\"\"\" from optimade.server.routers import ENTRY_COLLECTIONS results , data_returned , more_data_available , fields = collection . find ( params ) include = [] if getattr ( params , \"include\" , False ): include . extend ( params . include . split ( \",\" )) included = get_included_relationships ( results , ENTRY_COLLECTIONS , include ) if more_data_available : # Deduce the `next` link from the current request query = urllib . parse . parse_qs ( request . url . query ) query [ \"page_offset\" ] = int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results ) urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( request . url ) links = ToplevelLinks ( next = f \" { base_url }{ request . url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields : results = handle_response_fields ( results , fields ) return response ( links = links , data = results , meta = meta_values ( url = request . url , data_returned = data_returned , data_available = len ( collection ), more_data_available = more_data_available , ), included = included , ) get_included_relationships ( results , ENTRY_COLLECTIONS , include_param ) \u00b6 Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: Name Type Description Default results Union[optimade.models.entries.EntryResource, List[optimade.models.entries.EntryResource]] list of returned documents. required ENTRY_COLLECTIONS Dict[str, optimade.server.entry_collections.entry_collections.EntryCollection] dictionary containing collections to query, with key based on endpoint type. required include_param List[str] list of queried related resources that should be included in included . required Returns: Type Description Dict[str, List[optimade.models.entries.EntryResource]] Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. Source code in optimade/server/routers/utils.py def get_included_relationships ( results : Union [ EntryResource , List [ EntryResource ]], ENTRY_COLLECTIONS : Dict [ str , EntryCollection ], include_param : List [ str ], ) -> Dict [ str , List [ EntryResource ]]: \"\"\"Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: results: list of returned documents. ENTRY_COLLECTIONS: dictionary containing collections to query, with key based on endpoint type. include_param: list of queried related resources that should be included in `included`. Returns: Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. \"\"\" from collections import defaultdict if not isinstance ( results , list ): results = [ results ] for entry_type in include_param : if entry_type not in ENTRY_COLLECTIONS and entry_type != \"\" : raise BadRequest ( detail = f \"' { entry_type } ' cannot be identified as a valid relationship type. \" f \"Known relationship types: { sorted ( ENTRY_COLLECTIONS . keys ()) } \" ) endpoint_includes = defaultdict ( dict ) for doc in results : # convert list of references into dict by ID to only included unique IDs if doc is None : continue relationships = doc . relationships if relationships is None : continue relationships = relationships . dict () for entry_type in ENTRY_COLLECTIONS : # Skip entry type if it is not in `include_param` if entry_type not in include_param : continue entry_relationship = relationships . get ( entry_type , {}) if entry_relationship is not None : refs = entry_relationship . get ( \"data\" , []) for ref in refs : if ref [ \"id\" ] not in endpoint_includes [ entry_type ]: endpoint_includes [ entry_type ][ ref [ \"id\" ]] = ref included = {} for entry_type in endpoint_includes : compound_filter = \" OR \" . join ( [ 'id=\" {} \"' . format ( ref_id ) for ref_id in endpoint_includes [ entry_type ]] ) params = EntryListingQueryParams ( filter = compound_filter , response_format = \"json\" , response_fields = None , sort = None , page_limit = 0 , page_offset = 0 , ) # still need to handle pagination ref_results , _ , _ , _ = ENTRY_COLLECTIONS [ entry_type ] . find ( params ) included [ entry_type ] = ref_results # flatten dict by endpoint to list return [ obj for endp in included . values () for obj in endp ] get_providers () \u00b6 Retrieve Materials-Consortia providers (from https://providers.optimade.org/v1/links). Fallback order if providers.optimade.org is not available: Try Materials-Consortia/providers on GitHub. Try submodule providers ' list of providers. Log warning that providers list from Materials-Consortia is not included in the /links -endpoint. Returns: Type Description list List of raw JSON-decoded providers including MongoDB object IDs. Source code in optimade/server/routers/utils.py def get_providers () -> list : \"\"\"Retrieve Materials-Consortia providers (from https://providers.optimade.org/v1/links). Fallback order if providers.optimade.org is not available: 1. Try Materials-Consortia/providers on GitHub. 2. Try submodule `providers`' list of providers. 3. Log warning that providers list from Materials-Consortia is not included in the `/links`-endpoint. Returns: List of raw JSON-decoded providers including MongoDB object IDs. \"\"\" import requests try : import simplejson as json except ImportError : import json provider_list_urls = [ \"https://providers.optimade.org/v1/links\" , \"https://raw.githubusercontent.com/Materials-Consortia/providers\" \"/master/src/links/v1/providers.json\" , ] for provider_list_url in provider_list_urls : try : providers = requests . get ( provider_list_url ) . json () except ( requests . exceptions . ConnectionError , requests . exceptions . ConnectTimeout , json . JSONDecodeError , ): pass else : break else : try : from optimade.server.data import providers except ImportError : from optimade.server.logger import LOGGER LOGGER . warning ( \"\"\"Could not retrieve a list of providers! Tried the following resources: {} The list of providers will not be included in the `/links`-endpoint. \"\"\" . format ( \"\" . join ([ f \" * { _ } \\n \" for _ in provider_list_urls ]) ) ) return [] providers_list = [] for provider in providers . get ( \"data\" , []): # Remove/skip \"exmpl\" if provider [ \"id\" ] == \"exmpl\" : continue provider . update ( provider . pop ( \"attributes\" , {})) # Add MongoDB ObjectId provider [ \"_id\" ] = { \"$oid\" : mongo_id_for_database ( provider [ \"id\" ], provider [ \"type\" ]) } providers_list . append ( provider ) return providers_list handle_response_fields ( results , exclude_fields ) \u00b6 Handle query parameter response_fields It is assumed that all fields are under attributes . This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under attributes to be excluded from the response. Source code in optimade/server/routers/utils.py def handle_response_fields ( results : Union [ List [ EntryResource ], EntryResource ], exclude_fields : set ) -> dict : \"\"\"Handle query parameter ``response_fields`` It is assumed that all fields are under ``attributes``. This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under ``attributes`` to be excluded from the response. \"\"\" if not isinstance ( results , list ): results = [ results ] new_results = [] while results : entry = results . pop ( 0 ) # TODO: re-enable exclude_unset when proper handling of known/unknown fields # has been implemented (relevant issue: https://github.com/Materials-Consortia/optimade-python-tools/issues/263) # Have to handle top level fields explicitly here for now new_entry = entry . dict ( exclude_unset = False ) for field in ( \"relationships\" , \"links\" , \"meta\" , \"type\" , \"id\" ): if field in new_entry and new_entry [ field ] is None : del new_entry [ field ] for field in exclude_fields : if field in new_entry [ \"attributes\" ]: del new_entry [ \"attributes\" ][ field ] new_results . append ( new_entry ) return new_results meta_values ( url , data_returned , data_available , more_data_available , ** kwargs ) \u00b6 Helper to initialize the meta values Source code in optimade/server/routers/utils.py def meta_values ( url : Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ], data_returned : int , data_available : int , more_data_available : bool , ** kwargs , ) -> ResponseMeta : \"\"\"Helper to initialize the meta values\"\"\" from optimade.models import ResponseMetaQuery if isinstance ( url , str ): url = urllib . parse . urlparse ( url ) # To catch all (valid) variations of the version part of the URL, a regex is used if re . match ( r \"/v[0-9]+(\\.[0-9]+){,2}/.*\" , url . path ) is not None : url_path = re . sub ( r \"/v[0-9]+(\\.[0-9]+){,2}/\" , \"/\" , url . path ) else : url_path = url . path return ResponseMeta ( query = ResponseMetaQuery ( representation = f \" { url_path } ? { url . query } \" ), api_version = __api_version__ , time_stamp = datetime . now (), data_returned = data_returned , more_data_available = more_data_available , provider = CONFIG . provider , data_available = data_available , implementation = CONFIG . implementation , ** kwargs , ) mongo_id_for_database ( database_id , database_type ) \u00b6 Produce a MondoDB ObjectId for a database Source code in optimade/server/routers/utils.py def mongo_id_for_database ( database_id : str , database_type : str ) -> str : \"\"\"Produce a MondoDB ObjectId for a database\"\"\" from bson.objectid import ObjectId oid = f \" { database_id }{ database_type } \" if len ( oid ) > 12 : oid = oid [: 12 ] elif len ( oid ) < 12 : oid = f \" { oid }{ '0' * ( 12 - len ( oid )) } \" return str ( ObjectId ( oid . encode ( \"UTF-8\" )))","title":"utils"},{"location":"api_reference/server/routers/utils/#utils","text":"","title":"utils"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.get_base_url","text":"Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. Source code in optimade/server/routers/utils.py def get_base_url ( parsed_url_request : Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ] ) -> str : \"\"\"Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. \"\"\" parsed_url_request = ( urllib . parse . urlparse ( parsed_url_request ) if isinstance ( parsed_url_request , str ) else parsed_url_request ) return ( CONFIG . base_url . rstrip ( \"/\" ) if CONFIG . base_url else f \" { parsed_url_request . scheme } :// { parsed_url_request . netloc } \" )","title":"get_base_url()"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.get_entries","text":"Generalized /{entry} endpoint getter Source code in optimade/server/routers/utils.py def get_entries ( collection : EntryCollection , response : EntryResponseMany , request : Request , params : EntryListingQueryParams , ) -> EntryResponseMany : \"\"\"Generalized /{entry} endpoint getter\"\"\" from optimade.server.routers import ENTRY_COLLECTIONS results , data_returned , more_data_available , fields = collection . find ( params ) include = [] if getattr ( params , \"include\" , False ): include . extend ( params . include . split ( \",\" )) included = get_included_relationships ( results , ENTRY_COLLECTIONS , include ) if more_data_available : # Deduce the `next` link from the current request query = urllib . parse . parse_qs ( request . url . query ) query [ \"page_offset\" ] = int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results ) urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( request . url ) links = ToplevelLinks ( next = f \" { base_url }{ request . url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields : results = handle_response_fields ( results , fields ) return response ( links = links , data = results , meta = meta_values ( url = request . url , data_returned = data_returned , data_available = len ( collection ), more_data_available = more_data_available , ), included = included , )","title":"get_entries()"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.get_included_relationships","text":"Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: Name Type Description Default results Union[optimade.models.entries.EntryResource, List[optimade.models.entries.EntryResource]] list of returned documents. required ENTRY_COLLECTIONS Dict[str, optimade.server.entry_collections.entry_collections.EntryCollection] dictionary containing collections to query, with key based on endpoint type. required include_param List[str] list of queried related resources that should be included in included . required Returns: Type Description Dict[str, List[optimade.models.entries.EntryResource]] Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. Source code in optimade/server/routers/utils.py def get_included_relationships ( results : Union [ EntryResource , List [ EntryResource ]], ENTRY_COLLECTIONS : Dict [ str , EntryCollection ], include_param : List [ str ], ) -> Dict [ str , List [ EntryResource ]]: \"\"\"Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: results: list of returned documents. ENTRY_COLLECTIONS: dictionary containing collections to query, with key based on endpoint type. include_param: list of queried related resources that should be included in `included`. Returns: Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. \"\"\" from collections import defaultdict if not isinstance ( results , list ): results = [ results ] for entry_type in include_param : if entry_type not in ENTRY_COLLECTIONS and entry_type != \"\" : raise BadRequest ( detail = f \"' { entry_type } ' cannot be identified as a valid relationship type. \" f \"Known relationship types: { sorted ( ENTRY_COLLECTIONS . keys ()) } \" ) endpoint_includes = defaultdict ( dict ) for doc in results : # convert list of references into dict by ID to only included unique IDs if doc is None : continue relationships = doc . relationships if relationships is None : continue relationships = relationships . dict () for entry_type in ENTRY_COLLECTIONS : # Skip entry type if it is not in `include_param` if entry_type not in include_param : continue entry_relationship = relationships . get ( entry_type , {}) if entry_relationship is not None : refs = entry_relationship . get ( \"data\" , []) for ref in refs : if ref [ \"id\" ] not in endpoint_includes [ entry_type ]: endpoint_includes [ entry_type ][ ref [ \"id\" ]] = ref included = {} for entry_type in endpoint_includes : compound_filter = \" OR \" . join ( [ 'id=\" {} \"' . format ( ref_id ) for ref_id in endpoint_includes [ entry_type ]] ) params = EntryListingQueryParams ( filter = compound_filter , response_format = \"json\" , response_fields = None , sort = None , page_limit = 0 , page_offset = 0 , ) # still need to handle pagination ref_results , _ , _ , _ = ENTRY_COLLECTIONS [ entry_type ] . find ( params ) included [ entry_type ] = ref_results # flatten dict by endpoint to list return [ obj for endp in included . values () for obj in endp ]","title":"get_included_relationships()"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.get_providers","text":"Retrieve Materials-Consortia providers (from https://providers.optimade.org/v1/links). Fallback order if providers.optimade.org is not available: Try Materials-Consortia/providers on GitHub. Try submodule providers ' list of providers. Log warning that providers list from Materials-Consortia is not included in the /links -endpoint. Returns: Type Description list List of raw JSON-decoded providers including MongoDB object IDs. Source code in optimade/server/routers/utils.py def get_providers () -> list : \"\"\"Retrieve Materials-Consortia providers (from https://providers.optimade.org/v1/links). Fallback order if providers.optimade.org is not available: 1. Try Materials-Consortia/providers on GitHub. 2. Try submodule `providers`' list of providers. 3. Log warning that providers list from Materials-Consortia is not included in the `/links`-endpoint. Returns: List of raw JSON-decoded providers including MongoDB object IDs. \"\"\" import requests try : import simplejson as json except ImportError : import json provider_list_urls = [ \"https://providers.optimade.org/v1/links\" , \"https://raw.githubusercontent.com/Materials-Consortia/providers\" \"/master/src/links/v1/providers.json\" , ] for provider_list_url in provider_list_urls : try : providers = requests . get ( provider_list_url ) . json () except ( requests . exceptions . ConnectionError , requests . exceptions . ConnectTimeout , json . JSONDecodeError , ): pass else : break else : try : from optimade.server.data import providers except ImportError : from optimade.server.logger import LOGGER LOGGER . warning ( \"\"\"Could not retrieve a list of providers! Tried the following resources: {} The list of providers will not be included in the `/links`-endpoint. \"\"\" . format ( \"\" . join ([ f \" * { _ } \\n \" for _ in provider_list_urls ]) ) ) return [] providers_list = [] for provider in providers . get ( \"data\" , []): # Remove/skip \"exmpl\" if provider [ \"id\" ] == \"exmpl\" : continue provider . update ( provider . pop ( \"attributes\" , {})) # Add MongoDB ObjectId provider [ \"_id\" ] = { \"$oid\" : mongo_id_for_database ( provider [ \"id\" ], provider [ \"type\" ]) } providers_list . append ( provider ) return providers_list","title":"get_providers()"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.handle_response_fields","text":"Handle query parameter response_fields It is assumed that all fields are under attributes . This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under attributes to be excluded from the response. Source code in optimade/server/routers/utils.py def handle_response_fields ( results : Union [ List [ EntryResource ], EntryResource ], exclude_fields : set ) -> dict : \"\"\"Handle query parameter ``response_fields`` It is assumed that all fields are under ``attributes``. This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under ``attributes`` to be excluded from the response. \"\"\" if not isinstance ( results , list ): results = [ results ] new_results = [] while results : entry = results . pop ( 0 ) # TODO: re-enable exclude_unset when proper handling of known/unknown fields # has been implemented (relevant issue: https://github.com/Materials-Consortia/optimade-python-tools/issues/263) # Have to handle top level fields explicitly here for now new_entry = entry . dict ( exclude_unset = False ) for field in ( \"relationships\" , \"links\" , \"meta\" , \"type\" , \"id\" ): if field in new_entry and new_entry [ field ] is None : del new_entry [ field ] for field in exclude_fields : if field in new_entry [ \"attributes\" ]: del new_entry [ \"attributes\" ][ field ] new_results . append ( new_entry ) return new_results","title":"handle_response_fields()"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.meta_values","text":"Helper to initialize the meta values Source code in optimade/server/routers/utils.py def meta_values ( url : Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ], data_returned : int , data_available : int , more_data_available : bool , ** kwargs , ) -> ResponseMeta : \"\"\"Helper to initialize the meta values\"\"\" from optimade.models import ResponseMetaQuery if isinstance ( url , str ): url = urllib . parse . urlparse ( url ) # To catch all (valid) variations of the version part of the URL, a regex is used if re . match ( r \"/v[0-9]+(\\.[0-9]+){,2}/.*\" , url . path ) is not None : url_path = re . sub ( r \"/v[0-9]+(\\.[0-9]+){,2}/\" , \"/\" , url . path ) else : url_path = url . path return ResponseMeta ( query = ResponseMetaQuery ( representation = f \" { url_path } ? { url . query } \" ), api_version = __api_version__ , time_stamp = datetime . now (), data_returned = data_returned , more_data_available = more_data_available , provider = CONFIG . provider , data_available = data_available , implementation = CONFIG . implementation , ** kwargs , )","title":"meta_values()"},{"location":"api_reference/server/routers/utils/#optimade.server.routers.utils.mongo_id_for_database","text":"Produce a MondoDB ObjectId for a database Source code in optimade/server/routers/utils.py def mongo_id_for_database ( database_id : str , database_type : str ) -> str : \"\"\"Produce a MondoDB ObjectId for a database\"\"\" from bson.objectid import ObjectId oid = f \" { database_id }{ database_type } \" if len ( oid ) > 12 : oid = oid [: 12 ] elif len ( oid ) < 12 : oid = f \" { oid }{ '0' * ( 12 - len ( oid )) } \" return str ( ObjectId ( oid . encode ( \"UTF-8\" )))","title":"mongo_id_for_database()"},{"location":"api_reference/server/routers/versions/","text":"versions \u00b6 get_versions ( request ) \u00b6 Respond with the text/csv representation for the served versions. Source code in optimade/server/routers/versions.py @router . get ( \"/versions\" , tags = [ \"Versions\" ], response_class = CsvResponse , ) def get_versions ( request : Request ): \"\"\"Respond with the text/csv representation for the served versions.\"\"\" version = BASE_URL_PREFIXES [ \"major\" ] . replace ( \"/v\" , \"\" ) response = f \"version \\n { version } \" return CsvResponse ( content = response )","title":"versions"},{"location":"api_reference/server/routers/versions/#versions","text":"","title":"versions"},{"location":"api_reference/server/routers/versions/#optimade.server.routers.versions.get_versions","text":"Respond with the text/csv representation for the served versions. Source code in optimade/server/routers/versions.py @router . get ( \"/versions\" , tags = [ \"Versions\" ], response_class = CsvResponse , ) def get_versions ( request : Request ): \"\"\"Respond with the text/csv representation for the served versions.\"\"\" version = BASE_URL_PREFIXES [ \"major\" ] . replace ( \"/v\" , \"\" ) response = f \"version \\n { version } \" return CsvResponse ( content = response )","title":"get_versions()"},{"location":"api_reference/validator/config/","text":"config \u00b6 This submodule defines constant values and definitions from the OPTIMADE specification for use by the validator. The VALIDATOR_CONFIG object can be imported and modified before calling the validator inside a Python script to customise the hardcoded values. ValidatorConfig ( BaseSettings ) pydantic-model \u00b6 This class stores validator config parameters in a way that can be easily modified for testing niche implementations. Many of these fields are determined by the specification directly, but it may be desirable to modify them in certain cases. entry_schemas : Dict [ str , Any ] pydantic-field \u00b6 The entry listing endpoint schemas enum_fallback_values : Dict [ str , Dict [ str , List [ str ]]] pydantic-field \u00b6 Provide fallback values for enum fields to use when validating filters. exclusive_operators : Dict [ optimade . models . optimade_json . DataType , Set [ str ]] pydantic-field \u00b6 Dictionary mapping OPTIMADE DataType s to a list of operators that are 'exclusive', i.e. those that should not return entries with the matching value from the filter. inclusive_operators : Dict [ optimade . models . optimade_json . DataType , Set [ str ]] pydantic-field \u00b6 Dictionary mapping OPTIMADE DataType s to a list of operators that are 'inclusive', i.e. those that should return entries with the matching value from the filter. info_endpoint : str pydantic-field \u00b6 The name of the info endpoint links_endpoint : str pydantic-field \u00b6 The name of the links endpoint non_entry_endpoints : Set [ str ] pydantic-field \u00b6 The list specification-mandated endpoint names that do not contain entries response_classes : Dict [ str , Any ] pydantic-field \u00b6 Dictionary containing the mapping between endpoints and response classes for the main database response_classes_index : Dict [ str , Any ] pydantic-field \u00b6 Dictionary containing the mapping between endpoints and response classes for the index meta-database top_level_non_attribute_fields : Set [ str ] pydantic-field \u00b6 Field names to treat as top-level unique_properties : Set [ str ] pydantic-field \u00b6 Fields that should be treated as unique indexes for all endpoints, i.e. fields on which filters should return at most one entry. versions_endpoint : str pydantic-field \u00b6 The name of the versions endpoint","title":"config"},{"location":"api_reference/validator/config/#config","text":"This submodule defines constant values and definitions from the OPTIMADE specification for use by the validator. The VALIDATOR_CONFIG object can be imported and modified before calling the validator inside a Python script to customise the hardcoded values.","title":"config"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig","text":"This class stores validator config parameters in a way that can be easily modified for testing niche implementations. Many of these fields are determined by the specification directly, but it may be desirable to modify them in certain cases.","title":"ValidatorConfig"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.entry_schemas","text":"The entry listing endpoint schemas","title":"entry_schemas"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.enum_fallback_values","text":"Provide fallback values for enum fields to use when validating filters.","title":"enum_fallback_values"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.exclusive_operators","text":"Dictionary mapping OPTIMADE DataType s to a list of operators that are 'exclusive', i.e. those that should not return entries with the matching value from the filter.","title":"exclusive_operators"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.inclusive_operators","text":"Dictionary mapping OPTIMADE DataType s to a list of operators that are 'inclusive', i.e. those that should return entries with the matching value from the filter.","title":"inclusive_operators"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.info_endpoint","text":"The name of the info endpoint","title":"info_endpoint"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.links_endpoint","text":"The name of the links endpoint","title":"links_endpoint"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.non_entry_endpoints","text":"The list specification-mandated endpoint names that do not contain entries","title":"non_entry_endpoints"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.response_classes","text":"Dictionary containing the mapping between endpoints and response classes for the main database","title":"response_classes"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.response_classes_index","text":"Dictionary containing the mapping between endpoints and response classes for the index meta-database","title":"response_classes_index"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.top_level_non_attribute_fields","text":"Field names to treat as top-level","title":"top_level_non_attribute_fields"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.unique_properties","text":"Fields that should be treated as unique indexes for all endpoints, i.e. fields on which filters should return at most one entry.","title":"unique_properties"},{"location":"api_reference/validator/config/#optimade.validator.config.ValidatorConfig.versions_endpoint","text":"The name of the versions endpoint","title":"versions_endpoint"},{"location":"api_reference/validator/utils/","text":"utils \u00b6 This submodule contains utility methods and models used by the validator. The two main features being: The @test_case decorator can be used to decorate validation methods and performs error handling, output and logging of test successes and failures. The patched Validator versions allow for stricter validation of server responses. The standard response classes allow entries to be provided as bare dictionaries, whilst these patched classes force them to be validated with the corresponding entry models themselves. Client \u00b6 __init__ ( self , base_url , max_retries = 5 ) special \u00b6 Initialises the Client with the given base_url without testing if it is valid. Parameters: Name Type Description Default base_url str the base URL of the optimade implementation, including request protocol (e.g. 'http://' ) and API version number if necessary. Examples: - `'http://example.org/optimade/v1'`, - `'www.crystallography.net/cod-test/optimade/v0.10.0/'` Note: A maximum of one slash (\"/\") is allowed as the last character. required Source code in optimade/validator/utils.py def __init__ ( self , base_url : str , max_retries = 5 ): \"\"\"Initialises the Client with the given `base_url` without testing if it is valid. Parameters: base_url (str): the base URL of the optimade implementation, including request protocol (e.g. `'http://'`) and API version number if necessary. Examples: - `'http://example.org/optimade/v1'`, - `'www.crystallography.net/cod-test/optimade/v0.10.0/'` Note: A maximum of one slash (\"/\") is allowed as the last character. \"\"\" self . base_url = base_url self . last_request = None self . response = None self . max_retries = max_retries get ( self , request ) \u00b6 Makes the given request, with a number of retries if being rate limited. The request will be prepended with the base_url unless the request appears to be an absolute URL (i.e. starts with http:// or https:// ). Parameters: Name Type Description Default request str the request to make against the base URL of this client. required Returns: Type Description response (requests.models.Response) the response from the server. Exceptions: Type Description SystemExit if there is no response from the server, or if the URL is invalid. ResponseError if the server does not respond with a non-429 status code within the MAX_RETRIES attempts. Source code in optimade/validator/utils.py def get ( self , request : str ): \"\"\"Makes the given request, with a number of retries if being rate limited. The request will be prepended with the `base_url` unless the request appears to be an absolute URL (i.e. starts with `http://` or `https://`). Parameters: request (str): the request to make against the base URL of this client. Returns: response (requests.models.Response): the response from the server. Raises: SystemExit: if there is no response from the server, or if the URL is invalid. ResponseError: if the server does not respond with a non-429 status code within the `MAX_RETRIES` attempts. \"\"\" if urllib . parse . urlparse ( request , allow_fragments = True ) . scheme : self . last_request = request else : if request and not request . startswith ( \"/\" ): request = f \"/ { request } \" self . last_request = f \" { self . base_url }{ request } \" status_code = None retries = 0 # probably a smarter way to do this with requests, but their documentation 404's... while retries < self . max_retries : retries += 1 try : self . response = requests . get ( self . last_request ) except requests . exceptions . ConnectionError as exc : sys . exit ( f \" { exc . __class__ . __name__ } : No response from server at { self . last_request } , please check the URL.\" ) except requests . exceptions . MissingSchema : sys . exit ( f \"Unable to make request on { self . last_request } , did you mean http:// { self . last_request } ?\" ) status_code = self . response . status_code if status_code != 429 : break time . sleep ( 1 ) else : raise ResponseError ( \"Hit max (manual) retries on request.\" ) return self . response InternalError ( Exception ) \u00b6 This exception should be raised when validation throws an unexpected error. These should be counted separately from ResponseError 's and ValidationError 's. ResponseError ( Exception ) \u00b6 This exception should be raised for a manual hardcoded test failure. print_failure ( string , ** kwargs ) \u00b6 Print but sad. Source code in optimade/validator/utils.py def print_failure ( string , ** kwargs ): \"\"\" Print but sad. \"\"\" print ( f \" \\033 [91m \\033 [1m { string } \\033 [0m\" , ** kwargs ) print_notify ( string , ** kwargs ) \u00b6 Print but louder. Source code in optimade/validator/utils.py def print_notify ( string , ** kwargs ): \"\"\" Print but louder. \"\"\" print ( f \" \\033 [94m \\033 [1m { string } \\033 [0m\" , ** kwargs ) print_success ( string , ** kwargs ) \u00b6 Print but happy. Source code in optimade/validator/utils.py def print_success ( string , ** kwargs ): \"\"\" Print but happy. \"\"\" print ( f \" \\033 [92m \\033 [1m { string } \\033 [0m\" , ** kwargs ) print_warning ( string , ** kwargs ) \u00b6 Print but angry. Source code in optimade/validator/utils.py def print_warning ( string , ** kwargs ): \"\"\" Print but angry. \"\"\" print ( f \" \\033 [93m { string } \\033 [0m\" , ** kwargs ) test_case ( test_fn ) \u00b6 Wrapper for test case functions, which pretty-prints any errors depending on verbosity level, collates the number and severity of test failures, returns the response and summary string to the caller. Any additional positional or keyword arguments are passed directly to test_fn . The wrapper will intercept the named arguments optional , multistage and request and interpret them according to the docstring for wrapper(...) below. Parameters: Name Type Description Default test_fn Callable[[Any], Tuple[Any, str]] Any function that returns an object and a message to print upon success. The function should raise a ResponseError , ValidationError or a ManualValidationError if the test case has failed. The function can return None to indicate that the test was not appropriate and should be ignored. required Source code in optimade/validator/utils.py def test_case ( test_fn : Callable [[ Any ], Tuple [ Any , str ]]): \"\"\"Wrapper for test case functions, which pretty-prints any errors depending on verbosity level, collates the number and severity of test failures, returns the response and summary string to the caller. Any additional positional or keyword arguments are passed directly to `test_fn`. The wrapper will intercept the named arguments `optional`, `multistage` and `request` and interpret them according to the docstring for `wrapper(...)` below. Parameters: test_fn: Any function that returns an object and a message to print upon success. The function should raise a `ResponseError`, `ValidationError` or a `ManualValidationError` if the test case has failed. The function can return `None` to indicate that the test was not appropriate and should be ignored. \"\"\" from functools import wraps @wraps ( test_fn ) def wrapper ( validator , * args , request : str = None , optional : bool = False , multistage : bool = False , ** kwargs , ): \"\"\"Wraps a function or validator method and handles success, failure and output depending on the keyword arguments passed. Arguments: validator: The validator object to accumulate errors/counters. *args: Positional arguments passed to the test function. request: Description of the request made by the wrapped function (e.g. a URL or a summary). optional: Whether or not to treat the test as optional. multistage: If `True`, no output will be printed for this test, and it will not increment the success counter. Errors will be handled in the normal way. This can be used to avoid flooding the output for mutli-stage tests. **kwargs: Extra named arguments passed to the test function. \"\"\" try : try : if optional and not validator . run_optional_tests : result = None msg = \"skipping optional\" else : result , msg = test_fn ( validator , * args , ** kwargs ) except ( json . JSONDecodeError , ResponseError , ValidationError ) as exc : msg = f \" { exc . __class__ . __name__ } : { exc } \" raise exc except Exception as exc : msg = f \" { exc . __class__ . __name__ } : { exc } \" raise InternalError ( msg ) # Catch SystemExit and KeyboardInterrupt explicitly so that we can pass # them to the finally block, where they are immediately raised except ( Exception , SystemExit , KeyboardInterrupt ) as exc : result = exc traceback = tb . format_exc () finally : # This catches the case of the Client throwing a SystemExit if the server # did not respond, the case of the validator \"fail-fast\"'ing and throwing # a SystemExit below, and the case of the user interrupting the process manually if isinstance ( result , ( SystemExit , KeyboardInterrupt )): raise result display_request = None try : display_request = validator . client . last_request except AttributeError : pass if display_request is None : display_request = validator . base_url if request is not None : display_request += \"/\" + request request = display_request # If the result was None, return it here and ignore statuses if result is None : return result , msg if not isinstance ( result , Exception ): if not multistage : success_type = \"optional\" if optional else None validator . results . add_success ( f \" { request } - { msg } \" , success_type ) else : request = request . replace ( \" \\n \" , \"\" ) message = msg . split ( \" \\n \" ) if validator . verbosity > 1 : # ValidationErrors from pydantic already include very detailed errors # that get duplicated in the traceback if not isinstance ( result , ValidationError ): message += traceback . split ( \" \\n \" ) message = \" \\n \" . join ( message ) if isinstance ( result , InternalError ): summary = ( f \" { request } - { test_fn . __name__ } - failed with internal error\" ) failure_type = \"internal\" else : summary = f \" { request } - { test_fn . __name__ } - failed with error\" failure_type = \"optional\" if optional else None validator . results . add_failure ( summary , message , failure_type = failure_type ) # set failure result to None as this is expected by other functions result = None if validator . fail_fast and not optional : validator . print_summary () raise SystemExit # Reset the client request so that it can be properly # displayed if the next request fails if not multistage : validator . client . last_request = None return result , msg return wrapper","title":"utils"},{"location":"api_reference/validator/utils/#utils","text":"This submodule contains utility methods and models used by the validator. The two main features being: The @test_case decorator can be used to decorate validation methods and performs error handling, output and logging of test successes and failures. The patched Validator versions allow for stricter validation of server responses. The standard response classes allow entries to be provided as bare dictionaries, whilst these patched classes force them to be validated with the corresponding entry models themselves.","title":"utils"},{"location":"api_reference/validator/utils/#optimade.validator.utils.Client","text":"","title":"Client"},{"location":"api_reference/validator/utils/#optimade.validator.utils.Client.__init__","text":"Initialises the Client with the given base_url without testing if it is valid. Parameters: Name Type Description Default base_url str the base URL of the optimade implementation, including request protocol (e.g. 'http://' ) and API version number if necessary. Examples: - `'http://example.org/optimade/v1'`, - `'www.crystallography.net/cod-test/optimade/v0.10.0/'` Note: A maximum of one slash (\"/\") is allowed as the last character. required Source code in optimade/validator/utils.py def __init__ ( self , base_url : str , max_retries = 5 ): \"\"\"Initialises the Client with the given `base_url` without testing if it is valid. Parameters: base_url (str): the base URL of the optimade implementation, including request protocol (e.g. `'http://'`) and API version number if necessary. Examples: - `'http://example.org/optimade/v1'`, - `'www.crystallography.net/cod-test/optimade/v0.10.0/'` Note: A maximum of one slash (\"/\") is allowed as the last character. \"\"\" self . base_url = base_url self . last_request = None self . response = None self . max_retries = max_retries","title":"__init__()"},{"location":"api_reference/validator/utils/#optimade.validator.utils.Client.get","text":"Makes the given request, with a number of retries if being rate limited. The request will be prepended with the base_url unless the request appears to be an absolute URL (i.e. starts with http:// or https:// ). Parameters: Name Type Description Default request str the request to make against the base URL of this client. required Returns: Type Description response (requests.models.Response) the response from the server. Exceptions: Type Description SystemExit if there is no response from the server, or if the URL is invalid. ResponseError if the server does not respond with a non-429 status code within the MAX_RETRIES attempts. Source code in optimade/validator/utils.py def get ( self , request : str ): \"\"\"Makes the given request, with a number of retries if being rate limited. The request will be prepended with the `base_url` unless the request appears to be an absolute URL (i.e. starts with `http://` or `https://`). Parameters: request (str): the request to make against the base URL of this client. Returns: response (requests.models.Response): the response from the server. Raises: SystemExit: if there is no response from the server, or if the URL is invalid. ResponseError: if the server does not respond with a non-429 status code within the `MAX_RETRIES` attempts. \"\"\" if urllib . parse . urlparse ( request , allow_fragments = True ) . scheme : self . last_request = request else : if request and not request . startswith ( \"/\" ): request = f \"/ { request } \" self . last_request = f \" { self . base_url }{ request } \" status_code = None retries = 0 # probably a smarter way to do this with requests, but their documentation 404's... while retries < self . max_retries : retries += 1 try : self . response = requests . get ( self . last_request ) except requests . exceptions . ConnectionError as exc : sys . exit ( f \" { exc . __class__ . __name__ } : No response from server at { self . last_request } , please check the URL.\" ) except requests . exceptions . MissingSchema : sys . exit ( f \"Unable to make request on { self . last_request } , did you mean http:// { self . last_request } ?\" ) status_code = self . response . status_code if status_code != 429 : break time . sleep ( 1 ) else : raise ResponseError ( \"Hit max (manual) retries on request.\" ) return self . response","title":"get()"},{"location":"api_reference/validator/utils/#optimade.validator.utils.InternalError","text":"This exception should be raised when validation throws an unexpected error. These should be counted separately from ResponseError 's and ValidationError 's.","title":"InternalError"},{"location":"api_reference/validator/utils/#optimade.validator.utils.ResponseError","text":"This exception should be raised for a manual hardcoded test failure.","title":"ResponseError"},{"location":"api_reference/validator/utils/#optimade.validator.utils.print_failure","text":"Print but sad. Source code in optimade/validator/utils.py def print_failure ( string , ** kwargs ): \"\"\" Print but sad. \"\"\" print ( f \" \\033 [91m \\033 [1m { string } \\033 [0m\" , ** kwargs )","title":"print_failure()"},{"location":"api_reference/validator/utils/#optimade.validator.utils.print_notify","text":"Print but louder. Source code in optimade/validator/utils.py def print_notify ( string , ** kwargs ): \"\"\" Print but louder. \"\"\" print ( f \" \\033 [94m \\033 [1m { string } \\033 [0m\" , ** kwargs )","title":"print_notify()"},{"location":"api_reference/validator/utils/#optimade.validator.utils.print_success","text":"Print but happy. Source code in optimade/validator/utils.py def print_success ( string , ** kwargs ): \"\"\" Print but happy. \"\"\" print ( f \" \\033 [92m \\033 [1m { string } \\033 [0m\" , ** kwargs )","title":"print_success()"},{"location":"api_reference/validator/utils/#optimade.validator.utils.print_warning","text":"Print but angry. Source code in optimade/validator/utils.py def print_warning ( string , ** kwargs ): \"\"\" Print but angry. \"\"\" print ( f \" \\033 [93m { string } \\033 [0m\" , ** kwargs )","title":"print_warning()"},{"location":"api_reference/validator/utils/#optimade.validator.utils.test_case","text":"Wrapper for test case functions, which pretty-prints any errors depending on verbosity level, collates the number and severity of test failures, returns the response and summary string to the caller. Any additional positional or keyword arguments are passed directly to test_fn . The wrapper will intercept the named arguments optional , multistage and request and interpret them according to the docstring for wrapper(...) below. Parameters: Name Type Description Default test_fn Callable[[Any], Tuple[Any, str]] Any function that returns an object and a message to print upon success. The function should raise a ResponseError , ValidationError or a ManualValidationError if the test case has failed. The function can return None to indicate that the test was not appropriate and should be ignored. required Source code in optimade/validator/utils.py def test_case ( test_fn : Callable [[ Any ], Tuple [ Any , str ]]): \"\"\"Wrapper for test case functions, which pretty-prints any errors depending on verbosity level, collates the number and severity of test failures, returns the response and summary string to the caller. Any additional positional or keyword arguments are passed directly to `test_fn`. The wrapper will intercept the named arguments `optional`, `multistage` and `request` and interpret them according to the docstring for `wrapper(...)` below. Parameters: test_fn: Any function that returns an object and a message to print upon success. The function should raise a `ResponseError`, `ValidationError` or a `ManualValidationError` if the test case has failed. The function can return `None` to indicate that the test was not appropriate and should be ignored. \"\"\" from functools import wraps @wraps ( test_fn ) def wrapper ( validator , * args , request : str = None , optional : bool = False , multistage : bool = False , ** kwargs , ): \"\"\"Wraps a function or validator method and handles success, failure and output depending on the keyword arguments passed. Arguments: validator: The validator object to accumulate errors/counters. *args: Positional arguments passed to the test function. request: Description of the request made by the wrapped function (e.g. a URL or a summary). optional: Whether or not to treat the test as optional. multistage: If `True`, no output will be printed for this test, and it will not increment the success counter. Errors will be handled in the normal way. This can be used to avoid flooding the output for mutli-stage tests. **kwargs: Extra named arguments passed to the test function. \"\"\" try : try : if optional and not validator . run_optional_tests : result = None msg = \"skipping optional\" else : result , msg = test_fn ( validator , * args , ** kwargs ) except ( json . JSONDecodeError , ResponseError , ValidationError ) as exc : msg = f \" { exc . __class__ . __name__ } : { exc } \" raise exc except Exception as exc : msg = f \" { exc . __class__ . __name__ } : { exc } \" raise InternalError ( msg ) # Catch SystemExit and KeyboardInterrupt explicitly so that we can pass # them to the finally block, where they are immediately raised except ( Exception , SystemExit , KeyboardInterrupt ) as exc : result = exc traceback = tb . format_exc () finally : # This catches the case of the Client throwing a SystemExit if the server # did not respond, the case of the validator \"fail-fast\"'ing and throwing # a SystemExit below, and the case of the user interrupting the process manually if isinstance ( result , ( SystemExit , KeyboardInterrupt )): raise result display_request = None try : display_request = validator . client . last_request except AttributeError : pass if display_request is None : display_request = validator . base_url if request is not None : display_request += \"/\" + request request = display_request # If the result was None, return it here and ignore statuses if result is None : return result , msg if not isinstance ( result , Exception ): if not multistage : success_type = \"optional\" if optional else None validator . results . add_success ( f \" { request } - { msg } \" , success_type ) else : request = request . replace ( \" \\n \" , \"\" ) message = msg . split ( \" \\n \" ) if validator . verbosity > 1 : # ValidationErrors from pydantic already include very detailed errors # that get duplicated in the traceback if not isinstance ( result , ValidationError ): message += traceback . split ( \" \\n \" ) message = \" \\n \" . join ( message ) if isinstance ( result , InternalError ): summary = ( f \" { request } - { test_fn . __name__ } - failed with internal error\" ) failure_type = \"internal\" else : summary = f \" { request } - { test_fn . __name__ } - failed with error\" failure_type = \"optional\" if optional else None validator . results . add_failure ( summary , message , failure_type = failure_type ) # set failure result to None as this is expected by other functions result = None if validator . fail_fast and not optional : validator . print_summary () raise SystemExit # Reset the client request so that it can be properly # displayed if the next request fails if not multistage : validator . client . last_request = None return result , msg return wrapper","title":"test_case()"},{"location":"api_reference/validator/validator/","text":"validator \u00b6 This module contains the ImplementationValidator class that can be pointed at an OPTIMADE implementation and validated against the specification via the pydantic models implemented in this package. ImplementationValidator \u00b6 Class used to make a series of checks against a particular OPTIMADE implementation over HTTP. Uses the pydantic models in optimade.models to validate the response from the server and crawl through the available endpoints. Attributes: Name Type Description valid Optional[bool] whether or not the implementation was deemed valid, with None signifying that tests did not run. Caution Only works for current version of the specification as defined by optimade.models . __init__ ( self , client = None , base_url = None , verbosity = 0 , respond_json = False , page_limit = 5 , max_retries = 5 , run_optional_tests = True , fail_fast = False , as_type = None , index = False , minimal = False ) special \u00b6 Set up the tests to run, based on constants in this module for required endpoints. Parameters: Name Type Description Default client Any A client that has a .get() method to obtain the response from the implementation. If None , then Client will be used. None base_url str The URL of the implementation to validate. Unless performing \"as_type\" validation, this should point to the base of the OPTIMADE implementation. None verbosity int The verbosity of the output and logging as an integer ( 0 : critical, 1 : warning, 2 : info, 3 : debug). 0 respond_json bool If True , print only a JSON representation of the results of validation to stdout. False page_limit int The default page limit to apply to filters. 5 max_retries int Argument is passed to the client for how many attempts to make for a request before failing. 5 run_optional_tests bool Whether to run the tests on optional OPTIMADE features. True fail_fast bool Whether to exit validation after the first failure of a mandatory test. False as_type str An OPTIMADE entry or endpoint type to coerce the response from implementation into, e.g. \"structures\". Requires base_url to be pointed to the corresponding endpoint. None index bool Whether to validate the implementation as an index meta-database. False minimal bool Whether or not to run only a minimal test set. False Source code in optimade/validator/validator.py def __init__ ( # pylint: disable=too-many-arguments self , client : Any = None , base_url : str = None , verbosity : int = 0 , respond_json : bool = False , page_limit : int = 5 , max_retries : int = 5 , run_optional_tests : bool = True , fail_fast : bool = False , as_type : str = None , index : bool = False , minimal : bool = False , ): \"\"\"Set up the tests to run, based on constants in this module for required endpoints. Arguments: client: A client that has a `.get()` method to obtain the response from the implementation. If `None`, then [`Client`][optimade.validator.utils.Client] will be used. base_url: The URL of the implementation to validate. Unless performing \"as_type\" validation, this should point to the base of the OPTIMADE implementation. verbosity: The verbosity of the output and logging as an integer (`0`: critical, `1`: warning, `2`: info, `3`: debug). respond_json: If `True`, print only a JSON representation of the results of validation to stdout. page_limit: The default page limit to apply to filters. max_retries: Argument is passed to the client for how many attempts to make for a request before failing. run_optional_tests: Whether to run the tests on optional OPTIMADE features. fail_fast: Whether to exit validation after the first failure of a mandatory test. as_type: An OPTIMADE entry or endpoint type to coerce the response from implementation into, e.g. \"structures\". Requires `base_url` to be pointed to the corresponding endpoint. index: Whether to validate the implementation as an index meta-database. minimal: Whether or not to run only a minimal test set. \"\"\" self . verbosity = verbosity self . max_retries = max_retries self . page_limit = page_limit self . index = index self . run_optional_tests = run_optional_tests self . fail_fast = fail_fast self . respond_json = respond_json self . minimal = minimal if as_type is None : self . as_type_cls = None elif self . index : if as_type not in CONF . response_classes_index : raise RuntimeError ( f \"Provided as_type=' { as_type } ' not allowed for an Index meta-database.\" ) self . as_type_cls = CONF . response_classes_index [ as_type ] elif as_type in ( \"structure\" , \"reference\" ): self . as_type_cls = CONF . response_classes [ f \" { as_type } s/\" ] else : self . as_type_cls = CONF . response_classes [ as_type ] if client is None and base_url is None : raise RuntimeError ( \"Need at least a URL or a client to initialize validator.\" ) if base_url and client : raise RuntimeError ( \"Please specify at most one of base_url or client.\" ) if client : self . client = client self . base_url = self . client . base_url else : while base_url . endswith ( \"/\" ): base_url = base_url [: - 1 ] self . base_url = base_url self . client = Client ( base_url , max_retries = self . max_retries ) self . _setup_log () self . _response_classes = ( CONF . response_classes_index if self . index else CONF . response_classes ) # some simple checks on base_url self . base_url_parsed = urllib . parse . urlparse ( self . base_url ) # only allow filters/endpoints if we are working in \"as_type\" mode if self . as_type_cls is None and self . base_url_parsed . query : raise SystemExit ( \"Base URL not appropriate: should not contain a filter.\" ) self . valid = None self . _test_id_by_type = {} self . _entry_info_by_type = {} self . results = ValidatorResults ( verbosity = self . verbosity ) print_summary ( self ) \u00b6 Print a summary of the results of validation. Source code in optimade/validator/validator.py def print_summary ( self ): \"\"\" Print a summary of the results of validation. \"\"\" if self . respond_json : print ( json . dumps ( dataclasses . asdict ( self . results ), indent = 2 )) return if self . results . failure_messages : print ( \" \\n\\n FAILURES\" ) print ( \"======== \\n \" ) for message in self . results . failure_messages : print_failure ( message [ 0 ]) for line in message [ 1 ] . split ( \" \\n \" ): print_warning ( \" \\t \" + line ) if self . results . optional_failure_messages : print ( \" \\n\\n OPTIONAL TEST FAILURES\" ) print ( \"====================== \\n \" ) for message in self . results . optional_failure_messages : print_notify ( message [ 0 ]) for line in message [ 1 ] . split ( \" \\n \" ): print_warning ( \" \\t \" + line ) if self . results . internal_failure_messages : print ( \" \\n\\n INTERNAL FAILURES\" ) print ( \"================= \\n \" ) print ( \"There were internal validator failures associated with this run. \\n \" \"If this problem persists, please report it at: \\n \" \"https://github.com/Materials-Consortia/optimade-python-tools/issues/new \\n \" ) for message in self . results . internal_failure_messages : print_warning ( message [ 0 ]) for line in message [ 1 ] . split ( \" \\n \" ): print_warning ( \" \\t \" + line ) if self . valid or ( not self . valid and not self . fail_fast ): final_message = f \" \\n\\n Passed { self . results . success_count } out of { self . results . success_count + self . results . failure_count + self . results . internal_failure_count } tests.\" if not self . valid : print_failure ( final_message ) else : print_success ( final_message ) if self . run_optional_tests and not self . fail_fast : print ( f \"Additionally passed { self . results . optional_success_count } out of \" f \" { self . results . optional_success_count + self . results . optional_failure_count } optional tests.\" ) validate_implementation ( self ) \u00b6 Run all the test cases on the implementation, or the single type test, depending on what options were provided on initialiation. Sets the self.valid attribute to True or False depending on the outcome of the tests. Exceptions: Type Description RuntimeError If it was not possible to start the validation process. Source code in optimade/validator/validator.py def validate_implementation ( self ): \"\"\"Run all the test cases on the implementation, or the single type test, depending on what options were provided on initialiation. Sets the `self.valid` attribute to `True` or `False` depending on the outcome of the tests. Raises: RuntimeError: If it was not possible to start the validation process. \"\"\" # If a single \"as type\" has been set, only run that test if self . as_type_cls is not None : self . _log . debug ( \"Validating response of %s with model %s \" , self . base_url , self . as_type_cls , ) self . _test_as_type () self . valid = not bool ( self . results . failure_count ) self . print_summary () return # Test entire implementation if self . verbosity >= 0 : print ( f \"Testing entire implementation at { self . base_url } \" ) info_endp = CONF . info_endpoint self . _log . debug ( \"Testing base info endpoint of %s \" , info_endp ) # Get and validate base info to find endpoints # If this is not possible, then exit at this stage base_info = self . _test_info_or_links_endpoint ( info_endp ) if not base_info : self . _log . critical ( f \"Unable to deserialize response from introspective { info_endp !r} endpoint. \" \"This is required for all further validation, so the validator will now exit.\" ) # Set valid to False to ensure error code 1 is raised at CLI self . valid = False self . print_summary () return # Grab the provider prefix from base info and use it when looking for provider fields self . provider_prefix = None meta = base_info . get ( \"meta\" , {}) if meta . get ( \"provider\" ) is not None : self . provider_prefix = meta [ \"provider\" ] . get ( \"prefix\" ) # Set the response class for all `/info/entry` endpoints based on `/info` response self . available_json_endpoints , _ = self . _get_available_endpoints ( base_info , request = info_endp ) for endp in self . available_json_endpoints : self . _response_classes [ f \" { info_endp } / { endp } \" ] = EntryInfoResponse # Run some tests on the versions endpoint self . _log . debug ( \"Testing versions endpoint %s \" , CONF . versions_endpoint ) self . _test_versions_endpoint () self . _test_bad_version_returns_553 () # Test that entry info endpoints deserialize correctly # If they do not, the corresponding entry in _entry_info_by_type # is set to False, which must be checked for further validation for endp in self . available_json_endpoints : entry_info_endpoint = f \" { info_endp } / { endp } \" self . _log . debug ( \"Testing expected info endpoint %s \" , entry_info_endpoint ) self . _entry_info_by_type [ endp ] = self . _test_info_or_links_endpoint ( entry_info_endpoint ) # Use the _entry_info_by_type to construct filters on the relevant endpoints if not self . minimal : for endp in self . available_json_endpoints : self . _log . debug ( \"Testing queries on JSON entry endpoint of %s \" , endp ) self . _recurse_through_endpoint ( endp ) # Test that the results from multi-entry-endpoints obey, e.g. page limits, # and that all entries can be deserialized with the patched models. # These methods also set the test_ids for each type of entry, which are validated # in the next loop. for endp in self . available_json_endpoints : self . _log . debug ( \"Testing multiple entry endpoint of %s \" , endp ) self . _test_multi_entry_endpoint ( endp ) # Test that the single IDs scraped earlier work with the single entry endpoint for endp in self . available_json_endpoints : self . _log . debug ( \"Testing single entry request of type %s \" , endp ) self . _test_single_entry_endpoint ( endp ) # Test that the links endpoint can be serialized correctly self . _log . debug ( \"Testing %s endpoint\" , CONF . links_endpoint ) self . _test_info_or_links_endpoint ( CONF . links_endpoint ) self . valid = not ( self . results . failure_count or self . results . internal_failure_count ) self . print_summary ()","title":"validator"},{"location":"api_reference/validator/validator/#validator","text":"This module contains the ImplementationValidator class that can be pointed at an OPTIMADE implementation and validated against the specification via the pydantic models implemented in this package.","title":"validator"},{"location":"api_reference/validator/validator/#optimade.validator.validator.ImplementationValidator","text":"Class used to make a series of checks against a particular OPTIMADE implementation over HTTP. Uses the pydantic models in optimade.models to validate the response from the server and crawl through the available endpoints. Attributes: Name Type Description valid Optional[bool] whether or not the implementation was deemed valid, with None signifying that tests did not run. Caution Only works for current version of the specification as defined by optimade.models .","title":"ImplementationValidator"},{"location":"api_reference/validator/validator/#optimade.validator.validator.ImplementationValidator.__init__","text":"Set up the tests to run, based on constants in this module for required endpoints. Parameters: Name Type Description Default client Any A client that has a .get() method to obtain the response from the implementation. If None , then Client will be used. None base_url str The URL of the implementation to validate. Unless performing \"as_type\" validation, this should point to the base of the OPTIMADE implementation. None verbosity int The verbosity of the output and logging as an integer ( 0 : critical, 1 : warning, 2 : info, 3 : debug). 0 respond_json bool If True , print only a JSON representation of the results of validation to stdout. False page_limit int The default page limit to apply to filters. 5 max_retries int Argument is passed to the client for how many attempts to make for a request before failing. 5 run_optional_tests bool Whether to run the tests on optional OPTIMADE features. True fail_fast bool Whether to exit validation after the first failure of a mandatory test. False as_type str An OPTIMADE entry or endpoint type to coerce the response from implementation into, e.g. \"structures\". Requires base_url to be pointed to the corresponding endpoint. None index bool Whether to validate the implementation as an index meta-database. False minimal bool Whether or not to run only a minimal test set. False Source code in optimade/validator/validator.py def __init__ ( # pylint: disable=too-many-arguments self , client : Any = None , base_url : str = None , verbosity : int = 0 , respond_json : bool = False , page_limit : int = 5 , max_retries : int = 5 , run_optional_tests : bool = True , fail_fast : bool = False , as_type : str = None , index : bool = False , minimal : bool = False , ): \"\"\"Set up the tests to run, based on constants in this module for required endpoints. Arguments: client: A client that has a `.get()` method to obtain the response from the implementation. If `None`, then [`Client`][optimade.validator.utils.Client] will be used. base_url: The URL of the implementation to validate. Unless performing \"as_type\" validation, this should point to the base of the OPTIMADE implementation. verbosity: The verbosity of the output and logging as an integer (`0`: critical, `1`: warning, `2`: info, `3`: debug). respond_json: If `True`, print only a JSON representation of the results of validation to stdout. page_limit: The default page limit to apply to filters. max_retries: Argument is passed to the client for how many attempts to make for a request before failing. run_optional_tests: Whether to run the tests on optional OPTIMADE features. fail_fast: Whether to exit validation after the first failure of a mandatory test. as_type: An OPTIMADE entry or endpoint type to coerce the response from implementation into, e.g. \"structures\". Requires `base_url` to be pointed to the corresponding endpoint. index: Whether to validate the implementation as an index meta-database. minimal: Whether or not to run only a minimal test set. \"\"\" self . verbosity = verbosity self . max_retries = max_retries self . page_limit = page_limit self . index = index self . run_optional_tests = run_optional_tests self . fail_fast = fail_fast self . respond_json = respond_json self . minimal = minimal if as_type is None : self . as_type_cls = None elif self . index : if as_type not in CONF . response_classes_index : raise RuntimeError ( f \"Provided as_type=' { as_type } ' not allowed for an Index meta-database.\" ) self . as_type_cls = CONF . response_classes_index [ as_type ] elif as_type in ( \"structure\" , \"reference\" ): self . as_type_cls = CONF . response_classes [ f \" { as_type } s/\" ] else : self . as_type_cls = CONF . response_classes [ as_type ] if client is None and base_url is None : raise RuntimeError ( \"Need at least a URL or a client to initialize validator.\" ) if base_url and client : raise RuntimeError ( \"Please specify at most one of base_url or client.\" ) if client : self . client = client self . base_url = self . client . base_url else : while base_url . endswith ( \"/\" ): base_url = base_url [: - 1 ] self . base_url = base_url self . client = Client ( base_url , max_retries = self . max_retries ) self . _setup_log () self . _response_classes = ( CONF . response_classes_index if self . index else CONF . response_classes ) # some simple checks on base_url self . base_url_parsed = urllib . parse . urlparse ( self . base_url ) # only allow filters/endpoints if we are working in \"as_type\" mode if self . as_type_cls is None and self . base_url_parsed . query : raise SystemExit ( \"Base URL not appropriate: should not contain a filter.\" ) self . valid = None self . _test_id_by_type = {} self . _entry_info_by_type = {} self . results = ValidatorResults ( verbosity = self . verbosity )","title":"__init__()"},{"location":"api_reference/validator/validator/#optimade.validator.validator.ImplementationValidator.print_summary","text":"Print a summary of the results of validation. Source code in optimade/validator/validator.py def print_summary ( self ): \"\"\" Print a summary of the results of validation. \"\"\" if self . respond_json : print ( json . dumps ( dataclasses . asdict ( self . results ), indent = 2 )) return if self . results . failure_messages : print ( \" \\n\\n FAILURES\" ) print ( \"======== \\n \" ) for message in self . results . failure_messages : print_failure ( message [ 0 ]) for line in message [ 1 ] . split ( \" \\n \" ): print_warning ( \" \\t \" + line ) if self . results . optional_failure_messages : print ( \" \\n\\n OPTIONAL TEST FAILURES\" ) print ( \"====================== \\n \" ) for message in self . results . optional_failure_messages : print_notify ( message [ 0 ]) for line in message [ 1 ] . split ( \" \\n \" ): print_warning ( \" \\t \" + line ) if self . results . internal_failure_messages : print ( \" \\n\\n INTERNAL FAILURES\" ) print ( \"================= \\n \" ) print ( \"There were internal validator failures associated with this run. \\n \" \"If this problem persists, please report it at: \\n \" \"https://github.com/Materials-Consortia/optimade-python-tools/issues/new \\n \" ) for message in self . results . internal_failure_messages : print_warning ( message [ 0 ]) for line in message [ 1 ] . split ( \" \\n \" ): print_warning ( \" \\t \" + line ) if self . valid or ( not self . valid and not self . fail_fast ): final_message = f \" \\n\\n Passed { self . results . success_count } out of { self . results . success_count + self . results . failure_count + self . results . internal_failure_count } tests.\" if not self . valid : print_failure ( final_message ) else : print_success ( final_message ) if self . run_optional_tests and not self . fail_fast : print ( f \"Additionally passed { self . results . optional_success_count } out of \" f \" { self . results . optional_success_count + self . results . optional_failure_count } optional tests.\" )","title":"print_summary()"},{"location":"api_reference/validator/validator/#optimade.validator.validator.ImplementationValidator.validate_implementation","text":"Run all the test cases on the implementation, or the single type test, depending on what options were provided on initialiation. Sets the self.valid attribute to True or False depending on the outcome of the tests. Exceptions: Type Description RuntimeError If it was not possible to start the validation process. Source code in optimade/validator/validator.py def validate_implementation ( self ): \"\"\"Run all the test cases on the implementation, or the single type test, depending on what options were provided on initialiation. Sets the `self.valid` attribute to `True` or `False` depending on the outcome of the tests. Raises: RuntimeError: If it was not possible to start the validation process. \"\"\" # If a single \"as type\" has been set, only run that test if self . as_type_cls is not None : self . _log . debug ( \"Validating response of %s with model %s \" , self . base_url , self . as_type_cls , ) self . _test_as_type () self . valid = not bool ( self . results . failure_count ) self . print_summary () return # Test entire implementation if self . verbosity >= 0 : print ( f \"Testing entire implementation at { self . base_url } \" ) info_endp = CONF . info_endpoint self . _log . debug ( \"Testing base info endpoint of %s \" , info_endp ) # Get and validate base info to find endpoints # If this is not possible, then exit at this stage base_info = self . _test_info_or_links_endpoint ( info_endp ) if not base_info : self . _log . critical ( f \"Unable to deserialize response from introspective { info_endp !r} endpoint. \" \"This is required for all further validation, so the validator will now exit.\" ) # Set valid to False to ensure error code 1 is raised at CLI self . valid = False self . print_summary () return # Grab the provider prefix from base info and use it when looking for provider fields self . provider_prefix = None meta = base_info . get ( \"meta\" , {}) if meta . get ( \"provider\" ) is not None : self . provider_prefix = meta [ \"provider\" ] . get ( \"prefix\" ) # Set the response class for all `/info/entry` endpoints based on `/info` response self . available_json_endpoints , _ = self . _get_available_endpoints ( base_info , request = info_endp ) for endp in self . available_json_endpoints : self . _response_classes [ f \" { info_endp } / { endp } \" ] = EntryInfoResponse # Run some tests on the versions endpoint self . _log . debug ( \"Testing versions endpoint %s \" , CONF . versions_endpoint ) self . _test_versions_endpoint () self . _test_bad_version_returns_553 () # Test that entry info endpoints deserialize correctly # If they do not, the corresponding entry in _entry_info_by_type # is set to False, which must be checked for further validation for endp in self . available_json_endpoints : entry_info_endpoint = f \" { info_endp } / { endp } \" self . _log . debug ( \"Testing expected info endpoint %s \" , entry_info_endpoint ) self . _entry_info_by_type [ endp ] = self . _test_info_or_links_endpoint ( entry_info_endpoint ) # Use the _entry_info_by_type to construct filters on the relevant endpoints if not self . minimal : for endp in self . available_json_endpoints : self . _log . debug ( \"Testing queries on JSON entry endpoint of %s \" , endp ) self . _recurse_through_endpoint ( endp ) # Test that the results from multi-entry-endpoints obey, e.g. page limits, # and that all entries can be deserialized with the patched models. # These methods also set the test_ids for each type of entry, which are validated # in the next loop. for endp in self . available_json_endpoints : self . _log . debug ( \"Testing multiple entry endpoint of %s \" , endp ) self . _test_multi_entry_endpoint ( endp ) # Test that the single IDs scraped earlier work with the single entry endpoint for endp in self . available_json_endpoints : self . _log . debug ( \"Testing single entry request of type %s \" , endp ) self . _test_single_entry_endpoint ( endp ) # Test that the links endpoint can be serialized correctly self . _log . debug ( \"Testing %s endpoint\" , CONF . links_endpoint ) self . _test_info_or_links_endpoint ( CONF . links_endpoint ) self . valid = not ( self . results . failure_count or self . results . internal_failure_count ) self . print_summary ()","title":"validate_implementation()"},{"location":"use_cases/dynamic_db/","text":"Dynamic databases \u00b6","title":"Dynamic databases"},{"location":"use_cases/dynamic_db/#dynamic-databases","text":"","title":"Dynamic databases"},{"location":"use_cases/multi_db/","text":"Multiple databases \u00b6","title":"Multiple databases"},{"location":"use_cases/multi_db/#multiple-databases","text":"","title":"Multiple databases"},{"location":"use_cases/single_db/","text":"A single database \u00b6","title":"A single database"},{"location":"use_cases/single_db/#a-single-database","text":"","title":"A single database"}]}