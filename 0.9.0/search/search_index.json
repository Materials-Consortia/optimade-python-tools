{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OPTIMADE Python tools \u00b6 Latest release Build status Activity The aim of OPTIMADE is to develop a common API, compliant with the JSON API 1.0 specification. This is to enable interoperability among databases that contain calculated properties of existing and hypothetical materials. This repository contains a library of tools for implementing and consuming OPTIMADE APIs using Python. It also contains a server validator tool, which may be called from the shell or used as a GitHub Action from optimade-validator-action . Disclaimer : While the package supports elasticsearch-dsl v6 & v7 and django v2 & v3, all tests are performed with the latest supported version. If you experience any issues with the older versions, you are most welcome to contribute to the repository (see below under Contributing). Status \u00b6 Both the OPTIMADE specification and this repository are under development . The latest stable version can be obtained from PyPI pip install optimade or by cloning the master branch of this repository git clone git@github.com:Materials-Consortia/optimade-python-tools . Installation \u00b6 Installation instructions, for both the index meta-database, and for the main API can be found in INSTALL.md . Contributing \u00b6 Contribution guidelines and tips can be found in CONTRIBUTING.md . Links \u00b6 OPTIMADE Specification , the human-readable specification that this library is based on. optimade-validator-action , a GitHub action that can be used to validate implementations from a URL (using the validator from this repo). OpenAPI , the machine-readable format used to specify the OPTIMADE API in openapi.json . Interactive documentation generated from openapi.json (see also interactive JSON editor ). pydantic , the library used for generating the OpenAPI schema from Python models . FastAPI , the framework used for generating the reference implementation from the openapi.json specification. lark , the library used to parse the filter language in OPTIMADE queries.","title":"OPTIMADE Python tools"},{"location":"#optimade-python-tools","text":"Latest release Build status Activity The aim of OPTIMADE is to develop a common API, compliant with the JSON API 1.0 specification. This is to enable interoperability among databases that contain calculated properties of existing and hypothetical materials. This repository contains a library of tools for implementing and consuming OPTIMADE APIs using Python. It also contains a server validator tool, which may be called from the shell or used as a GitHub Action from optimade-validator-action . Disclaimer : While the package supports elasticsearch-dsl v6 & v7 and django v2 & v3, all tests are performed with the latest supported version. If you experience any issues with the older versions, you are most welcome to contribute to the repository (see below under Contributing).","title":"OPTIMADE Python tools"},{"location":"#status","text":"Both the OPTIMADE specification and this repository are under development . The latest stable version can be obtained from PyPI pip install optimade or by cloning the master branch of this repository git clone git@github.com:Materials-Consortia/optimade-python-tools .","title":"Status"},{"location":"#installation","text":"Installation instructions, for both the index meta-database, and for the main API can be found in INSTALL.md .","title":"Installation"},{"location":"#contributing","text":"Contribution guidelines and tips can be found in CONTRIBUTING.md .","title":"Contributing"},{"location":"#links","text":"OPTIMADE Specification , the human-readable specification that this library is based on. optimade-validator-action , a GitHub action that can be used to validate implementations from a URL (using the validator from this repo). OpenAPI , the machine-readable format used to specify the OPTIMADE API in openapi.json . Interactive documentation generated from openapi.json (see also interactive JSON editor ). pydantic , the library used for generating the OpenAPI schema from Python models . FastAPI , the framework used for generating the reference implementation from the openapi.json specification. lark , the library used to parse the filter language in OPTIMADE queries.","title":"Links"},{"location":"CHANGELOG/","text":"Changelog \u00b6 Unreleased \u00b6 Full Changelog Implemented enhancements: Run both servers as standard #238 Fixed bugs: Queries on aliased/provider fields are broken for nested properties #282 General exceptions not being put into response #281 Issue with CIF export #271 Type-cast inputs for general Error #280 ( CasperWA ) Security fixes: [Security] Bump django from 3.0.4 to 3.0.7 in /.github/workflows #291 ( dependabot-preview[bot] ) Closed issues: Need to set up mkdocs #289 Need to add custom schema entries for unit/sortable (and eventually type) #278 /info/\\<entry-endpoint> missing sortable key under each property #273 Validator does not check that pagination links work #265 available_api_versions is not correctly validated #261 Implementation model should allow for any URL type in source\\_url #260 Extra structure endpoints in the api specification @ odbx #259 Wrong response structure at info endpoint @ cod #258 Missing base url for api's docs @ materialscloud #257 Handling of KNOWN in mongo backend #254 Move run.sh to a python file to be environment-agnostic #81 Merged pull requests: Setup MKDocs for Documentation #294 ( shyamd ) Fix filters on nested provider/aliased fields #285 ( ml-evs ) Use heroku-shields instead of heroku-badge #284 ( CasperWA ) Add OPTIMADE logo to badge by extending JSON #283 ( CasperWA ) Add null check to mongo filtertransformer for KNOWN/UNKNOWN filters #279 ( ml-evs ) Add sortable=True to all properties #274 ( CasperWA ) Make _atom_site_label unique in CIF generation #272 ( CasperWA ) Not so quick fix to allow \"/\" at end of validator URL, plus fixes and tests for --as_type #267 ( ml-evs ) Check pagination links->next with validator #266 ( ml-evs ) Relax HTTP URL constraints on meta->implementation->source_url field. #262 ( ml-evs ) v0.8.1 (2020-04-25) \u00b6 Full Changelog Fixed bugs: Pip install missing some files #252 Merged pull requests: v0.8.1 hotfix #256 ( ml-evs ) Fix 252 missing landing page #253 ( shyamd ) v0.8.0 (2020-04-22) \u00b6 Full Changelog Implemented enhancements: Switch to pydantic's BaseSettings for the config file? #152 Use services for testing/updating dependencies? #96 Remove query constraints for /links-endpoint #244 ( CasperWA ) Add adapters - Base design + 'structures' (+ 'references'... sort of) #241 ( CasperWA ) Add dependabot and last commit date badges #237 ( CasperWA ) Add mongo length operator functionality with length aliases #222 ( ml-evs ) Fixed bugs: Use Path.home() instead of ~ in default config path values #245 Closed issues: Have Dependabot take care of various requirements.txt files as well #249 Remove commented out GH Action job deps\\_clean-install #247 Local testing fails without default config #239 Release only when pushing to master #229 Do we need server.cfg ? #134 Implement LENGTH in query #86 Merged pull requests: Up to v0.8.0 #251 ( CasperWA ) Remove old commented GH Action job #250 ( CasperWA ) Use Path.home() instead of ~ #246 ( CasperWA ) Fix path in default config #243 ( ml-evs ) Fixes Local Tests #240 ( shyamd ) Revert \"Fix github actions for non-release tags\" #236 ( shyamd ) Enable filtering on relationships with mongo #234 ( ml-evs ) Update filter examples and validate optional cases #227 ( ml-evs ) Switch from config init to BaseSettings #226 ( shyamd ) v0.7.1 (2020-03-16) \u00b6 Full Changelog Closed issues: Fix all capitalisation of OPTIMADE #232 Remove validator action from README #230 Merged pull requests: Fix github actions for non-release tags #235 ( shyamd ) Update OPTIMADE capitalisation #233 ( ml-evs ) Update mentions of action in readme #231 ( ml-evs ) v0.7.0 (2020-03-13) \u00b6 Full Changelog Implemented enhancements: Validate all non-optional :filter: examples from the spec #213 ( ml-evs ) Fixed bugs: Some mandatory filter examples from spec do not work #217 Add txt-files in optimade.validator.data to MANIFEST #225 ( CasperWA ) Handle arbitrary nested NOT/AND/OR in queries #221 ( ml-evs ) Closed issues: Validator only validates what we have working, not what is required by the spec #182 Merged pull requests: v0.7.0 release #228 ( ml-evs ) Remove GH Action to validate OPTiMaDe instances #224 ( CasperWA ) Codecov-action supports token-less uploads #220 ( CasperWA ) Update django requirement from >=2.2.9,~=2.2 to >=2.2,\\<4.0 #219 ( dependabot-preview[bot] ) Update elasticsearch-dsl requirement from ~=6.4 to >=6.4,\\<8.0 #218 ( dependabot-preview[bot] ) v0.6.0 (2020-03-06) \u00b6 Full Changelog Implemented enhancements: Possibly add CORS middleware #159 Add debug flag to server #130 Make validator GitHub Action #191 ( CasperWA ) Fixed bugs: meta/query/representation value not cutting off version properly #199 URL for providers.json from Materials-Consortia has changed #186 Relationships don't work when \"/\" present in id #181 Redirect middleware not hitting single-entry endpoints #174 Closed issues: /info/ reports wrong url under available_api_versions #215 Query parameters not handled correctly #208 Test for AvailableApiVersion is correct for the wrong reasons #204 Drop '/optimade' from paths in openapi.json #197 heroku is failing #185 List properties and HAS _ operators missing #98 Checklist for OPTiMaDe v0.10.1 #29 Merged pull requests: Removed /optimade/ prefix in info response #216 ( ml-evs ) Self load data #212 ( shyamd ) Update tests for available_api_versions #211 ( CasperWA ) Up to v0.6.0 #210 ( CasperWA ) Update handling of include parameter (and other query parameters) #209 ( CasperWA ) Skip HAS ONLY test if mongomock version \\<= 3.19.0 #206 ( ml-evs ) Test mandatory queries in validator #205 ( ml-evs ) Fix include query parameter #202 ( CasperWA ) Fix meta.query.representation and remove /optimade in base URLs #201 ( CasperWA ) Use mongo for CI #196 ( ml-evs ) (Cosmetic) updates to models #195 ( CasperWA ) Add CORSMiddleware #194 ( CasperWA ) Add \"debug mode\" #190 ( CasperWA ) Use https://provider.optimade.org/providers.json #187 ( CasperWA ) Fix errors parsing IDs that contain slashes #183 ( ml-evs ) Added default mongo implementations for HAS ALL/ANY/ONLY #173 ( ml-evs ) v0.5.0 (2020-02-13) \u00b6 Full Changelog Implemented enhancements: Implement a landing page for requests to the base URL #169 Fixed bugs: 'minor' and 'patch' versioned base URL prefixes are wrong #177 Closed issues: Handle include standard JSON API query parameter #94 Merged pull requests: Bump to v0.5.0 #179 ( CasperWA ) Correctly create optional versioned base URLs #178 ( CasperWA ) Make mapper aliases configurable #175 ( ml-evs ) Add landing page at base URL #172 ( ml-evs ) Implement include query parameter #163 ( CasperWA ) Add docker for index meta-database #140 ( CasperWA ) v0.4.0 (2020-02-06) \u00b6 Full Changelog Implemented enhancements: switch to pipenv? #37 Reorder tests #162 ( CasperWA ) Fixed bugs: Server app intermingles #161 response\\_fields not working #154 Closed issues: Change page\\_page to page\\_number #165 Add schema-relevant parameters to query parameters #164 Alias optimade/structures/ to optimade/structure #128 Minor changes to specification v0.10.1-develop #115 Update models with new levels of REQUIRED response properties #114 Constraining list/array types in the schema #55 Merged pull requests: Bump to v0.4.0 #168 ( CasperWA ) Describe query parameters in OpenAPI schema #166 ( CasperWA ) Redirect slashed URLs #160 ( CasperWA ) New REQUIRED level properties #153 ( CasperWA ) v0.3.4 (2020-02-04) \u00b6 Full Changelog Implemented enhancements: Include develop or not? Default branch? - Create INSTALL.md #136 Fixed bugs: Excepting non-existent exception #129 Closed issues: disable serving API under /v0.10 and /v0.10.0 by default? #122 PyPI release checklist #67 Merged pull requests: Bump to v0.3.4 #158 ( CasperWA ) Fix heroku badge #157 ( ml-evs ) Move installation instructions #156 ( ml-evs ) Update base URLs #155 ( CasperWA ) Extend OpenAPI/spec description #151 ( CasperWA ) Non Local Mongo #150 ( shyamd ) v0.3.3 (2020-01-24) \u00b6 Full Changelog Fixed bugs: Lark files not being distributed #141 Closed issues: Tests fail with lark-parser>=0.8 #146 Merged pull requests: Updated lark-parser to 0.8.1 #149 ( ml-evs ) Split eager and standard tests to avoid unnecessary badge of shame #148 ( ml-evs ) Bump to v0.3.3 #147 ( CasperWA ) Fix root_validator issues with optional fields and made meta optional #145 ( ml-evs ) Handle JSONDecodeError s in validator #144 ( ml-evs ) v0.3.2 (2020-01-20) \u00b6 Full Changelog Implemented enhancements: Add base URL to configuration file #135 ( CasperWA ) Fixed bugs: Fix load\\_from\\_json #137 ( CasperWA ) Merged pull requests: Make sure relevant package data is included in distributions #142 ( CasperWA ) Add database page limit #139 ( CasperWA ) v0.3.1 (2020-01-17) \u00b6 Full Changelog Merged pull requests: Update requirements #138 ( CasperWA ) v0.3.0 (2020-01-14) \u00b6 Full Changelog Implemented enhancements: Implement optional implementation in top-level meta response #117 Create \"special\" index meta-database server #100 Implement relationships in server #71 Add missing /references endpoint to server #69 Automatically publish version tags to PyPI via GH Actions #107 ( CasperWA ) Using routers #99 ( CasperWA ) Add relationships functionality #91 ( ml-evs ) Added external API validator based on our pydantic models #74 ( ml-evs ) Fixed bugs: The invoke task update-openapijson is incomplete #123 Django vulnerability #108 Closed issues: info endpoint duplicated? #120 Commented-out validator #111 FastAPI v0.44.0 supports pydantic > 1.0.0 #101 Server is missing /links endpoint #89 Make sure all validators are tested #87 The sortable field must be added to models #84 Package structure #72 Possibly make /info/{endpoint} dynamic #70 setuptools package with server as \"extra\" #62 use examples from specs as resources #57 httptools dependency has build issues on GCC/Linux #54 Lark grammar file for v0.9.8 #50 type is missing in response #43 Enforce use of autoformatter #33 switch license to MIT #28 write a lark JSONTransformer / JSONdecoder #26 server.jsonapi has no additionalProperties=false #23 server.jsonapi has no patternProperties #22 Developer-friendly pre-commit openapi.json visual diff #21 add JSON schema API #12 generate static documentation on github from openapi.json #9 test how to generate a client from the openapi.json #8 come up with suggested toolchain for validating existing optimade API against openapi.json #7 add travis test that checks openapi.json is valid OpenAPI spec #6 add 2 examples of how to include documentation in python classes #5 add one-line command to update openapi.json #4 Merged pull requests: Fixed CI readme badge #133 ( ml-evs ) Add meta.description to BaseRelationshipResource #131 ( CasperWA ) Added homepage attribute to LinksResource #127 ( ml-evs ) Updated structure models and validators #126 ( ml-evs ) Minor change to fallback server.cfg #125 ( ml-evs ) Update local OpenAPI schemes prior to copying #124 ( CasperWA ) Update OpenAPI tags #121 ( CasperWA ) A few fixes related to usage as a library #119 ( ml-evs ) Add implementation to top-level meta response #118 ( CasperWA ) Add heroku deployment scripts #116 ( ltalirz ) Reorganize package #113 ( CasperWA ) Introduce grammar v0.10.1 #112 ( CasperWA ) Update to pydantic v1 #110 ( CasperWA ) Minimum requirement of django v2.2.8 #109 ( CasperWA ) Index meta-database #103 ( CasperWA ) restrict pydantic version #97 ( ltalirz ) Add /links #95 ( CasperWA ) Fix data_returned and data_available #93 ( CasperWA ) Use GitHub Actions for CI #92 ( ml-evs ) Remove inappropriate lint messages #90 ( CasperWA ) Fix dependencies #88 ( CasperWA ) Add sortable field to EntryInfoProperty model #85 ( CasperWA ) Validate illegal fields are not present under attributes and relationships #83 ( CasperWA ) Add references endpoint #78 ( CasperWA ) fix travis build #77 ( ltalirz ) Fix manual verification of elements_ratios #76 ( CasperWA ) add automatic PyPI deployment #75 ( ltalirz ) Updates to README and docs for v0.10.0 #68 ( ml-evs ) Adding grammar for v0.10.0 #66 ( fekad ) v0.1.2 (2018-06-14) \u00b6 Full Changelog v0.1.1 (2018-06-13) \u00b6 Full Changelog v0.1.0 (2018-06-05) \u00b6 Full Changelog * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Full Changelog Implemented enhancements: Run both servers as standard #238 Fixed bugs: Queries on aliased/provider fields are broken for nested properties #282 General exceptions not being put into response #281 Issue with CIF export #271 Type-cast inputs for general Error #280 ( CasperWA ) Security fixes: [Security] Bump django from 3.0.4 to 3.0.7 in /.github/workflows #291 ( dependabot-preview[bot] ) Closed issues: Need to set up mkdocs #289 Need to add custom schema entries for unit/sortable (and eventually type) #278 /info/\\<entry-endpoint> missing sortable key under each property #273 Validator does not check that pagination links work #265 available_api_versions is not correctly validated #261 Implementation model should allow for any URL type in source\\_url #260 Extra structure endpoints in the api specification @ odbx #259 Wrong response structure at info endpoint @ cod #258 Missing base url for api's docs @ materialscloud #257 Handling of KNOWN in mongo backend #254 Move run.sh to a python file to be environment-agnostic #81 Merged pull requests: Setup MKDocs for Documentation #294 ( shyamd ) Fix filters on nested provider/aliased fields #285 ( ml-evs ) Use heroku-shields instead of heroku-badge #284 ( CasperWA ) Add OPTIMADE logo to badge by extending JSON #283 ( CasperWA ) Add null check to mongo filtertransformer for KNOWN/UNKNOWN filters #279 ( ml-evs ) Add sortable=True to all properties #274 ( CasperWA ) Make _atom_site_label unique in CIF generation #272 ( CasperWA ) Not so quick fix to allow \"/\" at end of validator URL, plus fixes and tests for --as_type #267 ( ml-evs ) Check pagination links->next with validator #266 ( ml-evs ) Relax HTTP URL constraints on meta->implementation->source_url field. #262 ( ml-evs )","title":"Unreleased"},{"location":"CHANGELOG/#v081-2020-04-25","text":"Full Changelog Fixed bugs: Pip install missing some files #252 Merged pull requests: v0.8.1 hotfix #256 ( ml-evs ) Fix 252 missing landing page #253 ( shyamd )","title":"v0.8.1 (2020-04-25)"},{"location":"CHANGELOG/#v080-2020-04-22","text":"Full Changelog Implemented enhancements: Switch to pydantic's BaseSettings for the config file? #152 Use services for testing/updating dependencies? #96 Remove query constraints for /links-endpoint #244 ( CasperWA ) Add adapters - Base design + 'structures' (+ 'references'... sort of) #241 ( CasperWA ) Add dependabot and last commit date badges #237 ( CasperWA ) Add mongo length operator functionality with length aliases #222 ( ml-evs ) Fixed bugs: Use Path.home() instead of ~ in default config path values #245 Closed issues: Have Dependabot take care of various requirements.txt files as well #249 Remove commented out GH Action job deps\\_clean-install #247 Local testing fails without default config #239 Release only when pushing to master #229 Do we need server.cfg ? #134 Implement LENGTH in query #86 Merged pull requests: Up to v0.8.0 #251 ( CasperWA ) Remove old commented GH Action job #250 ( CasperWA ) Use Path.home() instead of ~ #246 ( CasperWA ) Fix path in default config #243 ( ml-evs ) Fixes Local Tests #240 ( shyamd ) Revert \"Fix github actions for non-release tags\" #236 ( shyamd ) Enable filtering on relationships with mongo #234 ( ml-evs ) Update filter examples and validate optional cases #227 ( ml-evs ) Switch from config init to BaseSettings #226 ( shyamd )","title":"v0.8.0 (2020-04-22)"},{"location":"CHANGELOG/#v071-2020-03-16","text":"Full Changelog Closed issues: Fix all capitalisation of OPTIMADE #232 Remove validator action from README #230 Merged pull requests: Fix github actions for non-release tags #235 ( shyamd ) Update OPTIMADE capitalisation #233 ( ml-evs ) Update mentions of action in readme #231 ( ml-evs )","title":"v0.7.1 (2020-03-16)"},{"location":"CHANGELOG/#v070-2020-03-13","text":"Full Changelog Implemented enhancements: Validate all non-optional :filter: examples from the spec #213 ( ml-evs ) Fixed bugs: Some mandatory filter examples from spec do not work #217 Add txt-files in optimade.validator.data to MANIFEST #225 ( CasperWA ) Handle arbitrary nested NOT/AND/OR in queries #221 ( ml-evs ) Closed issues: Validator only validates what we have working, not what is required by the spec #182 Merged pull requests: v0.7.0 release #228 ( ml-evs ) Remove GH Action to validate OPTiMaDe instances #224 ( CasperWA ) Codecov-action supports token-less uploads #220 ( CasperWA ) Update django requirement from >=2.2.9,~=2.2 to >=2.2,\\<4.0 #219 ( dependabot-preview[bot] ) Update elasticsearch-dsl requirement from ~=6.4 to >=6.4,\\<8.0 #218 ( dependabot-preview[bot] )","title":"v0.7.0 (2020-03-13)"},{"location":"CHANGELOG/#v060-2020-03-06","text":"Full Changelog Implemented enhancements: Possibly add CORS middleware #159 Add debug flag to server #130 Make validator GitHub Action #191 ( CasperWA ) Fixed bugs: meta/query/representation value not cutting off version properly #199 URL for providers.json from Materials-Consortia has changed #186 Relationships don't work when \"/\" present in id #181 Redirect middleware not hitting single-entry endpoints #174 Closed issues: /info/ reports wrong url under available_api_versions #215 Query parameters not handled correctly #208 Test for AvailableApiVersion is correct for the wrong reasons #204 Drop '/optimade' from paths in openapi.json #197 heroku is failing #185 List properties and HAS _ operators missing #98 Checklist for OPTiMaDe v0.10.1 #29 Merged pull requests: Removed /optimade/ prefix in info response #216 ( ml-evs ) Self load data #212 ( shyamd ) Update tests for available_api_versions #211 ( CasperWA ) Up to v0.6.0 #210 ( CasperWA ) Update handling of include parameter (and other query parameters) #209 ( CasperWA ) Skip HAS ONLY test if mongomock version \\<= 3.19.0 #206 ( ml-evs ) Test mandatory queries in validator #205 ( ml-evs ) Fix include query parameter #202 ( CasperWA ) Fix meta.query.representation and remove /optimade in base URLs #201 ( CasperWA ) Use mongo for CI #196 ( ml-evs ) (Cosmetic) updates to models #195 ( CasperWA ) Add CORSMiddleware #194 ( CasperWA ) Add \"debug mode\" #190 ( CasperWA ) Use https://provider.optimade.org/providers.json #187 ( CasperWA ) Fix errors parsing IDs that contain slashes #183 ( ml-evs ) Added default mongo implementations for HAS ALL/ANY/ONLY #173 ( ml-evs )","title":"v0.6.0 (2020-03-06)"},{"location":"CHANGELOG/#v050-2020-02-13","text":"Full Changelog Implemented enhancements: Implement a landing page for requests to the base URL #169 Fixed bugs: 'minor' and 'patch' versioned base URL prefixes are wrong #177 Closed issues: Handle include standard JSON API query parameter #94 Merged pull requests: Bump to v0.5.0 #179 ( CasperWA ) Correctly create optional versioned base URLs #178 ( CasperWA ) Make mapper aliases configurable #175 ( ml-evs ) Add landing page at base URL #172 ( ml-evs ) Implement include query parameter #163 ( CasperWA ) Add docker for index meta-database #140 ( CasperWA )","title":"v0.5.0 (2020-02-13)"},{"location":"CHANGELOG/#v040-2020-02-06","text":"Full Changelog Implemented enhancements: switch to pipenv? #37 Reorder tests #162 ( CasperWA ) Fixed bugs: Server app intermingles #161 response\\_fields not working #154 Closed issues: Change page\\_page to page\\_number #165 Add schema-relevant parameters to query parameters #164 Alias optimade/structures/ to optimade/structure #128 Minor changes to specification v0.10.1-develop #115 Update models with new levels of REQUIRED response properties #114 Constraining list/array types in the schema #55 Merged pull requests: Bump to v0.4.0 #168 ( CasperWA ) Describe query parameters in OpenAPI schema #166 ( CasperWA ) Redirect slashed URLs #160 ( CasperWA ) New REQUIRED level properties #153 ( CasperWA )","title":"v0.4.0 (2020-02-06)"},{"location":"CHANGELOG/#v034-2020-02-04","text":"Full Changelog Implemented enhancements: Include develop or not? Default branch? - Create INSTALL.md #136 Fixed bugs: Excepting non-existent exception #129 Closed issues: disable serving API under /v0.10 and /v0.10.0 by default? #122 PyPI release checklist #67 Merged pull requests: Bump to v0.3.4 #158 ( CasperWA ) Fix heroku badge #157 ( ml-evs ) Move installation instructions #156 ( ml-evs ) Update base URLs #155 ( CasperWA ) Extend OpenAPI/spec description #151 ( CasperWA ) Non Local Mongo #150 ( shyamd )","title":"v0.3.4 (2020-02-04)"},{"location":"CHANGELOG/#v033-2020-01-24","text":"Full Changelog Fixed bugs: Lark files not being distributed #141 Closed issues: Tests fail with lark-parser>=0.8 #146 Merged pull requests: Updated lark-parser to 0.8.1 #149 ( ml-evs ) Split eager and standard tests to avoid unnecessary badge of shame #148 ( ml-evs ) Bump to v0.3.3 #147 ( CasperWA ) Fix root_validator issues with optional fields and made meta optional #145 ( ml-evs ) Handle JSONDecodeError s in validator #144 ( ml-evs )","title":"v0.3.3 (2020-01-24)"},{"location":"CHANGELOG/#v032-2020-01-20","text":"Full Changelog Implemented enhancements: Add base URL to configuration file #135 ( CasperWA ) Fixed bugs: Fix load\\_from\\_json #137 ( CasperWA ) Merged pull requests: Make sure relevant package data is included in distributions #142 ( CasperWA ) Add database page limit #139 ( CasperWA )","title":"v0.3.2 (2020-01-20)"},{"location":"CHANGELOG/#v031-2020-01-17","text":"Full Changelog Merged pull requests: Update requirements #138 ( CasperWA )","title":"v0.3.1 (2020-01-17)"},{"location":"CHANGELOG/#v030-2020-01-14","text":"Full Changelog Implemented enhancements: Implement optional implementation in top-level meta response #117 Create \"special\" index meta-database server #100 Implement relationships in server #71 Add missing /references endpoint to server #69 Automatically publish version tags to PyPI via GH Actions #107 ( CasperWA ) Using routers #99 ( CasperWA ) Add relationships functionality #91 ( ml-evs ) Added external API validator based on our pydantic models #74 ( ml-evs ) Fixed bugs: The invoke task update-openapijson is incomplete #123 Django vulnerability #108 Closed issues: info endpoint duplicated? #120 Commented-out validator #111 FastAPI v0.44.0 supports pydantic > 1.0.0 #101 Server is missing /links endpoint #89 Make sure all validators are tested #87 The sortable field must be added to models #84 Package structure #72 Possibly make /info/{endpoint} dynamic #70 setuptools package with server as \"extra\" #62 use examples from specs as resources #57 httptools dependency has build issues on GCC/Linux #54 Lark grammar file for v0.9.8 #50 type is missing in response #43 Enforce use of autoformatter #33 switch license to MIT #28 write a lark JSONTransformer / JSONdecoder #26 server.jsonapi has no additionalProperties=false #23 server.jsonapi has no patternProperties #22 Developer-friendly pre-commit openapi.json visual diff #21 add JSON schema API #12 generate static documentation on github from openapi.json #9 test how to generate a client from the openapi.json #8 come up with suggested toolchain for validating existing optimade API against openapi.json #7 add travis test that checks openapi.json is valid OpenAPI spec #6 add 2 examples of how to include documentation in python classes #5 add one-line command to update openapi.json #4 Merged pull requests: Fixed CI readme badge #133 ( ml-evs ) Add meta.description to BaseRelationshipResource #131 ( CasperWA ) Added homepage attribute to LinksResource #127 ( ml-evs ) Updated structure models and validators #126 ( ml-evs ) Minor change to fallback server.cfg #125 ( ml-evs ) Update local OpenAPI schemes prior to copying #124 ( CasperWA ) Update OpenAPI tags #121 ( CasperWA ) A few fixes related to usage as a library #119 ( ml-evs ) Add implementation to top-level meta response #118 ( CasperWA ) Add heroku deployment scripts #116 ( ltalirz ) Reorganize package #113 ( CasperWA ) Introduce grammar v0.10.1 #112 ( CasperWA ) Update to pydantic v1 #110 ( CasperWA ) Minimum requirement of django v2.2.8 #109 ( CasperWA ) Index meta-database #103 ( CasperWA ) restrict pydantic version #97 ( ltalirz ) Add /links #95 ( CasperWA ) Fix data_returned and data_available #93 ( CasperWA ) Use GitHub Actions for CI #92 ( ml-evs ) Remove inappropriate lint messages #90 ( CasperWA ) Fix dependencies #88 ( CasperWA ) Add sortable field to EntryInfoProperty model #85 ( CasperWA ) Validate illegal fields are not present under attributes and relationships #83 ( CasperWA ) Add references endpoint #78 ( CasperWA ) fix travis build #77 ( ltalirz ) Fix manual verification of elements_ratios #76 ( CasperWA ) add automatic PyPI deployment #75 ( ltalirz ) Updates to README and docs for v0.10.0 #68 ( ml-evs ) Adding grammar for v0.10.0 #66 ( fekad )","title":"v0.3.0 (2020-01-14)"},{"location":"CHANGELOG/#v012-2018-06-14","text":"Full Changelog","title":"v0.1.2 (2018-06-14)"},{"location":"CHANGELOG/#v011-2018-06-13","text":"Full Changelog","title":"v0.1.1 (2018-06-13)"},{"location":"CHANGELOG/#v010-2018-06-05","text":"Full Changelog * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.0 (2018-06-05)"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 The Materials Consortia is very open to contributions to this package. This may be anything from simple feedback and raising new issues to creating new PRs . We have below recommendations for setting up an environment in which one may develop the package further. Getting Started with Filter Parsing and Transforming \u00b6 Example use: from optimade.filterparser import Parser p = Parser ( version = ( 0 , 9 , 7 )) tree = p . parse ( \"nelements<3\" ) print ( tree ) Tree ( start, [ Tree ( expression, [ Tree ( term, [ Tree ( atom, [ Tree ( comparison, [ Token ( VALUE, 'nelements' ) , Token ( OPERATOR, '<' ) , Token ( VALUE, '3' )])])])])]) print ( tree . pretty ()) start expression term atom comparison nelements < 3 tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) print ( tree . pretty ()) start expression term term atom comparison _mp_bandgap > 5 .0 AND atom comparison _cod_molecular_weight < 350 # Assumes graphviz installed on system (e.g. `conda install -c anaconda graphviz`) and `pip install pydot` from lark.tree import pydot__tree_to_png pydot__tree_to_png ( tree , \"exampletree.png\" ) Flow for Parsing User-Supplied Filter and Converting to Backend Query \u00b6 optimade.filterparser.Parser will take user input to generate a lark.Tree and feed that to a lark.Transformer . E.g., optimade.filtertransformers.mongo.MongoTransformer will turn the tree into something useful for your MondoDB backend: # Example: Converting to MongoDB Query Syntax from optimade.filtertransformers.mongo import MongoTransformer transformer = MongoTransformer () tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) query = transformer . transform ( tree ) print ( query ) { '$and' : [{ '_mp_bandgap' : { '$gt' : 5.0 }}, { '_cod_molecular_weight' : { '$lt' : 350.0 }}]} There is also a basic JSON transformer ( optimade.filtertransformers.json.JSONTransformer ) you can use as a simple example for developing your own transformer. You can also use the JSON output it produces as an easy-to-parse input for a \"transformer\" in your programming language of choice. class JSONTransformer ( Transformer ): def __init__ ( self , compact = False ): self . compact = compact super () . __init__ () def __default__ ( self , data , children ): items = [] for c in children : if isinstance ( c , Token ): token_repr = { \"@module\" : \"lark.lexer\" , \"@class\" : \"Token\" , \"type_\" : c . type , \"value\" : c . value , } if self . compact : del token_repr [ \"@module\" ] del token_repr [ \"@class\" ] items . append ( token_repr ) elif isinstance ( c , dict ): items . append ( c ) else : raise ValueError ( f \"Unknown type { type ( c ) } for tree child { c } \" ) tree_repr = { \"@module\" : \"lark\" , \"@class\" : \"Tree\" , \"data\" : data , \"children\" : items , } if self . compact : del tree_repr [ \"@module\" ] del tree_repr [ \"@class\" ] return tree_repr Developing New Filter Transformers \u00b6 If you would like to add a new transformer, please add: A module (.py file) in the optimade/filtertransformers folder. Any additional Python requirements must be optional and provided as a separate \" extra_requires \" entry in setup.py . Tests in optimade/filtertransformers/tests that are skipped if the required packages fail to import. For examples, please check out existing filter transformers.","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"The Materials Consortia is very open to contributions to this package. This may be anything from simple feedback and raising new issues to creating new PRs . We have below recommendations for setting up an environment in which one may develop the package further.","title":"Contributing"},{"location":"CONTRIBUTING/#getting-started-with-filter-parsing-and-transforming","text":"Example use: from optimade.filterparser import Parser p = Parser ( version = ( 0 , 9 , 7 )) tree = p . parse ( \"nelements<3\" ) print ( tree ) Tree ( start, [ Tree ( expression, [ Tree ( term, [ Tree ( atom, [ Tree ( comparison, [ Token ( VALUE, 'nelements' ) , Token ( OPERATOR, '<' ) , Token ( VALUE, '3' )])])])])]) print ( tree . pretty ()) start expression term atom comparison nelements < 3 tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) print ( tree . pretty ()) start expression term term atom comparison _mp_bandgap > 5 .0 AND atom comparison _cod_molecular_weight < 350 # Assumes graphviz installed on system (e.g. `conda install -c anaconda graphviz`) and `pip install pydot` from lark.tree import pydot__tree_to_png pydot__tree_to_png ( tree , \"exampletree.png\" )","title":"Getting Started with Filter Parsing and Transforming"},{"location":"CONTRIBUTING/#flow-for-parsing-user-supplied-filter-and-converting-to-backend-query","text":"optimade.filterparser.Parser will take user input to generate a lark.Tree and feed that to a lark.Transformer . E.g., optimade.filtertransformers.mongo.MongoTransformer will turn the tree into something useful for your MondoDB backend: # Example: Converting to MongoDB Query Syntax from optimade.filtertransformers.mongo import MongoTransformer transformer = MongoTransformer () tree = p . parse ( '_mp_bandgap > 5.0 AND _cod_molecular_weight < 350' ) query = transformer . transform ( tree ) print ( query ) { '$and' : [{ '_mp_bandgap' : { '$gt' : 5.0 }}, { '_cod_molecular_weight' : { '$lt' : 350.0 }}]} There is also a basic JSON transformer ( optimade.filtertransformers.json.JSONTransformer ) you can use as a simple example for developing your own transformer. You can also use the JSON output it produces as an easy-to-parse input for a \"transformer\" in your programming language of choice. class JSONTransformer ( Transformer ): def __init__ ( self , compact = False ): self . compact = compact super () . __init__ () def __default__ ( self , data , children ): items = [] for c in children : if isinstance ( c , Token ): token_repr = { \"@module\" : \"lark.lexer\" , \"@class\" : \"Token\" , \"type_\" : c . type , \"value\" : c . value , } if self . compact : del token_repr [ \"@module\" ] del token_repr [ \"@class\" ] items . append ( token_repr ) elif isinstance ( c , dict ): items . append ( c ) else : raise ValueError ( f \"Unknown type { type ( c ) } for tree child { c } \" ) tree_repr = { \"@module\" : \"lark\" , \"@class\" : \"Tree\" , \"data\" : data , \"children\" : items , } if self . compact : del tree_repr [ \"@module\" ] del tree_repr [ \"@class\" ] return tree_repr","title":"Flow for Parsing User-Supplied Filter and Converting to Backend Query"},{"location":"CONTRIBUTING/#developing-new-filter-transformers","text":"If you would like to add a new transformer, please add: A module (.py file) in the optimade/filtertransformers folder. Any additional Python requirements must be optional and provided as a separate \" extra_requires \" entry in setup.py . Tests in optimade/filtertransformers/tests that are skipped if the required packages fail to import. For examples, please check out existing filter transformers.","title":"Developing New Filter Transformers"},{"location":"INSTALL/","text":"Installation \u00b6 The index meta-database \u00b6 This package may be used to setup and run an OPTIMADE index meta-database . Install the package via pip install optimade[server] . This python OPTIMADE implementation can be configured in two ways: First, the server can be configured via environment variables prefixed with optimade_ and the corresponding variable names in ServerConfig in the config.py file . These take precedence. These environment variables are not case sensitive, so both OPTIMADE_CONFIG_FILE and optimade_config_file are valid. Second, and the preferred method of configuring the server, is to use a JSON file with the bulk of the configuration and setting the optimade_config_file environment variable to point to the absolute location of this JSON file. By default this points to ~/.optimade.json which can also be used to store the configuration if you don't want to set optimade_config_file . For any configuration parameters not set by the above two, the defaults in built into ServerConfig in optimade.server.config will be used. There is a built-in index meta-database set up to populate a mongomock in-memory database with resources from a static json file containing the child resources you, as a database provider, want to serve under this index meta-database. The location of that json file is controllable using the index_links_path property of the configuration or setting via the environment variable optimade_index_links_path . Running the index meta-database is then as simple as writing ./run.sh index in a terminal from the root of this package. You can find it at the base URL: http://localhost:5001/v0.10.1 . Here is an example of how it may look to start your server: :~$ export OPTIMADE_CONFIG_FILE = /home/optimade_server/config.json :~$ ./path/to/optimade/run.sh index Full development installation \u00b6 The dependencies of this package can be found in setup.py with their latest supported versions. By default, a minimal set of requirements are installed to work with the filter language and the pydantic models. The install mode server (i.e. pip install .[server] ) is sufficient to run a uvicorn server using the mongomock backend (or MongoDB with pymongo , if present). The suite of development and testing tools are installed with via the install modes dev and testing . There are additionally three backend-specific install modes, django , elastic and mongo , as well as the all mode, which installs all dependencies. All contributed Python code, must use the black code formatter, and must pass the flake8 linter that is run automatically on all PRs. # Clone this repository to your computer git clone git@github.com:Materials-Consortia/optimade-python-tools.git cd optimade-python-tools # Ensure a Python>=3.7 (virtual) environment (example below using Anaconda/Miniconda) conda create -n optimade python = 3 .7 conda activate optimade # Install package and dependencies in editable mode (including \"dev\" requirements). pip install -e \".[dev]\" # Run the tests with pytest py.test # Install pre-commit environment (e.g., auto-formats code on `git commit`) pre-commit install # Optional: Install MongoDB (and set `use_real_mongo = true`) # Below method installs in conda environment and # - starts server in background # - ensures and uses ~/dbdata directory to store data conda install -c anaconda mongodb mkdir -p ~/dbdata && mongod --dbpath ~/dbdata --syslog --fork # Start a development server (auto-reload on file changes at http://localhost:5000 # You can also execute ./run.sh uvicorn optimade.server.main:app --reload --port 5000 # View auto-generated docs open http://localhost:5000/docs # View Open API Schema open http://localhost:5000/openapi.json When developing, you can run both the server and an index meta-database server at the same time (from two separate terminals). Running the following: ./run.sh index # or uvicorn optimade.server.main_index:app --reload --port 5001 will run the index meta-database server at http://localhost:5001/v0.10.1 .","title":"Installation"},{"location":"INSTALL/#installation","text":"","title":"Installation"},{"location":"INSTALL/#the-index-meta-database","text":"This package may be used to setup and run an OPTIMADE index meta-database . Install the package via pip install optimade[server] . This python OPTIMADE implementation can be configured in two ways: First, the server can be configured via environment variables prefixed with optimade_ and the corresponding variable names in ServerConfig in the config.py file . These take precedence. These environment variables are not case sensitive, so both OPTIMADE_CONFIG_FILE and optimade_config_file are valid. Second, and the preferred method of configuring the server, is to use a JSON file with the bulk of the configuration and setting the optimade_config_file environment variable to point to the absolute location of this JSON file. By default this points to ~/.optimade.json which can also be used to store the configuration if you don't want to set optimade_config_file . For any configuration parameters not set by the above two, the defaults in built into ServerConfig in optimade.server.config will be used. There is a built-in index meta-database set up to populate a mongomock in-memory database with resources from a static json file containing the child resources you, as a database provider, want to serve under this index meta-database. The location of that json file is controllable using the index_links_path property of the configuration or setting via the environment variable optimade_index_links_path . Running the index meta-database is then as simple as writing ./run.sh index in a terminal from the root of this package. You can find it at the base URL: http://localhost:5001/v0.10.1 . Here is an example of how it may look to start your server: :~$ export OPTIMADE_CONFIG_FILE = /home/optimade_server/config.json :~$ ./path/to/optimade/run.sh index","title":"The index meta-database"},{"location":"INSTALL/#full-development-installation","text":"The dependencies of this package can be found in setup.py with their latest supported versions. By default, a minimal set of requirements are installed to work with the filter language and the pydantic models. The install mode server (i.e. pip install .[server] ) is sufficient to run a uvicorn server using the mongomock backend (or MongoDB with pymongo , if present). The suite of development and testing tools are installed with via the install modes dev and testing . There are additionally three backend-specific install modes, django , elastic and mongo , as well as the all mode, which installs all dependencies. All contributed Python code, must use the black code formatter, and must pass the flake8 linter that is run automatically on all PRs. # Clone this repository to your computer git clone git@github.com:Materials-Consortia/optimade-python-tools.git cd optimade-python-tools # Ensure a Python>=3.7 (virtual) environment (example below using Anaconda/Miniconda) conda create -n optimade python = 3 .7 conda activate optimade # Install package and dependencies in editable mode (including \"dev\" requirements). pip install -e \".[dev]\" # Run the tests with pytest py.test # Install pre-commit environment (e.g., auto-formats code on `git commit`) pre-commit install # Optional: Install MongoDB (and set `use_real_mongo = true`) # Below method installs in conda environment and # - starts server in background # - ensures and uses ~/dbdata directory to store data conda install -c anaconda mongodb mkdir -p ~/dbdata && mongod --dbpath ~/dbdata --syslog --fork # Start a development server (auto-reload on file changes at http://localhost:5000 # You can also execute ./run.sh uvicorn optimade.server.main:app --reload --port 5000 # View auto-generated docs open http://localhost:5000/docs # View Open API Schema open http://localhost:5000/openapi.json When developing, you can run both the server and an index meta-database server at the same time (from two separate terminals). Running the following: ./run.sh index # or uvicorn optimade.server.main_index:app --reload --port 5001 will run the index meta-database server at http://localhost:5001/v0.10.1 .","title":"Full development installation"},{"location":"reference/models/","text":"baseinfo \u00b6 AvailableApiVersion ( BaseModel ) pydantic-model \u00b6 A JSON object containing information about an available API version url : AnyHttpUrl pydantic-field required \u00b6 a string specifying a versioned base URL that MUST adhere to the rules in section Base URL version : ConstrainedStrValue pydantic-field required \u00b6 a string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'. crosscheck_url_and_version ( values ) classmethod \u00b6 Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) url_version = tuple ( int ( val ) for val in url_version . split ( \".\" )) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \".\" )) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values url_must_be_versioned_base_url ( v ) classmethod \u00b6 The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v BaseInfoAttributes ( BaseModel ) pydantic-model \u00b6 Attributes for Base URL Info endpoint api_version : str pydantic-field required \u00b6 Presently used version of the OPTIMADE API available_api_versions : List [ optimade . models . baseinfo . AvailableApiVersion ] pydantic-field required \u00b6 A list of dictionaries of available API versions at other base URLs available_endpoints : List [ str ] pydantic-field required \u00b6 List of available endpoints (i.e., the string to be appended to the versioned base URL). entry_types_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 Available entry endpoints as a function of output formats. formats : List [ str ] pydantic-field \u00b6 List of available output formats. is_index : bool pydantic-field \u00b6 If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false). entries \u00b6 EntryInfoProperty ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 description of the entry property sortable : bool pydantic-field \u00b6 defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true . unit : str pydantic-field \u00b6 the physical unit of the entry property EntryInfoResource ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 description of the entry formats : List [ str ] pydantic-field required \u00b6 list of available output formats. output_fields_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 a dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary. properties : Dict [ str , optimade . models . entries . EntryInfoProperty ] pydantic-field required \u00b6 a dictionary describing queryable properties for this entry type, where each key is a property ID. EntryRelationships ( Relationships ) pydantic-model \u00b6 This model wraps the JSON API Relationships to include type-specific top level keys. references : ReferenceRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the references type. structures : StructureRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the structures type. EntryResourceAttributes ( Attributes ) pydantic-model \u00b6 Contains key-value pairs representing the entry's properties. immutable_id : str pydantic-field \u00b6 The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. - Type : string. - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : :val: \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" :val: \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.) last_modified : datetime pydantic-field required \u00b6 Date and time representing when the entry was last modified. - Type : timestamp. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter :query-param: response_fields is present and does not include this property. Example : As part of JSON response format: :VAL: \"2007-04-05T14:30Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format <https://tools.ietf.org/html/rfc3339#section-5.6> __ string.) index_metadb \u00b6 IndexInfoAttributes ( BaseInfoAttributes ) pydantic-model \u00b6 Attributes for Base URL Info endpoint for an Index Meta-Database IndexInfoResource ( BaseInfoResource ) pydantic-model \u00b6 Index Meta-Database Base URL Info endpoint resource IndexRelationship ( BaseModel ) pydantic-model \u00b6 Index Meta-Database relationship data : RelatedLinksResource pydantic-field required \u00b6 JSON API resource linkage. It MUST be either null or contain a single Links identifier object with the fields 'id' and 'type' RelatedLinksResource ( BaseResource ) pydantic-model \u00b6 A related Links resource object jsonapi \u00b6 This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/ Attributes ( BaseModel ) pydantic-model \u00b6 Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type BaseResource ( BaseModel ) pydantic-model \u00b6 Minimum requirements to represent a Resource id : str pydantic-field required \u00b6 Resource ID type : str pydantic-field required \u00b6 Resource type Error ( BaseModel ) pydantic-model \u00b6 An error response code : str pydantic-field \u00b6 an application-specific error code, expressed as a string value. detail : str pydantic-field \u00b6 A human-readable explanation specific to this occurrence of the problem. id : str pydantic-field \u00b6 A unique identifier for this particular occurrence of the problem. links : ErrorLinks pydantic-field \u00b6 A links object storing about meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the error. source : ErrorSource pydantic-field \u00b6 An object containing references to the source of the error status : str pydantic-field \u00b6 the HTTP status code applicable to this problem, expressed as a string value. title : str pydantic-field \u00b6 A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization. __hash__ ( self ) special \u00b6 Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ()) ErrorLinks ( BaseModel ) pydantic-model \u00b6 A Links object specific to Error objects about : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that leads to further details about this particular occurrence of the problem. ErrorSource ( BaseModel ) pydantic-model \u00b6 an object containing references to the source of the error parameter : str pydantic-field \u00b6 a string indicating which URI query parameter caused the error. pointer : str pydantic-field \u00b6 a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute]. JsonApi ( BaseModel ) pydantic-model \u00b6 An object describing the server's implementation meta : Meta pydantic-field \u00b6 Non-standard meta information version : str pydantic-field \u00b6 Version of the json API used Link ( BaseModel ) pydantic-model \u00b6 A link MUST be represented as either: a string containing the link's URL or a link object. href : AnyUrl pydantic-field required \u00b6 a string containing the link\u2019s URL. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the link. Meta ( BaseModel ) pydantic-model \u00b6 Non-standard meta-information that can not be represented as an attribute or relationship. Relationship ( BaseModel ) pydantic-model \u00b6 Representation references from the resource object in which it\u2019s defined to other resource objects. data : Union [ optimade . models . jsonapi . BaseResource , List [ optimade . models . jsonapi . BaseResource ]] pydantic-field \u00b6 Resource linkage links : RelationshipLinks pydantic-field \u00b6 a links object containing at least one of the following: self, related meta : Meta pydantic-field \u00b6 a meta object that contains non-standard meta-information about the relationship. RelationshipLinks ( BaseModel ) pydantic-model \u00b6 A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object. related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link to itself Relationships ( BaseModel ) pydantic-model \u00b6 Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id Resource ( BaseResource ) pydantic-model \u00b6 Resource objects appear in a JSON:API document to represent resources. attributes : Attributes pydantic-field \u00b6 an attributes object representing some of the resource\u2019s data. links : ResourceLinks pydantic-field \u00b6 a links object containing links related to the resource. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship. relationships : Relationships pydantic-field \u00b6 a relationships object describing relationships between the resource and other JSON:API resources. ResourceLinks ( BaseModel ) pydantic-model \u00b6 A Resource Links object self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that identifies the resource represented by the resource object. Response ( BaseModel ) pydantic-model \u00b6 A top-level response data : Union [ NoneType , optimade . models . jsonapi . Resource , List [ optimade . models . jsonapi . Resource ]] pydantic-field \u00b6 Outputted Data errors : List [ optimade . models . jsonapi . Error ] pydantic-field \u00b6 A list of unique errors included : List [ optimade . models . jsonapi . Resource ] pydantic-field \u00b6 A list of unique included resources jsonapi : JsonApi pydantic-field \u00b6 Information about the JSON API used links : ToplevelLinks pydantic-field \u00b6 Links associated with the primary data or errors meta : Meta pydantic-field \u00b6 A meta object containing non-standard information related to the Success __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ToplevelLinks ( BaseModel ) pydantic-model \u00b6 A set of Links objects, possibly including pagination first : AnyUrl pydantic-field \u00b6 The first page of data last : AnyUrl pydantic-field \u00b6 The last page of data next : AnyUrl pydantic-field \u00b6 The next page of data prev : AnyUrl pydantic-field \u00b6 The previous page of data related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link to itself links \u00b6 LinksResource ( EntryResource ) pydantic-model \u00b6 A Links endpoint resource object LinksResourceAttributes ( Attributes ) pydantic-model \u00b6 Links endpoint resource object attributes base_url : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to the base URL for this implementation description : str pydantic-field required \u00b6 Human-readable description for the OPTIMADE API implementation a client may provide in a list to an end-user. homepage : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to a homepage URL for this implementation link_type : str pydantic-field required \u00b6 The link type of the represented resource in relation to this implementation. MUST be one of these values: 'child', 'root', 'external', 'providers'. name : str pydantic-field required \u00b6 Human-readable name for the OPTIMADE API implementation a client may provide in a list to an end-user. optimade_json \u00b6 Modified JSON API v1.0 for OPTIMADE API BaseRelationshipMeta ( Meta ) pydantic-model \u00b6 Specific meta field for base relationship resource description : str pydantic-field required \u00b6 OPTIONAL human-readable description of the relationship BaseRelationshipResource ( BaseResource ) pydantic-model \u00b6 Minimum requirements to represent a relationship resource meta : BaseRelationshipMeta pydantic-field \u00b6 Relationship meta field. MUST contain 'description' if supplied. Implementation ( BaseModel ) pydantic-model \u00b6 Information on the server implementation maintainer : ImplementationMaintainer pydantic-field \u00b6 A dictionary providing details about the maintainer of the implementation. name : str pydantic-field \u00b6 name of the implementation source_url : AnyUrl pydantic-field \u00b6 URL of the implementation source, either downloadable archive or version control system version : str pydantic-field \u00b6 version string of the current implementation ImplementationMaintainer ( BaseModel ) pydantic-model \u00b6 Details about the maintainer of the implementation email : EmailStr pydantic-field required \u00b6 the maintainer's email address OptimadeError ( Error ) pydantic-model \u00b6 detail MUST be present Provider ( BaseModel ) pydantic-model \u00b6 Information on the database provider of the implementation. description : str pydantic-field required \u00b6 a longer description of the database provider homepage : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object. index_base_url : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 a JSON API links object pointing to the base URL for the index meta-database as specified in Appendix 1, either directly as a string, or as a link object. name : str pydantic-field required \u00b6 a short name for the database provider prefix : str pydantic-field required \u00b6 database-provider-specific prefix as found in Appendix 1. Relationship ( Relationship ) pydantic-model \u00b6 Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource ResponseMeta ( Meta ) pydantic-model \u00b6 A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix. api_version : str pydantic-field required \u00b6 a string containing the version of the API implementation, e.g. v0.9.5 data_available : int pydantic-field \u00b6 an integer containing the total number of data objects available in the database data_returned : ConstrainedIntValue pydantic-field required \u00b6 an integer containing the number of data objects returned for the query. implementation : Implementation pydantic-field \u00b6 a dictionary describing the server implementation last_id : str pydantic-field \u00b6 a string containing the last ID returned more_data_available : bool pydantic-field required \u00b6 false if all data has been returned, and true if not. provider : Provider pydantic-field required \u00b6 information on the database provider of the implementation. query : ResponseMetaQuery pydantic-field required \u00b6 information on the query that was requested response_message : str pydantic-field \u00b6 response string from the server time_stamp : datetime pydantic-field required \u00b6 a string containing the date and time at which the query was exexcuted warnings : List [ optimade . models . optimade_json . Warnings ] pydantic-field \u00b6 List of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status, representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects. ResponseMetaQuery ( BaseModel ) pydantic-model \u00b6 Information on the query that was requested. representation : str pydantic-field required \u00b6 a string with the part of the URL that follows the base URL. Example: '/structures?' Success ( Response ) pydantic-model \u00b6 errors are not allowed __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. either_data_meta_or_errors_must_be_set ( values ) classmethod \u00b6 Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values Warnings ( OptimadeError ) pydantic-model \u00b6 OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \" warning \" . The field detail MUST be present and SHOULD contain a non - critical message , e . g ., reporting unrecognized search attributes or deprecated features . Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class. type : str pydantic-field \u00b6 Warnings must be of type \"warning\" references \u00b6 Person ( BaseModel ) pydantic-model \u00b6 firstname : str pydantic-field \u00b6 First name of the person. lastname : str pydantic-field \u00b6 Last name of the person. ReferenceResource ( EntryResource ) pydantic-model \u00b6 The :entry: references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , type , volume , year : Meanings of these properties match the BibTeX specification <http://bibtexml.sourceforge.net/btxdoc.pdf> __, values are strings; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL, i.e., any of the properties MAY be :val: null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties. ReferenceResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification . address : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. annote : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. authors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the authors of the reference. bib_type : str pydantic-field \u00b6 Type of the reference, corresponding to the type property in the BiBTeX specification. booktitle : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. chapter : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. crossref : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. doi : str pydantic-field \u00b6 The digital object identifier of the reference. edition : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. editors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the editors of the reference. howpublished : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. institution : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. journal : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. key : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. month : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. note : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. number : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. organization : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. pages : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. publisher : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. school : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. series : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. title : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. url : AnyUrl pydantic-field \u00b6 The URL of the reference. volume : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. year : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. responses \u00b6 EntryInfoResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. EntryResponseMany ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. EntryResponseOne ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ErrorResponse ( Response ) pydantic-model \u00b6 errors MUST be present and data MUST be skipped __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. IndexInfoResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. InfoResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. LinksResponse ( EntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ReferenceResponseMany ( EntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ReferenceResponseOne ( EntryResponseOne ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. StructureResponseMany ( EntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. StructureResponseOne ( EntryResponseOne ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. structures \u00b6 Assembly ( BaseModel ) pydantic-model \u00b6 A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). group_probabilities : List [ float ] pydantic-field required \u00b6 Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _. sites_in_groups : List [ List [ int ]] pydantic-field required \u00b6 Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth. Periodicity ( IntEnum ) \u00b6 An enumeration. Species ( BaseModel ) pydantic-model \u00b6 A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13. chemical_symbols : List [ str ] pydantic-field required \u00b6 MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). concentration : List [ float ] pydantic-field required \u00b6 MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : float pydantic-field \u00b6 If present MUST be a float expressed in a.m.u. original_name : str pydantic-field \u00b6 Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _). StructureResource ( EntryResource ) pydantic-model \u00b6 Representing a structure. StructureResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions. assemblies : List [ optimade . models . structures . Assembly ] pydantic-field \u00b6 A description of groups of sites that are statistically correlated. - Type : list of dictionary with keys: :property: sites_in_groups : list of list of integers (REQUIRED) :property: group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. If present, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _. If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: .. code:: jsonc { \"cartesian_site_positions\": [[0,0,0]], \"species_at_sites\": [\"SiGe-vac\"], \"species\": [ { \"name\": \"SiGe-vac\", \"chemical_symbols\": [\"Si\", \"Ge\", \"vacancy\"], \"concentration\": [0.3, 0.5, 0.2] } ] // ... } Using multiple species and the assemblies: .. code:: jsonc { \"cartesian_site_positions\": [ [0,0,0], [0,0,0], [0,0,0] ], \"species_at_sites\": [\"Si\", \"Ge\", \"vac\"], \"species\": { \"Si\": { \"chemical_symbols\": [\"Si\"], \"concentration\": [1.0] }, \"Ge\": { \"chemical_symbols\": [\"Ge\"], \"concentration\": [1.0] }, \"vac\": { \"chemical_symbols\": [\"vacancy\"], \"concentration\": [1.0] } }, \"assemblies\": [ { \"sites_in_groups\": [ [0], [1], [2] ], \"group_probabilities\": [0.3, 0.5, 0.2] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: .. code:: jsonc { \"assemblies\": [ { \"sites_in_groups\": [ [0], [1] ], \"group_probabilities\": [0.2, 0.8], }, { \"sites_in_groups\": [ [2], [3] ], \"group_probabilities\": [0.3, 0.7] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability). cartesian_site_positions : List [ Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float ]]] pydantic-field required \u00b6 Cartesian positions of each site. A site is an atom, a site potentially occupied by an atom, or a placeholder for a virtual mixture of atoms (e.g., in a virtual crystal approximation). - Type : list of list of floats and/or unknown values - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length N times 3, where N is the number of sites in the structure. An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies _). If a component of the position is unknown, the :val: null value should be provided instead (see section Properties with unknown value ). Otherwise, it should be a float value, expressed in angstrom (\u00c5). If at least one of the coordinates is unknown, the correct flag in the list property structure_features MUST be set. Notes : (for implementers) While this is unrelated to this OPTIMADE specification: If you decide to store internally the :property: cartesian_site_positions as a float array, you might want to represent :val: null values with :field-val: NaN values. The latter being valid float numbers in the IEEE 754 standard in IEEE 754-1985 <https://doi.org/10.1109/IEEESTD.1985.82928> and in the updated version IEEE 754-2008 <https://doi.org/10.1109/IEEESTD.2008.4610935> . Examples : :val: [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin. chemical_formula_anonymous : str pydantic-field required \u00b6 The anonymous formula is the :property: chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : :val: \"A2B\" :val: \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is :filter: chemical_formula_anonymous=\"A2B\" . chemical_formula_descriptive : str pydantic-field required \u00b6 The chemical formula for a structure as a string in a form chosen by the API implementation. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the :property: chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry <https://www.qmul.ac.uk/sbcs/iupac/bibliog/blue.html> __. Examples : :val: \"(H2O)2 Na\" :val: \"NaCl\" :val: \"CaCO3\" :val: \"CCaO3\" :val: \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: :filter: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: :filter: chemical_formula_descriptive CONTAINS \"H2O\" . chemical_formula_hill : str pydantic-field \u00b6 The chemical formula for a structure in Hill form <https://dx.doi.org/10.1021/ja02046a005> __ with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : Support for queries on these properties are OPTIONAL. If supported, only a subset of filter operators MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, :property: chemical_formula_hill is :val: \"H2O2\" (i.e., not :val: \"HO\" , nor :val: \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in Hill order <https://dx.doi.org/10.1021/ja02046a005> __, followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : :val: \"H2O2\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_hill=\"H2O2\" . chemical_formula_reduced : str pydantic-field required \u00b6 The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate querying on formula components are instead recommended to be formulated using set-type filter operators on the multi valued :property: elements and :property: elements_proportions properties. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : :val: \"H2NaO\" :val: \"ClNa\" :val: \"CCaO3\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_reduced=\"H2NaO\" . dimension_types : Tuple [ optimade . models . structures . Periodicity , optimade . models . structures . Periodicity , optimade . models . structures . Periodicity ] pydantic-field required \u00b6 List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ). This list indicates if the direction is periodic (value :val: 1 ) or non-periodic (value :val: 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in property lattice_vectors and not the Cartesian x, y, z directions. - Type : list of integers. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. Support for equality comparison is REQUIRED, support for other comparison operators are OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: :val: [0, 0, 0] For a wire along the direction specified by the third lattice vector: :val: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: :val: [1, 0, 1] For a bulk 3D system: :val: [1, 1, 1] elements : List [ str ] pydantic-field required \u00b6 Names of the different elements present in the structure. - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The strings are the chemical symbols, written as uppercase letter plus optional lowercase letters. The order MUST be alphabetical. Note: This may not contain the \"x\" that is suggested in chemical_symbols for the :property: species property. Examples : :val: [\"Si\"] :val: [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: :filter: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use :filter: elements HAS ALL \"Si\", \"Al\", \"O\" AND LENGTH elements = 3 . elements_ratios : List [ float ] pydantic-field required \u00b6 Relative proportions of different elements in the structure. - Type : list of floats - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : :val: [1.0] :val: [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally not recommended. A filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: :filter: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 . lattice_vectors : Tuple [ Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float , NoneType ]], Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float , NoneType ]], Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float ]]] pydantic-field \u00b6 The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). - Type : list of list of floats. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. This property MUST be an array of dimensions 3 times 3 regardless of the elements of :property: dimension_types . The vectors SHOULD by convention be chosen so the determinant of the :property: lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. All three elements of the inner lists of floats MAY be :val: null for non-periodic dimensions, i.e., those dimensions for which :property: dimension_types is :val: 0 . Examples : :val: [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is :val: (4, 0, 0) , i.e., a vector aligned along the :val: x axis of length 4 \u00c5; the second vector is :val: (0, 4, 0) ; and the third vector is :val: (0, 1, 4) . nelements : int pydantic-field required \u00b6 Number of different elements in the structure as an integer. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Example : :val: 3 Querying : Note: queries on this property can equivalently be formulated using :filter-fragment: LENGTH elements . A filter that matches structures that have exactly 4 elements: :filter: nelements=4 . A filter that matches structures that have between 2 and 7 elements: :filter: nelements>=2 AND nelements<=7 . nsites : int pydantic-field required \u00b6 An integer specifying the length of the :property: cartesian_site_positions property. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Examples : :val: 42 Query examples : Match only structures with exactly 4 sites: :filter: nsites=4 Match structures that have between 2 and 7 sites: :filter: nsites>=2 AND nsites<=7 species : List [ optimade . models . structures . Species ] pydantic-field required \u00b6 A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. - Type : list of dictionary with keys: :property: name : string (REQUIRED) :property: chemical_symbols : list of strings (REQUIRED) :property: concentration : list of float (REQUIRED) :property: mass : float (OPTIONAL) :property: original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the :property: species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). concentration : REQUIRED; MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : OPTIONAL. If present MUST be a float expressed in a.m.u. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., :val: \"Ti\" for titanium, :val: \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species :val: {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13. species_at_sites : List [ str ] pydantic-field required \u00b6 Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions _). Each species MUST have a unique name. Each species name mentioned in the :property: species_at_sites list MUST be described in the list property species _ (i.e. for each value in the :property: species_at_sites list there MUST exist exactly one dictionary in the :property: species list with the :property: name attribute equal to the corresponding :property: species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : :val: [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled :val: \"Ti\" and the second a species labeled :val: \"O2\" . structure_features : List [ str ] pydantic-field required \u00b6 A list of strings that flag which special features are used by the structure. - Type : list of strings - Requirements/Conventions : Support : REQUIRED, MUST NOT be :val: null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : :val: disorder : This flag MUST be present if any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element. :val: unknown_positions : This flag MUST be present if at least one component of the :property: cartesian_site_positions list of lists has value :val: null . :val: assemblies : This flag MUST be present if the property assemblies _ is present. Examples : A structure having unknown positions and using assemblies: :val: [\"assemblies\", \"unknown_positions\"]","title":"Models"},{"location":"reference/models/#optimade.models.baseinfo","text":"","title":"baseinfo"},{"location":"reference/models/#optimade.models.baseinfo.AvailableApiVersion","text":"A JSON object containing information about an available API version","title":"AvailableApiVersion"},{"location":"reference/models/#optimade.models.baseinfo.AvailableApiVersion.url","text":"a string specifying a versioned base URL that MUST adhere to the rules in section Base URL","title":"url"},{"location":"reference/models/#optimade.models.baseinfo.AvailableApiVersion.version","text":"a string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'.","title":"version"},{"location":"reference/models/#optimade.models.baseinfo.AvailableApiVersion.crosscheck_url_and_version","text":"Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) url_version = tuple ( int ( val ) for val in url_version . split ( \".\" )) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \".\" )) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values","title":"crosscheck_url_and_version()"},{"location":"reference/models/#optimade.models.baseinfo.AvailableApiVersion.url_must_be_versioned_base_url","text":"The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v","title":"url_must_be_versioned_base_url()"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes","text":"Attributes for Base URL Info endpoint","title":"BaseInfoAttributes"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes.api_version","text":"Presently used version of the OPTIMADE API","title":"api_version"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes.available_api_versions","text":"A list of dictionaries of available API versions at other base URLs","title":"available_api_versions"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes.available_endpoints","text":"List of available endpoints (i.e., the string to be appended to the versioned base URL).","title":"available_endpoints"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes.entry_types_by_format","text":"Available entry endpoints as a function of output formats.","title":"entry_types_by_format"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes.formats","text":"List of available output formats.","title":"formats"},{"location":"reference/models/#optimade.models.baseinfo.BaseInfoAttributes.is_index","text":"If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false).","title":"is_index"},{"location":"reference/models/#optimade.models.entries","text":"","title":"entries"},{"location":"reference/models/#optimade.models.entries.EntryInfoProperty","text":"","title":"EntryInfoProperty"},{"location":"reference/models/#optimade.models.entries.EntryInfoProperty.description","text":"description of the entry property","title":"description"},{"location":"reference/models/#optimade.models.entries.EntryInfoProperty.sortable","text":"defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true .","title":"sortable"},{"location":"reference/models/#optimade.models.entries.EntryInfoProperty.unit","text":"the physical unit of the entry property","title":"unit"},{"location":"reference/models/#optimade.models.entries.EntryInfoResource","text":"","title":"EntryInfoResource"},{"location":"reference/models/#optimade.models.entries.EntryInfoResource.description","text":"description of the entry","title":"description"},{"location":"reference/models/#optimade.models.entries.EntryInfoResource.formats","text":"list of available output formats.","title":"formats"},{"location":"reference/models/#optimade.models.entries.EntryInfoResource.output_fields_by_format","text":"a dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary.","title":"output_fields_by_format"},{"location":"reference/models/#optimade.models.entries.EntryInfoResource.properties","text":"a dictionary describing queryable properties for this entry type, where each key is a property ID.","title":"properties"},{"location":"reference/models/#optimade.models.entries.EntryRelationships","text":"This model wraps the JSON API Relationships to include type-specific top level keys.","title":"EntryRelationships"},{"location":"reference/models/#optimade.models.entries.EntryRelationships.references","text":"Object containing links to relationships with entries of the references type.","title":"references"},{"location":"reference/models/#optimade.models.entries.EntryRelationships.structures","text":"Object containing links to relationships with entries of the structures type.","title":"structures"},{"location":"reference/models/#optimade.models.entries.EntryResourceAttributes","text":"Contains key-value pairs representing the entry's properties.","title":"EntryResourceAttributes"},{"location":"reference/models/#optimade.models.entries.EntryResourceAttributes.immutable_id","text":"The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. - Type : string. - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : :val: \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" :val: \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.)","title":"immutable_id"},{"location":"reference/models/#optimade.models.entries.EntryResourceAttributes.last_modified","text":"Date and time representing when the entry was last modified. - Type : timestamp. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter :query-param: response_fields is present and does not include this property. Example : As part of JSON response format: :VAL: \"2007-04-05T14:30Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format <https://tools.ietf.org/html/rfc3339#section-5.6> __ string.)","title":"last_modified"},{"location":"reference/models/#optimade.models.index_metadb","text":"","title":"index_metadb"},{"location":"reference/models/#optimade.models.index_metadb.IndexInfoAttributes","text":"Attributes for Base URL Info endpoint for an Index Meta-Database","title":"IndexInfoAttributes"},{"location":"reference/models/#optimade.models.index_metadb.IndexInfoResource","text":"Index Meta-Database Base URL Info endpoint resource","title":"IndexInfoResource"},{"location":"reference/models/#optimade.models.index_metadb.IndexRelationship","text":"Index Meta-Database relationship","title":"IndexRelationship"},{"location":"reference/models/#optimade.models.index_metadb.IndexRelationship.data","text":"JSON API resource linkage. It MUST be either null or contain a single Links identifier object with the fields 'id' and 'type'","title":"data"},{"location":"reference/models/#optimade.models.index_metadb.RelatedLinksResource","text":"A related Links resource object","title":"RelatedLinksResource"},{"location":"reference/models/#optimade.models.jsonapi","text":"This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/","title":"jsonapi"},{"location":"reference/models/#optimade.models.jsonapi.Attributes","text":"Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type","title":"Attributes"},{"location":"reference/models/#optimade.models.jsonapi.BaseResource","text":"Minimum requirements to represent a Resource","title":"BaseResource"},{"location":"reference/models/#optimade.models.jsonapi.BaseResource.id","text":"Resource ID","title":"id"},{"location":"reference/models/#optimade.models.jsonapi.BaseResource.type","text":"Resource type","title":"type"},{"location":"reference/models/#optimade.models.jsonapi.Error","text":"An error response","title":"Error"},{"location":"reference/models/#optimade.models.jsonapi.Error.code","text":"an application-specific error code, expressed as a string value.","title":"code"},{"location":"reference/models/#optimade.models.jsonapi.Error.detail","text":"A human-readable explanation specific to this occurrence of the problem.","title":"detail"},{"location":"reference/models/#optimade.models.jsonapi.Error.id","text":"A unique identifier for this particular occurrence of the problem.","title":"id"},{"location":"reference/models/#optimade.models.jsonapi.Error.links","text":"A links object storing about","title":"links"},{"location":"reference/models/#optimade.models.jsonapi.Error.meta","text":"a meta object containing non-standard meta-information about the error.","title":"meta"},{"location":"reference/models/#optimade.models.jsonapi.Error.source","text":"An object containing references to the source of the error","title":"source"},{"location":"reference/models/#optimade.models.jsonapi.Error.status","text":"the HTTP status code applicable to this problem, expressed as a string value.","title":"status"},{"location":"reference/models/#optimade.models.jsonapi.Error.title","text":"A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.","title":"title"},{"location":"reference/models/#optimade.models.jsonapi.Error.__hash__","text":"Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ())","title":"__hash__()"},{"location":"reference/models/#optimade.models.jsonapi.ErrorLinks","text":"A Links object specific to Error objects","title":"ErrorLinks"},{"location":"reference/models/#optimade.models.jsonapi.ErrorLinks.about","text":"A link that leads to further details about this particular occurrence of the problem.","title":"about"},{"location":"reference/models/#optimade.models.jsonapi.ErrorSource","text":"an object containing references to the source of the error","title":"ErrorSource"},{"location":"reference/models/#optimade.models.jsonapi.ErrorSource.parameter","text":"a string indicating which URI query parameter caused the error.","title":"parameter"},{"location":"reference/models/#optimade.models.jsonapi.ErrorSource.pointer","text":"a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute].","title":"pointer"},{"location":"reference/models/#optimade.models.jsonapi.JsonApi","text":"An object describing the server's implementation","title":"JsonApi"},{"location":"reference/models/#optimade.models.jsonapi.JsonApi.meta","text":"Non-standard meta information","title":"meta"},{"location":"reference/models/#optimade.models.jsonapi.JsonApi.version","text":"Version of the json API used","title":"version"},{"location":"reference/models/#optimade.models.jsonapi.Link","text":"A link MUST be represented as either: a string containing the link's URL or a link object.","title":"Link"},{"location":"reference/models/#optimade.models.jsonapi.Link.href","text":"a string containing the link\u2019s URL.","title":"href"},{"location":"reference/models/#optimade.models.jsonapi.Link.meta","text":"a meta object containing non-standard meta-information about the link.","title":"meta"},{"location":"reference/models/#optimade.models.jsonapi.Meta","text":"Non-standard meta-information that can not be represented as an attribute or relationship.","title":"Meta"},{"location":"reference/models/#optimade.models.jsonapi.Relationship","text":"Representation references from the resource object in which it\u2019s defined to other resource objects.","title":"Relationship"},{"location":"reference/models/#optimade.models.jsonapi.Relationship.data","text":"Resource linkage","title":"data"},{"location":"reference/models/#optimade.models.jsonapi.Relationship.links","text":"a links object containing at least one of the following: self, related","title":"links"},{"location":"reference/models/#optimade.models.jsonapi.Relationship.meta","text":"a meta object that contains non-standard meta-information about the relationship.","title":"meta"},{"location":"reference/models/#optimade.models.jsonapi.RelationshipLinks","text":"A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object.","title":"RelationshipLinks"},{"location":"reference/models/#optimade.models.jsonapi.RelationshipLinks.related","text":"A related resource link","title":"related"},{"location":"reference/models/#optimade.models.jsonapi.RelationshipLinks.self","text":"A link to itself","title":"self"},{"location":"reference/models/#optimade.models.jsonapi.Relationships","text":"Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id","title":"Relationships"},{"location":"reference/models/#optimade.models.jsonapi.Resource","text":"Resource objects appear in a JSON:API document to represent resources.","title":"Resource"},{"location":"reference/models/#optimade.models.jsonapi.Resource.attributes","text":"an attributes object representing some of the resource\u2019s data.","title":"attributes"},{"location":"reference/models/#optimade.models.jsonapi.Resource.links","text":"a links object containing links related to the resource.","title":"links"},{"location":"reference/models/#optimade.models.jsonapi.Resource.meta","text":"a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship.","title":"meta"},{"location":"reference/models/#optimade.models.jsonapi.Resource.relationships","text":"a relationships object describing relationships between the resource and other JSON:API resources.","title":"relationships"},{"location":"reference/models/#optimade.models.jsonapi.ResourceLinks","text":"A Resource Links object","title":"ResourceLinks"},{"location":"reference/models/#optimade.models.jsonapi.ResourceLinks.self","text":"A link that identifies the resource represented by the resource object.","title":"self"},{"location":"reference/models/#optimade.models.jsonapi.Response","text":"A top-level response","title":"Response"},{"location":"reference/models/#optimade.models.jsonapi.Response.data","text":"Outputted Data","title":"data"},{"location":"reference/models/#optimade.models.jsonapi.Response.errors","text":"A list of unique errors","title":"errors"},{"location":"reference/models/#optimade.models.jsonapi.Response.included","text":"A list of unique included resources","title":"included"},{"location":"reference/models/#optimade.models.jsonapi.Response.jsonapi","text":"Information about the JSON API used","title":"jsonapi"},{"location":"reference/models/#optimade.models.jsonapi.Response.links","text":"Links associated with the primary data or errors","title":"links"},{"location":"reference/models/#optimade.models.jsonapi.Response.meta","text":"A meta object containing non-standard information related to the Success","title":"meta"},{"location":"reference/models/#optimade.models.jsonapi.Response.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks","text":"A set of Links objects, possibly including pagination","title":"ToplevelLinks"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks.first","text":"The first page of data","title":"first"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks.last","text":"The last page of data","title":"last"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks.next","text":"The next page of data","title":"next"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks.prev","text":"The previous page of data","title":"prev"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks.related","text":"A related resource link","title":"related"},{"location":"reference/models/#optimade.models.jsonapi.ToplevelLinks.self","text":"A link to itself","title":"self"},{"location":"reference/models/#optimade.models.links","text":"","title":"links"},{"location":"reference/models/#optimade.models.links.LinksResource","text":"A Links endpoint resource object","title":"LinksResource"},{"location":"reference/models/#optimade.models.links.LinksResourceAttributes","text":"Links endpoint resource object attributes","title":"LinksResourceAttributes"},{"location":"reference/models/#optimade.models.links.LinksResourceAttributes.base_url","text":"JSON API links object, pointing to the base URL for this implementation","title":"base_url"},{"location":"reference/models/#optimade.models.links.LinksResourceAttributes.description","text":"Human-readable description for the OPTIMADE API implementation a client may provide in a list to an end-user.","title":"description"},{"location":"reference/models/#optimade.models.links.LinksResourceAttributes.homepage","text":"JSON API links object, pointing to a homepage URL for this implementation","title":"homepage"},{"location":"reference/models/#optimade.models.links.LinksResourceAttributes.link_type","text":"The link type of the represented resource in relation to this implementation. MUST be one of these values: 'child', 'root', 'external', 'providers'.","title":"link_type"},{"location":"reference/models/#optimade.models.links.LinksResourceAttributes.name","text":"Human-readable name for the OPTIMADE API implementation a client may provide in a list to an end-user.","title":"name"},{"location":"reference/models/#optimade.models.optimade_json","text":"Modified JSON API v1.0 for OPTIMADE API","title":"optimade_json"},{"location":"reference/models/#optimade.models.optimade_json.BaseRelationshipMeta","text":"Specific meta field for base relationship resource","title":"BaseRelationshipMeta"},{"location":"reference/models/#optimade.models.optimade_json.BaseRelationshipMeta.description","text":"OPTIONAL human-readable description of the relationship","title":"description"},{"location":"reference/models/#optimade.models.optimade_json.BaseRelationshipResource","text":"Minimum requirements to represent a relationship resource","title":"BaseRelationshipResource"},{"location":"reference/models/#optimade.models.optimade_json.BaseRelationshipResource.meta","text":"Relationship meta field. MUST contain 'description' if supplied.","title":"meta"},{"location":"reference/models/#optimade.models.optimade_json.Implementation","text":"Information on the server implementation","title":"Implementation"},{"location":"reference/models/#optimade.models.optimade_json.Implementation.maintainer","text":"A dictionary providing details about the maintainer of the implementation.","title":"maintainer"},{"location":"reference/models/#optimade.models.optimade_json.Implementation.name","text":"name of the implementation","title":"name"},{"location":"reference/models/#optimade.models.optimade_json.Implementation.source_url","text":"URL of the implementation source, either downloadable archive or version control system","title":"source_url"},{"location":"reference/models/#optimade.models.optimade_json.Implementation.version","text":"version string of the current implementation","title":"version"},{"location":"reference/models/#optimade.models.optimade_json.ImplementationMaintainer","text":"Details about the maintainer of the implementation","title":"ImplementationMaintainer"},{"location":"reference/models/#optimade.models.optimade_json.ImplementationMaintainer.email","text":"the maintainer's email address","title":"email"},{"location":"reference/models/#optimade.models.optimade_json.OptimadeError","text":"detail MUST be present","title":"OptimadeError"},{"location":"reference/models/#optimade.models.optimade_json.Provider","text":"Information on the database provider of the implementation.","title":"Provider"},{"location":"reference/models/#optimade.models.optimade_json.Provider.description","text":"a longer description of the database provider","title":"description"},{"location":"reference/models/#optimade.models.optimade_json.Provider.homepage","text":"a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object.","title":"homepage"},{"location":"reference/models/#optimade.models.optimade_json.Provider.index_base_url","text":"a JSON API links object pointing to the base URL for the index meta-database as specified in Appendix 1, either directly as a string, or as a link object.","title":"index_base_url"},{"location":"reference/models/#optimade.models.optimade_json.Provider.name","text":"a short name for the database provider","title":"name"},{"location":"reference/models/#optimade.models.optimade_json.Provider.prefix","text":"database-provider-specific prefix as found in Appendix 1.","title":"prefix"},{"location":"reference/models/#optimade.models.optimade_json.Relationship","text":"Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource","title":"Relationship"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta","text":"A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix.","title":"ResponseMeta"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.api_version","text":"a string containing the version of the API implementation, e.g. v0.9.5","title":"api_version"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.data_available","text":"an integer containing the total number of data objects available in the database","title":"data_available"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.data_returned","text":"an integer containing the number of data objects returned for the query.","title":"data_returned"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.implementation","text":"a dictionary describing the server implementation","title":"implementation"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.last_id","text":"a string containing the last ID returned","title":"last_id"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.more_data_available","text":"false if all data has been returned, and true if not.","title":"more_data_available"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.provider","text":"information on the database provider of the implementation.","title":"provider"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.query","text":"information on the query that was requested","title":"query"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.response_message","text":"response string from the server","title":"response_message"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.time_stamp","text":"a string containing the date and time at which the query was exexcuted","title":"time_stamp"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMeta.warnings","text":"List of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status, representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects.","title":"warnings"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMetaQuery","text":"Information on the query that was requested.","title":"ResponseMetaQuery"},{"location":"reference/models/#optimade.models.optimade_json.ResponseMetaQuery.representation","text":"a string with the part of the URL that follows the base URL. Example: '/structures?'","title":"representation"},{"location":"reference/models/#optimade.models.optimade_json.Success","text":"errors are not allowed","title":"Success"},{"location":"reference/models/#optimade.models.optimade_json.Success.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.optimade_json.Success.either_data_meta_or_errors_must_be_set","text":"Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values","title":"either_data_meta_or_errors_must_be_set()"},{"location":"reference/models/#optimade.models.optimade_json.Warnings","text":"OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \" warning \" . The field detail MUST be present and SHOULD contain a non - critical message , e . g ., reporting unrecognized search attributes or deprecated features . Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class.","title":"Warnings"},{"location":"reference/models/#optimade.models.optimade_json.Warnings.type","text":"Warnings must be of type \"warning\"","title":"type"},{"location":"reference/models/#optimade.models.references","text":"","title":"references"},{"location":"reference/models/#optimade.models.references.Person","text":"","title":"Person"},{"location":"reference/models/#optimade.models.references.Person.firstname","text":"First name of the person.","title":"firstname"},{"location":"reference/models/#optimade.models.references.Person.lastname","text":"Last name of the person.","title":"lastname"},{"location":"reference/models/#optimade.models.references.ReferenceResource","text":"The :entry: references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , type , volume , year : Meanings of these properties match the BibTeX specification <http://bibtexml.sourceforge.net/btxdoc.pdf> __, values are strings; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL, i.e., any of the properties MAY be :val: null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties.","title":"ReferenceResource"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes","text":"Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification .","title":"ReferenceResourceAttributes"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.address","text":"Meaning of property matches the BiBTeX specification.","title":"address"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.annote","text":"Meaning of property matches the BiBTeX specification.","title":"annote"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.authors","text":"List of person objects containing the authors of the reference.","title":"authors"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.bib_type","text":"Type of the reference, corresponding to the type property in the BiBTeX specification.","title":"bib_type"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.booktitle","text":"Meaning of property matches the BiBTeX specification.","title":"booktitle"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.chapter","text":"Meaning of property matches the BiBTeX specification.","title":"chapter"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.crossref","text":"Meaning of property matches the BiBTeX specification.","title":"crossref"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.doi","text":"The digital object identifier of the reference.","title":"doi"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.edition","text":"Meaning of property matches the BiBTeX specification.","title":"edition"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.editors","text":"List of person objects containing the editors of the reference.","title":"editors"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.howpublished","text":"Meaning of property matches the BiBTeX specification.","title":"howpublished"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.institution","text":"Meaning of property matches the BiBTeX specification.","title":"institution"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.journal","text":"Meaning of property matches the BiBTeX specification.","title":"journal"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.key","text":"Meaning of property matches the BiBTeX specification.","title":"key"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.month","text":"Meaning of property matches the BiBTeX specification.","title":"month"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.note","text":"Meaning of property matches the BiBTeX specification.","title":"note"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.number","text":"Meaning of property matches the BiBTeX specification.","title":"number"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.organization","text":"Meaning of property matches the BiBTeX specification.","title":"organization"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.pages","text":"Meaning of property matches the BiBTeX specification.","title":"pages"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.publisher","text":"Meaning of property matches the BiBTeX specification.","title":"publisher"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.school","text":"Meaning of property matches the BiBTeX specification.","title":"school"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.series","text":"Meaning of property matches the BiBTeX specification.","title":"series"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.title","text":"Meaning of property matches the BiBTeX specification.","title":"title"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.url","text":"The URL of the reference.","title":"url"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.volume","text":"Meaning of property matches the BiBTeX specification.","title":"volume"},{"location":"reference/models/#optimade.models.references.ReferenceResourceAttributes.year","text":"Meaning of property matches the BiBTeX specification.","title":"year"},{"location":"reference/models/#optimade.models.responses","text":"","title":"responses"},{"location":"reference/models/#optimade.models.responses.EntryInfoResponse","text":"","title":"EntryInfoResponse"},{"location":"reference/models/#optimade.models.responses.EntryInfoResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.EntryResponseMany","text":"","title":"EntryResponseMany"},{"location":"reference/models/#optimade.models.responses.EntryResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.EntryResponseOne","text":"","title":"EntryResponseOne"},{"location":"reference/models/#optimade.models.responses.EntryResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.ErrorResponse","text":"errors MUST be present and data MUST be skipped","title":"ErrorResponse"},{"location":"reference/models/#optimade.models.responses.ErrorResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.IndexInfoResponse","text":"","title":"IndexInfoResponse"},{"location":"reference/models/#optimade.models.responses.IndexInfoResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.InfoResponse","text":"","title":"InfoResponse"},{"location":"reference/models/#optimade.models.responses.InfoResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.LinksResponse","text":"","title":"LinksResponse"},{"location":"reference/models/#optimade.models.responses.LinksResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.ReferenceResponseMany","text":"","title":"ReferenceResponseMany"},{"location":"reference/models/#optimade.models.responses.ReferenceResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.ReferenceResponseOne","text":"","title":"ReferenceResponseOne"},{"location":"reference/models/#optimade.models.responses.ReferenceResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.StructureResponseMany","text":"","title":"StructureResponseMany"},{"location":"reference/models/#optimade.models.responses.StructureResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.responses.StructureResponseOne","text":"","title":"StructureResponseOne"},{"location":"reference/models/#optimade.models.responses.StructureResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/#optimade.models.structures","text":"","title":"structures"},{"location":"reference/models/#optimade.models.structures.Assembly","text":"A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent).","title":"Assembly"},{"location":"reference/models/#optimade.models.structures.Assembly.group_probabilities","text":"Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _.","title":"group_probabilities"},{"location":"reference/models/#optimade.models.structures.Assembly.sites_in_groups","text":"Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth.","title":"sites_in_groups"},{"location":"reference/models/#optimade.models.structures.Periodicity","text":"An enumeration.","title":"Periodicity"},{"location":"reference/models/#optimade.models.structures.Species","text":"A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13.","title":"Species"},{"location":"reference/models/#optimade.models.structures.Species.chemical_symbols","text":"MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _).","title":"chemical_symbols"},{"location":"reference/models/#optimade.models.structures.Species.concentration","text":"MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species).","title":"concentration"},{"location":"reference/models/#optimade.models.structures.Species.mass","text":"If present MUST be a float expressed in a.m.u.","title":"mass"},{"location":"reference/models/#optimade.models.structures.Species.original_name","text":"Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _).","title":"original_name"},{"location":"reference/models/#optimade.models.structures.StructureResource","text":"Representing a structure.","title":"StructureResource"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes","text":"This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions.","title":"StructureResourceAttributes"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.assemblies","text":"A description of groups of sites that are statistically correlated. - Type : list of dictionary with keys: :property: sites_in_groups : list of list of integers (REQUIRED) :property: group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. If present, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _. If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: .. code:: jsonc { \"cartesian_site_positions\": [[0,0,0]], \"species_at_sites\": [\"SiGe-vac\"], \"species\": [ { \"name\": \"SiGe-vac\", \"chemical_symbols\": [\"Si\", \"Ge\", \"vacancy\"], \"concentration\": [0.3, 0.5, 0.2] } ] // ... } Using multiple species and the assemblies: .. code:: jsonc { \"cartesian_site_positions\": [ [0,0,0], [0,0,0], [0,0,0] ], \"species_at_sites\": [\"Si\", \"Ge\", \"vac\"], \"species\": { \"Si\": { \"chemical_symbols\": [\"Si\"], \"concentration\": [1.0] }, \"Ge\": { \"chemical_symbols\": [\"Ge\"], \"concentration\": [1.0] }, \"vac\": { \"chemical_symbols\": [\"vacancy\"], \"concentration\": [1.0] } }, \"assemblies\": [ { \"sites_in_groups\": [ [0], [1], [2] ], \"group_probabilities\": [0.3, 0.5, 0.2] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: .. code:: jsonc { \"assemblies\": [ { \"sites_in_groups\": [ [0], [1] ], \"group_probabilities\": [0.2, 0.8], }, { \"sites_in_groups\": [ [2], [3] ], \"group_probabilities\": [0.3, 0.7] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability).","title":"assemblies"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.cartesian_site_positions","text":"Cartesian positions of each site. A site is an atom, a site potentially occupied by an atom, or a placeholder for a virtual mixture of atoms (e.g., in a virtual crystal approximation). - Type : list of list of floats and/or unknown values - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length N times 3, where N is the number of sites in the structure. An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies _). If a component of the position is unknown, the :val: null value should be provided instead (see section Properties with unknown value ). Otherwise, it should be a float value, expressed in angstrom (\u00c5). If at least one of the coordinates is unknown, the correct flag in the list property structure_features MUST be set. Notes : (for implementers) While this is unrelated to this OPTIMADE specification: If you decide to store internally the :property: cartesian_site_positions as a float array, you might want to represent :val: null values with :field-val: NaN values. The latter being valid float numbers in the IEEE 754 standard in IEEE 754-1985 <https://doi.org/10.1109/IEEESTD.1985.82928> and in the updated version IEEE 754-2008 <https://doi.org/10.1109/IEEESTD.2008.4610935> . Examples : :val: [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin.","title":"cartesian_site_positions"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_anonymous","text":"The anonymous formula is the :property: chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : :val: \"A2B\" :val: \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is :filter: chemical_formula_anonymous=\"A2B\" .","title":"chemical_formula_anonymous"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_descriptive","text":"The chemical formula for a structure as a string in a form chosen by the API implementation. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the :property: chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry <https://www.qmul.ac.uk/sbcs/iupac/bibliog/blue.html> __. Examples : :val: \"(H2O)2 Na\" :val: \"NaCl\" :val: \"CaCO3\" :val: \"CCaO3\" :val: \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: :filter: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: :filter: chemical_formula_descriptive CONTAINS \"H2O\" .","title":"chemical_formula_descriptive"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_hill","text":"The chemical formula for a structure in Hill form <https://dx.doi.org/10.1021/ja02046a005> __ with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : Support for queries on these properties are OPTIONAL. If supported, only a subset of filter operators MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, :property: chemical_formula_hill is :val: \"H2O2\" (i.e., not :val: \"HO\" , nor :val: \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in Hill order <https://dx.doi.org/10.1021/ja02046a005> __, followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : :val: \"H2O2\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_hill=\"H2O2\" .","title":"chemical_formula_hill"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.chemical_formula_reduced","text":"The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate querying on formula components are instead recommended to be formulated using set-type filter operators on the multi valued :property: elements and :property: elements_proportions properties. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : :val: \"H2NaO\" :val: \"ClNa\" :val: \"CCaO3\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_reduced=\"H2NaO\" .","title":"chemical_formula_reduced"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.dimension_types","text":"List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ). This list indicates if the direction is periodic (value :val: 1 ) or non-periodic (value :val: 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in property lattice_vectors and not the Cartesian x, y, z directions. - Type : list of integers. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. Support for equality comparison is REQUIRED, support for other comparison operators are OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: :val: [0, 0, 0] For a wire along the direction specified by the third lattice vector: :val: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: :val: [1, 0, 1] For a bulk 3D system: :val: [1, 1, 1]","title":"dimension_types"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.elements","text":"Names of the different elements present in the structure. - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The strings are the chemical symbols, written as uppercase letter plus optional lowercase letters. The order MUST be alphabetical. Note: This may not contain the \"x\" that is suggested in chemical_symbols for the :property: species property. Examples : :val: [\"Si\"] :val: [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: :filter: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use :filter: elements HAS ALL \"Si\", \"Al\", \"O\" AND LENGTH elements = 3 .","title":"elements"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.elements_ratios","text":"Relative proportions of different elements in the structure. - Type : list of floats - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : :val: [1.0] :val: [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally not recommended. A filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: :filter: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 .","title":"elements_ratios"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.lattice_vectors","text":"The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). - Type : list of list of floats. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. This property MUST be an array of dimensions 3 times 3 regardless of the elements of :property: dimension_types . The vectors SHOULD by convention be chosen so the determinant of the :property: lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. All three elements of the inner lists of floats MAY be :val: null for non-periodic dimensions, i.e., those dimensions for which :property: dimension_types is :val: 0 . Examples : :val: [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is :val: (4, 0, 0) , i.e., a vector aligned along the :val: x axis of length 4 \u00c5; the second vector is :val: (0, 4, 0) ; and the third vector is :val: (0, 1, 4) .","title":"lattice_vectors"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.nelements","text":"Number of different elements in the structure as an integer. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Example : :val: 3 Querying : Note: queries on this property can equivalently be formulated using :filter-fragment: LENGTH elements . A filter that matches structures that have exactly 4 elements: :filter: nelements=4 . A filter that matches structures that have between 2 and 7 elements: :filter: nelements>=2 AND nelements<=7 .","title":"nelements"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.nsites","text":"An integer specifying the length of the :property: cartesian_site_positions property. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Examples : :val: 42 Query examples : Match only structures with exactly 4 sites: :filter: nsites=4 Match structures that have between 2 and 7 sites: :filter: nsites>=2 AND nsites<=7","title":"nsites"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.species","text":"A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. - Type : list of dictionary with keys: :property: name : string (REQUIRED) :property: chemical_symbols : list of strings (REQUIRED) :property: concentration : list of float (REQUIRED) :property: mass : float (OPTIONAL) :property: original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the :property: species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). concentration : REQUIRED; MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : OPTIONAL. If present MUST be a float expressed in a.m.u. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., :val: \"Ti\" for titanium, :val: \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species :val: {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13.","title":"species"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.species_at_sites","text":"Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions _). Each species MUST have a unique name. Each species name mentioned in the :property: species_at_sites list MUST be described in the list property species _ (i.e. for each value in the :property: species_at_sites list there MUST exist exactly one dictionary in the :property: species list with the :property: name attribute equal to the corresponding :property: species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : :val: [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled :val: \"Ti\" and the second a species labeled :val: \"O2\" .","title":"species_at_sites"},{"location":"reference/models/#optimade.models.structures.StructureResourceAttributes.structure_features","text":"A list of strings that flag which special features are used by the structure. - Type : list of strings - Requirements/Conventions : Support : REQUIRED, MUST NOT be :val: null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : :val: disorder : This flag MUST be present if any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element. :val: unknown_positions : This flag MUST be present if at least one component of the :property: cartesian_site_positions list of lists has value :val: null . :val: assemblies : This flag MUST be present if the property assemblies _ is present. Examples : A structure having unknown positions and using assemblies: :val: [\"assemblies\", \"unknown_positions\"]","title":"structure_features"},{"location":"reference/filtertransformers/debug/","text":"TransformerSkeleton ( Transformer ) \u00b6 Prints out all the nodes and its arguments during the walk-through of the tree.","title":"Debug"},{"location":"reference/filtertransformers/debug/#optimade.filtertransformers.debug.TransformerSkeleton","text":"Prints out all the nodes and its arguments during the walk-through of the tree.","title":"TransformerSkeleton"},{"location":"reference/filtertransformers/django/","text":"","title":"Django"},{"location":"reference/filtertransformers/elasticsearch/","text":"Quantity \u00b6 Class to provide information about available quantities to the transformer. The elasticsearch transformer will :class: Quantity s to (a) do some semantic checks, (b) map quantities to the underlying elastic index. Attributes: Name Type Description name The name of the quantity as used in the filter expressions. es_field The name of the field for this quanity in elastic search, will be name by default. elastic_mapping_type A decendent of an elasticsearch_dsl Field that denotes which mapping was used in the elastic search index. length_quantity Elasticsearch does not support length of arrays, but we can map fields with array to other fields with ints about the array length. The LENGTH operator will only be supported for quantities with this attribute. has_only_quantity Elasticsearch does not support exclusive search on arrays, like a list of chemical elements. But, we can order all elements by atomic number and use a keyword field with all elements to perform this search. This only works for elements (i.e. labels in CHEMICAL_SYMBOLS ) and quantities with this attribute. nested_quantity To support optimade's 'zipped tuple' feature (e.g. 'elements:elements_ratios HAS \"H\":>0.33), we use elasticsearch nested objects and nested queries. This quantity will provide the field for the nested object that contains the quantity (and others). The zipped tuples will only work for quantities that share the same nested object quantity. Transformer ( Transformer ) \u00b6 Transformer that transforms v0.10.0 grammer parse trees into queries. Uses elasticsearch_dsl and will produce a :class: Q instance. Parameters: Name Type Description Default quantities A list of :class: Quantity s that describe how optimade (and other) quantities are mapped to the elasticsearch index. required __default__ ( self , tree , children , * args , ** kwargs ) special \u00b6 Default behavior for rules that only replace one symbol with another Source code in optimade/filtertransformers/elasticsearch.py def __default__ ( self , tree , children , * args , ** kwargs ): \"\"\" Default behavior for rules that only replace one symbol with another \"\"\" return children [ 0 ]","title":"Elasticsearch"},{"location":"reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.Quantity","text":"Class to provide information about available quantities to the transformer. The elasticsearch transformer will :class: Quantity s to (a) do some semantic checks, (b) map quantities to the underlying elastic index. Attributes: Name Type Description name The name of the quantity as used in the filter expressions. es_field The name of the field for this quanity in elastic search, will be name by default. elastic_mapping_type A decendent of an elasticsearch_dsl Field that denotes which mapping was used in the elastic search index. length_quantity Elasticsearch does not support length of arrays, but we can map fields with array to other fields with ints about the array length. The LENGTH operator will only be supported for quantities with this attribute. has_only_quantity Elasticsearch does not support exclusive search on arrays, like a list of chemical elements. But, we can order all elements by atomic number and use a keyword field with all elements to perform this search. This only works for elements (i.e. labels in CHEMICAL_SYMBOLS ) and quantities with this attribute. nested_quantity To support optimade's 'zipped tuple' feature (e.g. 'elements:elements_ratios HAS \"H\":>0.33), we use elasticsearch nested objects and nested queries. This quantity will provide the field for the nested object that contains the quantity (and others). The zipped tuples will only work for quantities that share the same nested object quantity.","title":"Quantity"},{"location":"reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.Transformer","text":"Transformer that transforms v0.10.0 grammer parse trees into queries. Uses elasticsearch_dsl and will produce a :class: Q instance. Parameters: Name Type Description Default quantities A list of :class: Quantity s that describe how optimade (and other) quantities are mapped to the elasticsearch index. required","title":"Transformer"},{"location":"reference/filtertransformers/elasticsearch/#optimade.filtertransformers.elasticsearch.Transformer.__default__","text":"Default behavior for rules that only replace one symbol with another Source code in optimade/filtertransformers/elasticsearch.py def __default__ ( self , tree , children , * args , ** kwargs ): \"\"\" Default behavior for rules that only replace one symbol with another \"\"\" return children [ 0 ]","title":"__default__()"},{"location":"reference/filtertransformers/json/","text":"","title":"Json"},{"location":"reference/filtertransformers/mongo/","text":"MongoTransformer ( Transformer ) \u00b6 Support for grammar v0.10.1 __init__ ( self , mapper = None ) special \u00b6 Initialise the object, optionally loading in a resource mapper for use when post-processing. Source code in optimade/filtertransformers/mongo.py def __init__ ( self , mapper : BaseResourceMapper = None ): \"\"\" Initialise the object, optionally loading in a resource mapper for use when post-processing. \"\"\" self . mapper = mapper super () . __init__ () non_string_value ( self , value ) \u00b6 non_string_value: number | property Source code in optimade/filtertransformers/mongo.py @v_args ( inline = True ) def non_string_value ( self , value ): \"\"\" non_string_value: number | property \"\"\" # Note: Do nothing! return value not_implemented_string ( self , value ) \u00b6 not_implemented_string: value Raise NotImplementedError. For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 Source code in optimade/filtertransformers/mongo.py @v_args ( inline = True ) def not_implemented_string ( self , value ): \"\"\" not_implemented_string: value Raise NotImplementedError. For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 \"\"\" raise NotImplementedError ( \"Comparing strings is not yet implemented.\" ) postprocess ( self , query ) \u00b6 Used to post-process the final parsed query. Source code in optimade/filtertransformers/mongo.py def postprocess ( self , query ): \"\"\" Used to post-process the final parsed query. \"\"\" if self . mapper : # important to apply length alias before normal aliases query = self . _apply_length_aliases ( query ) query = self . _apply_aliases ( query ) query = self . _apply_relationship_filtering ( query ) query = self . _apply_length_operators ( query ) query = self . _apply_unknown_or_null_filter ( query ) return query transform ( self , tree ) \u00b6 Transform the given tree, and return the final result Source code in optimade/filtertransformers/mongo.py def transform ( self , tree ): return self . postprocess ( super () . transform ( tree )) recursive_postprocessing ( filter_ , condition , replacement ) \u00b6 Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: Name Type Description Default filter_ list/dict the filter_ to process. required condition callable a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over filter_.items() . required replacement callable a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). required Examples: For the simple case of replacing one field name with another, the following functions could be used: def condition ( prop , expr ): return prop == \"field_name_old\" def replacement ( d , prop , expr ): d [ \"field_name_old\" ] = d . pop ( prop ) filter_ = recursive_postprocessing ( filter_ , condition , replacement ) Source code in optimade/filtertransformers/mongo.py def recursive_postprocessing ( filter_ , condition , replacement ): \"\"\" Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: filter_ (list/dict): the filter_ to process. condition (callable): a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over `filter_.items()`. replacement (callable): a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). Example: For the simple case of replacing one field name with another, the following functions could be used: ```python def condition(prop, expr): return prop == \"field_name_old\" def replacement(d, prop, expr): d[\"field_name_old\"] = d.pop(prop) filter_ = recursive_postprocessing( filter_, condition, replacement ) ``` \"\"\" if isinstance ( filter_ , list ): result = [ recursive_postprocessing ( q , condition , replacement ) for q in filter_ ] return result if isinstance ( filter_ , dict ): # this could potentially lead to memory leaks if the filter_ is *heavily* nested _cached_filter = copy . deepcopy ( filter_ ) for prop , expr in filter_ . items (): if condition ( prop , expr ): _cached_filter = replacement ( _cached_filter , prop , expr ) elif isinstance ( expr , list ): _cached_filter [ prop ] = [ recursive_postprocessing ( q , condition , replacement ) for q in expr ] return _cached_filter return filter_","title":"Mongo"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer","text":"Support for grammar v0.10.1","title":"MongoTransformer"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.__init__","text":"Initialise the object, optionally loading in a resource mapper for use when post-processing. Source code in optimade/filtertransformers/mongo.py def __init__ ( self , mapper : BaseResourceMapper = None ): \"\"\" Initialise the object, optionally loading in a resource mapper for use when post-processing. \"\"\" self . mapper = mapper super () . __init__ ()","title":"__init__()"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.non_string_value","text":"non_string_value: number | property Source code in optimade/filtertransformers/mongo.py @v_args ( inline = True ) def non_string_value ( self , value ): \"\"\" non_string_value: number | property \"\"\" # Note: Do nothing! return value","title":"non_string_value()"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.not_implemented_string","text":"not_implemented_string: value Raise NotImplementedError. For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 Source code in optimade/filtertransformers/mongo.py @v_args ( inline = True ) def not_implemented_string ( self , value ): \"\"\" not_implemented_string: value Raise NotImplementedError. For further information, see Materials-Consortia/OPTIMADE issue 157: https://github.com/Materials-Consortia/OPTIMADE/issues/157 \"\"\" raise NotImplementedError ( \"Comparing strings is not yet implemented.\" )","title":"not_implemented_string()"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.postprocess","text":"Used to post-process the final parsed query. Source code in optimade/filtertransformers/mongo.py def postprocess ( self , query ): \"\"\" Used to post-process the final parsed query. \"\"\" if self . mapper : # important to apply length alias before normal aliases query = self . _apply_length_aliases ( query ) query = self . _apply_aliases ( query ) query = self . _apply_relationship_filtering ( query ) query = self . _apply_length_operators ( query ) query = self . _apply_unknown_or_null_filter ( query ) return query","title":"postprocess()"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.MongoTransformer.transform","text":"Transform the given tree, and return the final result Source code in optimade/filtertransformers/mongo.py def transform ( self , tree ): return self . postprocess ( super () . transform ( tree ))","title":"transform()"},{"location":"reference/filtertransformers/mongo/#optimade.filtertransformers.mongo.recursive_postprocessing","text":"Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: Name Type Description Default filter_ list/dict the filter_ to process. required condition callable a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over filter_.items() . required replacement callable a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). required Examples: For the simple case of replacing one field name with another, the following functions could be used: def condition ( prop , expr ): return prop == \"field_name_old\" def replacement ( d , prop , expr ): d [ \"field_name_old\" ] = d . pop ( prop ) filter_ = recursive_postprocessing ( filter_ , condition , replacement ) Source code in optimade/filtertransformers/mongo.py def recursive_postprocessing ( filter_ , condition , replacement ): \"\"\" Recursively descend into the query, checking each dictionary (contained in a list, or as an entry in another dictionary) for the condition passed. If the condition is true, apply the replacement to the dictionary. Parameters: filter_ (list/dict): the filter_ to process. condition (callable): a function that returns True if the replacement function should be applied. It should take as arguments the property and expression from the filter_, as would be returned by iterating over `filter_.items()`. replacement (callable): a function that returns the processed dictionary. It should take as arguments the dictionary to modify, the property and the expression (as described above). Example: For the simple case of replacing one field name with another, the following functions could be used: ```python def condition(prop, expr): return prop == \"field_name_old\" def replacement(d, prop, expr): d[\"field_name_old\"] = d.pop(prop) filter_ = recursive_postprocessing( filter_, condition, replacement ) ``` \"\"\" if isinstance ( filter_ , list ): result = [ recursive_postprocessing ( q , condition , replacement ) for q in filter_ ] return result if isinstance ( filter_ , dict ): # this could potentially lead to memory leaks if the filter_ is *heavily* nested _cached_filter = copy . deepcopy ( filter_ ) for prop , expr in filter_ . items (): if condition ( prop , expr ): _cached_filter = replacement ( _cached_filter , prop , expr ) elif isinstance ( expr , list ): _cached_filter [ prop ] = [ recursive_postprocessing ( q , condition , replacement ) for q in expr ] return _cached_filter return filter_","title":"recursive_postprocessing()"},{"location":"reference/models/baseinfo/","text":"AvailableApiVersion ( BaseModel ) pydantic-model \u00b6 A JSON object containing information about an available API version url : AnyHttpUrl pydantic-field required \u00b6 a string specifying a versioned base URL that MUST adhere to the rules in section Base URL version : ConstrainedStrValue pydantic-field required \u00b6 a string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'. crosscheck_url_and_version ( values ) classmethod \u00b6 Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) url_version = tuple ( int ( val ) for val in url_version . split ( \".\" )) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \".\" )) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values url_must_be_versioned_base_url ( v ) classmethod \u00b6 The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v BaseInfoAttributes ( BaseModel ) pydantic-model \u00b6 Attributes for Base URL Info endpoint api_version : str pydantic-field required \u00b6 Presently used version of the OPTIMADE API available_api_versions : List [ optimade . models . baseinfo . AvailableApiVersion ] pydantic-field required \u00b6 A list of dictionaries of available API versions at other base URLs available_endpoints : List [ str ] pydantic-field required \u00b6 List of available endpoints (i.e., the string to be appended to the versioned base URL). entry_types_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 Available entry endpoints as a function of output formats. formats : List [ str ] pydantic-field \u00b6 List of available output formats. is_index : bool pydantic-field \u00b6 If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false).","title":"Baseinfo"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion","text":"A JSON object containing information about an available API version","title":"AvailableApiVersion"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.url","text":"a string specifying a versioned base URL that MUST adhere to the rules in section Base URL","title":"url"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.version","text":"a string containing the full version number of the API served at that versioned base URL. The version number string MUST NOT be prefixed by, e.g., 'v'.","title":"version"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.crosscheck_url_and_version","text":"Check that URL version and API version are compatible. Source code in optimade/models/baseinfo.py @root_validator ( pre = False , skip_on_failure = True ) def crosscheck_url_and_version ( cls , values ): \"\"\" Check that URL version and API version are compatible. \"\"\" url_version = ( values [ \"url\" ] . split ( \"/\" )[ - 2 if values [ \"url\" ] . endswith ( \"/\" ) else - 1 ] . replace ( \"v\" , \"\" ) ) url_version = tuple ( int ( val ) for val in url_version . split ( \".\" )) api_version = tuple ( int ( val ) for val in values [ \"version\" ] . split ( \".\" )) if any ( a != b for a , b in zip ( url_version , api_version )): raise ValueError ( f \"API version { api_version } is not compatible with url version { url_version } .\" ) return values","title":"crosscheck_url_and_version()"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.AvailableApiVersion.url_must_be_versioned_base_url","text":"The URL must be a valid versioned Base URL Source code in optimade/models/baseinfo.py @validator ( \"url\" ) def url_must_be_versioned_base_url ( cls , v ): \"\"\"The URL must be a valid versioned Base URL\"\"\" if not re . match ( r \".+/v[0-1](\\.[0-9]+)*/?$\" , v ): raise ValueError ( f \"url MUST be a versioned base URL. It is: { v } \" ) return v","title":"url_must_be_versioned_base_url()"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes","text":"Attributes for Base URL Info endpoint","title":"BaseInfoAttributes"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.api_version","text":"Presently used version of the OPTIMADE API","title":"api_version"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.available_api_versions","text":"A list of dictionaries of available API versions at other base URLs","title":"available_api_versions"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.available_endpoints","text":"List of available endpoints (i.e., the string to be appended to the versioned base URL).","title":"available_endpoints"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.entry_types_by_format","text":"Available entry endpoints as a function of output formats.","title":"entry_types_by_format"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.formats","text":"List of available output formats.","title":"formats"},{"location":"reference/models/baseinfo/#optimade.models.baseinfo.BaseInfoAttributes.is_index","text":"If true, this is an index meta-database base URL (see section Index Meta-Database). If this member is not provided, the client MUST assume this is not an index meta-database base URL (i.e., the default is for is_index to be false).","title":"is_index"},{"location":"reference/models/entries/","text":"EntryInfoProperty ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 description of the entry property sortable : bool pydantic-field \u00b6 defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true . unit : str pydantic-field \u00b6 the physical unit of the entry property EntryInfoResource ( BaseModel ) pydantic-model \u00b6 description : str pydantic-field required \u00b6 description of the entry formats : List [ str ] pydantic-field required \u00b6 list of available output formats. output_fields_by_format : Dict [ str , List [ str ]] pydantic-field required \u00b6 a dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary. properties : Dict [ str , optimade . models . entries . EntryInfoProperty ] pydantic-field required \u00b6 a dictionary describing queryable properties for this entry type, where each key is a property ID. EntryRelationships ( Relationships ) pydantic-model \u00b6 This model wraps the JSON API Relationships to include type-specific top level keys. references : ReferenceRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the references type. structures : StructureRelationship pydantic-field \u00b6 Object containing links to relationships with entries of the structures type. EntryResourceAttributes ( Attributes ) pydantic-model \u00b6 Contains key-value pairs representing the entry's properties. immutable_id : str pydantic-field \u00b6 The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. - Type : string. - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : :val: \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" :val: \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.) last_modified : datetime pydantic-field required \u00b6 Date and time representing when the entry was last modified. - Type : timestamp. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter :query-param: response_fields is present and does not include this property. Example : As part of JSON response format: :VAL: \"2007-04-05T14:30Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format <https://tools.ietf.org/html/rfc3339#section-5.6> __ string.)","title":"Entries"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoProperty","text":"","title":"EntryInfoProperty"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoProperty.description","text":"description of the entry property","title":"description"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoProperty.sortable","text":"defines whether the entry property can be used for sorting with the \"sort\" parameter. If the entry listing endpoint supports sorting, this key MUST be present for sortable properties with value true .","title":"sortable"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoProperty.unit","text":"the physical unit of the entry property","title":"unit"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoResource","text":"","title":"EntryInfoResource"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoResource.description","text":"description of the entry","title":"description"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoResource.formats","text":"list of available output formats.","title":"formats"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoResource.output_fields_by_format","text":"a dictionary of available output fields for this entry type, where the keys are the values of the formats list and the values are the keys of the properties dictionary.","title":"output_fields_by_format"},{"location":"reference/models/entries/#optimade.models.entries.EntryInfoResource.properties","text":"a dictionary describing queryable properties for this entry type, where each key is a property ID.","title":"properties"},{"location":"reference/models/entries/#optimade.models.entries.EntryRelationships","text":"This model wraps the JSON API Relationships to include type-specific top level keys.","title":"EntryRelationships"},{"location":"reference/models/entries/#optimade.models.entries.EntryRelationships.references","text":"Object containing links to relationships with entries of the references type.","title":"references"},{"location":"reference/models/entries/#optimade.models.entries.EntryRelationships.structures","text":"Object containing links to relationships with entries of the structures type.","title":"structures"},{"location":"reference/models/entries/#optimade.models.entries.EntryResourceAttributes","text":"Contains key-value pairs representing the entry's properties.","title":"EntryResourceAttributes"},{"location":"reference/models/entries/#optimade.models.entries.EntryResourceAttributes.immutable_id","text":"The entry's immutable ID (e.g., an UUID). This is important for databases having preferred IDs that point to \"the latest version\" of a record, but still offer access to older variants. This ID maps to the version-specific record, in case it changes in the future. - Type : string. - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Examples : :val: \"8bd3e750-b477-41a0-9b11-3a799f21b44f\" :val: \"fjeiwoj,54;@=%<>#32\" (Strings that are not URL-safe are allowed.)","title":"immutable_id"},{"location":"reference/models/entries/#optimade.models.entries.EntryResourceAttributes.last_modified","text":"Date and time representing when the entry was last modified. - Type : timestamp. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter features. Response : REQUIRED in the response unless the query parameter :query-param: response_fields is present and does not include this property. Example : As part of JSON response format: :VAL: \"2007-04-05T14:30Z\" (i.e., encoded as an RFC 3339 Internet Date/Time Format <https://tools.ietf.org/html/rfc3339#section-5.6> __ string.)","title":"last_modified"},{"location":"reference/models/index_metadb/","text":"IndexInfoAttributes ( BaseInfoAttributes ) pydantic-model \u00b6 Attributes for Base URL Info endpoint for an Index Meta-Database IndexInfoResource ( BaseInfoResource ) pydantic-model \u00b6 Index Meta-Database Base URL Info endpoint resource IndexRelationship ( BaseModel ) pydantic-model \u00b6 Index Meta-Database relationship data : RelatedLinksResource pydantic-field required \u00b6 JSON API resource linkage. It MUST be either null or contain a single Links identifier object with the fields 'id' and 'type' RelatedLinksResource ( BaseResource ) pydantic-model \u00b6 A related Links resource object","title":"Index metadb"},{"location":"reference/models/index_metadb/#optimade.models.index_metadb.IndexInfoAttributes","text":"Attributes for Base URL Info endpoint for an Index Meta-Database","title":"IndexInfoAttributes"},{"location":"reference/models/index_metadb/#optimade.models.index_metadb.IndexInfoResource","text":"Index Meta-Database Base URL Info endpoint resource","title":"IndexInfoResource"},{"location":"reference/models/index_metadb/#optimade.models.index_metadb.IndexRelationship","text":"Index Meta-Database relationship","title":"IndexRelationship"},{"location":"reference/models/index_metadb/#optimade.models.index_metadb.IndexRelationship.data","text":"JSON API resource linkage. It MUST be either null or contain a single Links identifier object with the fields 'id' and 'type'","title":"data"},{"location":"reference/models/index_metadb/#optimade.models.index_metadb.RelatedLinksResource","text":"A related Links resource object","title":"RelatedLinksResource"},{"location":"reference/models/jsonapi/","text":"This module should reproduce JSON API v1.0 https://jsonapi.org/format/1.0/ Attributes ( BaseModel ) pydantic-model \u00b6 Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type BaseResource ( BaseModel ) pydantic-model \u00b6 Minimum requirements to represent a Resource id : str pydantic-field required \u00b6 Resource ID type : str pydantic-field required \u00b6 Resource type Error ( BaseModel ) pydantic-model \u00b6 An error response code : str pydantic-field \u00b6 an application-specific error code, expressed as a string value. detail : str pydantic-field \u00b6 A human-readable explanation specific to this occurrence of the problem. id : str pydantic-field \u00b6 A unique identifier for this particular occurrence of the problem. links : ErrorLinks pydantic-field \u00b6 A links object storing about meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the error. source : ErrorSource pydantic-field \u00b6 An object containing references to the source of the error status : str pydantic-field \u00b6 the HTTP status code applicable to this problem, expressed as a string value. title : str pydantic-field \u00b6 A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization. __hash__ ( self ) special \u00b6 Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ()) ErrorLinks ( BaseModel ) pydantic-model \u00b6 A Links object specific to Error objects about : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that leads to further details about this particular occurrence of the problem. ErrorSource ( BaseModel ) pydantic-model \u00b6 an object containing references to the source of the error parameter : str pydantic-field \u00b6 a string indicating which URI query parameter caused the error. pointer : str pydantic-field \u00b6 a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute]. JsonApi ( BaseModel ) pydantic-model \u00b6 An object describing the server's implementation meta : Meta pydantic-field \u00b6 Non-standard meta information version : str pydantic-field \u00b6 Version of the json API used Link ( BaseModel ) pydantic-model \u00b6 A link MUST be represented as either: a string containing the link's URL or a link object. href : AnyUrl pydantic-field required \u00b6 a string containing the link\u2019s URL. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about the link. Meta ( BaseModel ) pydantic-model \u00b6 Non-standard meta-information that can not be represented as an attribute or relationship. Relationship ( BaseModel ) pydantic-model \u00b6 Representation references from the resource object in which it\u2019s defined to other resource objects. data : Union [ optimade . models . jsonapi . BaseResource , List [ optimade . models . jsonapi . BaseResource ]] pydantic-field \u00b6 Resource linkage links : RelationshipLinks pydantic-field \u00b6 a links object containing at least one of the following: self, related meta : Meta pydantic-field \u00b6 a meta object that contains non-standard meta-information about the relationship. RelationshipLinks ( BaseModel ) pydantic-model \u00b6 A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object. related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link to itself Relationships ( BaseModel ) pydantic-model \u00b6 Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id Resource ( BaseResource ) pydantic-model \u00b6 Resource objects appear in a JSON:API document to represent resources. attributes : Attributes pydantic-field \u00b6 an attributes object representing some of the resource\u2019s data. links : ResourceLinks pydantic-field \u00b6 a links object containing links related to the resource. meta : Meta pydantic-field \u00b6 a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship. relationships : Relationships pydantic-field \u00b6 a relationships object describing relationships between the resource and other JSON:API resources. ResourceLinks ( BaseModel ) pydantic-model \u00b6 A Resource Links object self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link that identifies the resource represented by the resource object. Response ( BaseModel ) pydantic-model \u00b6 A top-level response data : Union [ NoneType , optimade . models . jsonapi . Resource , List [ optimade . models . jsonapi . Resource ]] pydantic-field \u00b6 Outputted Data errors : List [ optimade . models . jsonapi . Error ] pydantic-field \u00b6 A list of unique errors included : List [ optimade . models . jsonapi . Resource ] pydantic-field \u00b6 A list of unique included resources jsonapi : JsonApi pydantic-field \u00b6 Information about the JSON API used links : ToplevelLinks pydantic-field \u00b6 Links associated with the primary data or errors meta : Meta pydantic-field \u00b6 A meta object containing non-standard information related to the Success __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ToplevelLinks ( BaseModel ) pydantic-model \u00b6 A set of Links objects, possibly including pagination first : AnyUrl pydantic-field \u00b6 The first page of data last : AnyUrl pydantic-field \u00b6 The last page of data next : AnyUrl pydantic-field \u00b6 The next page of data prev : AnyUrl pydantic-field \u00b6 The previous page of data related : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A related resource link self : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 A link to itself","title":"Jsonapi"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Attributes","text":"Members of the attributes object (\"attributes\") represent information about the resource object in which it's defined. The keys for Attributes MUST NOT be: relationships links id type","title":"Attributes"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.BaseResource","text":"Minimum requirements to represent a Resource","title":"BaseResource"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.BaseResource.id","text":"Resource ID","title":"id"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.BaseResource.type","text":"Resource type","title":"type"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error","text":"An error response","title":"Error"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.code","text":"an application-specific error code, expressed as a string value.","title":"code"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.detail","text":"A human-readable explanation specific to this occurrence of the problem.","title":"detail"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.id","text":"A unique identifier for this particular occurrence of the problem.","title":"id"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.links","text":"A links object storing about","title":"links"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.meta","text":"a meta object containing non-standard meta-information about the error.","title":"meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.source","text":"An object containing references to the source of the error","title":"source"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.status","text":"the HTTP status code applicable to this problem, expressed as a string value.","title":"status"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.title","text":"A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.","title":"title"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Error.__hash__","text":"Return hash(self). Source code in optimade/models/jsonapi.py def __hash__ ( self ): return hash ( self . json ())","title":"__hash__()"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ErrorLinks","text":"A Links object specific to Error objects","title":"ErrorLinks"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ErrorLinks.about","text":"A link that leads to further details about this particular occurrence of the problem.","title":"about"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ErrorSource","text":"an object containing references to the source of the error","title":"ErrorSource"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ErrorSource.parameter","text":"a string indicating which URI query parameter caused the error.","title":"parameter"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ErrorSource.pointer","text":"a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. \"/data\" for a primary data object, or \"/data/attributes/title\" for a specific attribute].","title":"pointer"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.JsonApi","text":"An object describing the server's implementation","title":"JsonApi"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.JsonApi.meta","text":"Non-standard meta information","title":"meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.JsonApi.version","text":"Version of the json API used","title":"version"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Link","text":"A link MUST be represented as either: a string containing the link's URL or a link object.","title":"Link"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Link.href","text":"a string containing the link\u2019s URL.","title":"href"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Link.meta","text":"a meta object containing non-standard meta-information about the link.","title":"meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Meta","text":"Non-standard meta-information that can not be represented as an attribute or relationship.","title":"Meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Relationship","text":"Representation references from the resource object in which it\u2019s defined to other resource objects.","title":"Relationship"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Relationship.data","text":"Resource linkage","title":"data"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Relationship.links","text":"a links object containing at least one of the following: self, related","title":"links"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Relationship.meta","text":"a meta object that contains non-standard meta-information about the relationship.","title":"meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks","text":"A resource object MAY contain references to other resource objects (\"relationships\"). Relationships may be to-one or to-many. Relationships can be specified by including a member in a resource's links object.","title":"RelationshipLinks"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks.related","text":"A related resource link","title":"related"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.RelationshipLinks.self","text":"A link to itself","title":"self"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Relationships","text":"Members of the relationships object (\"relationships\") represent references from the resource object in which it's defined to other resource objects. Keys MUST NOT be: type id","title":"Relationships"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Resource","text":"Resource objects appear in a JSON:API document to represent resources.","title":"Resource"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Resource.attributes","text":"an attributes object representing some of the resource\u2019s data.","title":"attributes"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Resource.links","text":"a links object containing links related to the resource.","title":"links"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Resource.meta","text":"a meta object containing non-standard meta-information about a resource that can not be represented as an attribute or relationship.","title":"meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Resource.relationships","text":"a relationships object describing relationships between the resource and other JSON:API resources.","title":"relationships"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ResourceLinks","text":"A Resource Links object","title":"ResourceLinks"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ResourceLinks.self","text":"A link that identifies the resource represented by the resource object.","title":"self"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response","text":"A top-level response","title":"Response"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.data","text":"Outputted Data","title":"data"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.errors","text":"A list of unique errors","title":"errors"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.included","text":"A list of unique included resources","title":"included"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.jsonapi","text":"Information about the JSON API used","title":"jsonapi"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.links","text":"Links associated with the primary data or errors","title":"links"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.meta","text":"A meta object containing non-standard information related to the Success","title":"meta"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.Response.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks","text":"A set of Links objects, possibly including pagination","title":"ToplevelLinks"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.first","text":"The first page of data","title":"first"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.last","text":"The last page of data","title":"last"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.next","text":"The next page of data","title":"next"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.prev","text":"The previous page of data","title":"prev"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.related","text":"A related resource link","title":"related"},{"location":"reference/models/jsonapi/#optimade.models.jsonapi.ToplevelLinks.self","text":"A link to itself","title":"self"},{"location":"reference/models/links/","text":"LinksResource ( EntryResource ) pydantic-model \u00b6 A Links endpoint resource object LinksResourceAttributes ( Attributes ) pydantic-model \u00b6 Links endpoint resource object attributes base_url : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to the base URL for this implementation description : str pydantic-field required \u00b6 Human-readable description for the OPTIMADE API implementation a client may provide in a list to an end-user. homepage : Union [ pydantic . networks . AnyUrl , optimade . models . jsonapi . Link ] pydantic-field required \u00b6 JSON API links object, pointing to a homepage URL for this implementation link_type : str pydantic-field required \u00b6 The link type of the represented resource in relation to this implementation. MUST be one of these values: 'child', 'root', 'external', 'providers'. name : str pydantic-field required \u00b6 Human-readable name for the OPTIMADE API implementation a client may provide in a list to an end-user.","title":"Links"},{"location":"reference/models/links/#optimade.models.links.LinksResource","text":"A Links endpoint resource object","title":"LinksResource"},{"location":"reference/models/links/#optimade.models.links.LinksResourceAttributes","text":"Links endpoint resource object attributes","title":"LinksResourceAttributes"},{"location":"reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url","text":"JSON API links object, pointing to the base URL for this implementation","title":"base_url"},{"location":"reference/models/links/#optimade.models.links.LinksResourceAttributes.description","text":"Human-readable description for the OPTIMADE API implementation a client may provide in a list to an end-user.","title":"description"},{"location":"reference/models/links/#optimade.models.links.LinksResourceAttributes.homepage","text":"JSON API links object, pointing to a homepage URL for this implementation","title":"homepage"},{"location":"reference/models/links/#optimade.models.links.LinksResourceAttributes.link_type","text":"The link type of the represented resource in relation to this implementation. MUST be one of these values: 'child', 'root', 'external', 'providers'.","title":"link_type"},{"location":"reference/models/links/#optimade.models.links.LinksResourceAttributes.name","text":"Human-readable name for the OPTIMADE API implementation a client may provide in a list to an end-user.","title":"name"},{"location":"reference/models/optimade_json/","text":"Modified JSON API v1.0 for OPTIMADE API BaseRelationshipMeta ( Meta ) pydantic-model \u00b6 Specific meta field for base relationship resource description : str pydantic-field required \u00b6 OPTIONAL human-readable description of the relationship BaseRelationshipResource ( BaseResource ) pydantic-model \u00b6 Minimum requirements to represent a relationship resource meta : BaseRelationshipMeta pydantic-field \u00b6 Relationship meta field. MUST contain 'description' if supplied. Implementation ( BaseModel ) pydantic-model \u00b6 Information on the server implementation maintainer : ImplementationMaintainer pydantic-field \u00b6 A dictionary providing details about the maintainer of the implementation. name : str pydantic-field \u00b6 name of the implementation source_url : AnyUrl pydantic-field \u00b6 URL of the implementation source, either downloadable archive or version control system version : str pydantic-field \u00b6 version string of the current implementation ImplementationMaintainer ( BaseModel ) pydantic-model \u00b6 Details about the maintainer of the implementation email : EmailStr pydantic-field required \u00b6 the maintainer's email address OptimadeError ( Error ) pydantic-model \u00b6 detail MUST be present Provider ( BaseModel ) pydantic-model \u00b6 Information on the database provider of the implementation. description : str pydantic-field required \u00b6 a longer description of the database provider homepage : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object. index_base_url : Union [ pydantic . networks . AnyHttpUrl , optimade . models . jsonapi . Link ] pydantic-field \u00b6 a JSON API links object pointing to the base URL for the index meta-database as specified in Appendix 1, either directly as a string, or as a link object. name : str pydantic-field required \u00b6 a short name for the database provider prefix : str pydantic-field required \u00b6 database-provider-specific prefix as found in Appendix 1. Relationship ( Relationship ) pydantic-model \u00b6 Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource ResponseMeta ( Meta ) pydantic-model \u00b6 A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix. api_version : str pydantic-field required \u00b6 a string containing the version of the API implementation, e.g. v0.9.5 data_available : int pydantic-field \u00b6 an integer containing the total number of data objects available in the database data_returned : ConstrainedIntValue pydantic-field required \u00b6 an integer containing the number of data objects returned for the query. implementation : Implementation pydantic-field \u00b6 a dictionary describing the server implementation last_id : str pydantic-field \u00b6 a string containing the last ID returned more_data_available : bool pydantic-field required \u00b6 false if all data has been returned, and true if not. provider : Provider pydantic-field required \u00b6 information on the database provider of the implementation. query : ResponseMetaQuery pydantic-field required \u00b6 information on the query that was requested response_message : str pydantic-field \u00b6 response string from the server time_stamp : datetime pydantic-field required \u00b6 a string containing the date and time at which the query was exexcuted warnings : List [ optimade . models . optimade_json . Warnings ] pydantic-field \u00b6 List of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status, representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects. ResponseMetaQuery ( BaseModel ) pydantic-model \u00b6 Information on the query that was requested. representation : str pydantic-field required \u00b6 a string with the part of the URL that follows the base URL. Example: '/structures?' Success ( Response ) pydantic-model \u00b6 errors are not allowed __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. either_data_meta_or_errors_must_be_set ( values ) classmethod \u00b6 Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values Warnings ( OptimadeError ) pydantic-model \u00b6 OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \" warning \" . The field detail MUST be present and SHOULD contain a non - critical message , e . g ., reporting unrecognized search attributes or deprecated features . Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class. type : str pydantic-field \u00b6 Warnings must be of type \"warning\"","title":"Optimade json"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipMeta","text":"Specific meta field for base relationship resource","title":"BaseRelationshipMeta"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipMeta.description","text":"OPTIONAL human-readable description of the relationship","title":"description"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipResource","text":"Minimum requirements to represent a relationship resource","title":"BaseRelationshipResource"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.BaseRelationshipResource.meta","text":"Relationship meta field. MUST contain 'description' if supplied.","title":"meta"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Implementation","text":"Information on the server implementation","title":"Implementation"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Implementation.maintainer","text":"A dictionary providing details about the maintainer of the implementation.","title":"maintainer"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Implementation.name","text":"name of the implementation","title":"name"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Implementation.source_url","text":"URL of the implementation source, either downloadable archive or version control system","title":"source_url"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Implementation.version","text":"version string of the current implementation","title":"version"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ImplementationMaintainer","text":"Details about the maintainer of the implementation","title":"ImplementationMaintainer"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ImplementationMaintainer.email","text":"the maintainer's email address","title":"email"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.OptimadeError","text":"detail MUST be present","title":"OptimadeError"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Provider","text":"Information on the database provider of the implementation.","title":"Provider"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Provider.description","text":"a longer description of the database provider","title":"description"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Provider.homepage","text":"a JSON API links object pointing to homepage of the database provider, either directly as a string, or as a link object.","title":"homepage"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Provider.index_base_url","text":"a JSON API links object pointing to the base URL for the index meta-database as specified in Appendix 1, either directly as a string, or as a link object.","title":"index_base_url"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Provider.name","text":"a short name for the database provider","title":"name"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Provider.prefix","text":"database-provider-specific prefix as found in Appendix 1.","title":"prefix"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Relationship","text":"Similar to normal JSON API relationship, but with addition of OPTIONAL meta field for a resource","title":"Relationship"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta","text":"A JSON API meta member that contains JSON API meta objects of non-standard meta-information. OPTIONAL additional information global to the query that is not specified in this document, MUST start with a database-provider-specific prefix.","title":"ResponseMeta"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.api_version","text":"a string containing the version of the API implementation, e.g. v0.9.5","title":"api_version"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.data_available","text":"an integer containing the total number of data objects available in the database","title":"data_available"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.data_returned","text":"an integer containing the number of data objects returned for the query.","title":"data_returned"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.implementation","text":"a dictionary describing the server implementation","title":"implementation"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.last_id","text":"a string containing the last ID returned","title":"last_id"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.more_data_available","text":"false if all data has been returned, and true if not.","title":"more_data_available"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.provider","text":"information on the database provider of the implementation.","title":"provider"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.query","text":"information on the query that was requested","title":"query"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.response_message","text":"response string from the server","title":"response_message"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.time_stamp","text":"a string containing the date and time at which the query was exexcuted","title":"time_stamp"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMeta.warnings","text":"List of warning resource objects representing non-critical errors or warnings. A warning resource object is defined similarly to a JSON API error object, but MUST also include the field type, which MUST have the value \"warning\". The field detail MUST be present and SHOULD contain a non-critical message, e.g., reporting unrecognized search attributes or deprecated features. The field status, representing a HTTP response status code, MUST NOT be present for a warning resource object. This is an exclusive field for error resource objects.","title":"warnings"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMetaQuery","text":"Information on the query that was requested.","title":"ResponseMetaQuery"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.ResponseMetaQuery.representation","text":"a string with the part of the URL that follows the base URL. Example: '/structures?'","title":"representation"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Success","text":"errors are not allowed","title":"Success"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Success.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Success.either_data_meta_or_errors_must_be_set","text":"Overwriting the existing validation function, since 'errors' MUST NOT be set Source code in optimade/models/optimade_json.py @root_validator ( pre = True ) def either_data_meta_or_errors_must_be_set ( cls , values ): \"\"\"Overwriting the existing validation function, since 'errors' MUST NOT be set\"\"\" required_fields = ( \"data\" , \"meta\" ) if not any ( values . get ( field ) for field in required_fields ): raise ValueError ( f \"At least one of { required_fields } MUST be specified in the top-level response\" ) # errors MUST be skipped if values . get ( \"errors\" , None ) is not None : raise ValueError ( \"'errors' MUST be skipped for a successful response\" ) return values","title":"either_data_meta_or_errors_must_be_set()"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Warnings","text":"OPTIMADE-specific warning class based on OPTIMADE-specific JSON API Error. From the specification: A warning resource object is defined similarly to a JSON API error object , but MUST also include the field type , which MUST have the value \" warning \" . The field detail MUST be present and SHOULD contain a non - critical message , e . g ., reporting unrecognized search attributes or deprecated features . Note: Must be named \"Warnings\", since \"Warning\" is a built-in Python class.","title":"Warnings"},{"location":"reference/models/optimade_json/#optimade.models.optimade_json.Warnings.type","text":"Warnings must be of type \"warning\"","title":"type"},{"location":"reference/models/references/","text":"Person ( BaseModel ) pydantic-model \u00b6 firstname : str pydantic-field \u00b6 First name of the person. lastname : str pydantic-field \u00b6 Last name of the person. ReferenceResource ( EntryResource ) pydantic-model \u00b6 The :entry: references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , type , volume , year : Meanings of these properties match the BibTeX specification <http://bibtexml.sourceforge.net/btxdoc.pdf> __, values are strings; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL, i.e., any of the properties MAY be :val: null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties. ReferenceResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification . address : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. annote : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. authors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the authors of the reference. bib_type : str pydantic-field \u00b6 Type of the reference, corresponding to the type property in the BiBTeX specification. booktitle : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. chapter : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. crossref : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. doi : str pydantic-field \u00b6 The digital object identifier of the reference. edition : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. editors : List [ optimade . models . references . Person ] pydantic-field \u00b6 List of person objects containing the editors of the reference. howpublished : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. institution : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. journal : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. key : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. month : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. note : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. number : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. organization : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. pages : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. publisher : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. school : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. series : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. title : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. url : AnyUrl pydantic-field \u00b6 The URL of the reference. volume : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification. year : str pydantic-field \u00b6 Meaning of property matches the BiBTeX specification.","title":"References"},{"location":"reference/models/references/#optimade.models.references.Person","text":"","title":"Person"},{"location":"reference/models/references/#optimade.models.references.Person.firstname","text":"First name of the person.","title":"firstname"},{"location":"reference/models/references/#optimade.models.references.Person.lastname","text":"Last name of the person.","title":"lastname"},{"location":"reference/models/references/#optimade.models.references.ReferenceResource","text":"The :entry: references entries describe bibliographic references. The following properties are used to provide the bibliographic details: address , annote , booktitle , chapter , crossref , edition , howpublished , institution , journal , key , month , note , number , organization , pages , publisher , school , series , title , type , volume , year : Meanings of these properties match the BibTeX specification <http://bibtexml.sourceforge.net/btxdoc.pdf> __, values are strings; authors and editors : lists of person objects which are dictionaries with the following keys: name : Full name of the person, REQUIRED. firstname , lastname : Parts of the person's name, OPTIONAL. doi and url : values are strings. Requirements/Conventions : Support : OPTIONAL, i.e., any of the properties MAY be :val: null . Query : Support for queries on any of these properties is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Every references entry MUST contain at least one of the properties.","title":"ReferenceResource"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes","text":"Model that stores the attributes of a reference. Many properties match the meaning described in the BibTeX specification .","title":"ReferenceResourceAttributes"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.address","text":"Meaning of property matches the BiBTeX specification.","title":"address"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.annote","text":"Meaning of property matches the BiBTeX specification.","title":"annote"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.authors","text":"List of person objects containing the authors of the reference.","title":"authors"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.bib_type","text":"Type of the reference, corresponding to the type property in the BiBTeX specification.","title":"bib_type"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.booktitle","text":"Meaning of property matches the BiBTeX specification.","title":"booktitle"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.chapter","text":"Meaning of property matches the BiBTeX specification.","title":"chapter"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.crossref","text":"Meaning of property matches the BiBTeX specification.","title":"crossref"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.doi","text":"The digital object identifier of the reference.","title":"doi"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.edition","text":"Meaning of property matches the BiBTeX specification.","title":"edition"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.editors","text":"List of person objects containing the editors of the reference.","title":"editors"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.howpublished","text":"Meaning of property matches the BiBTeX specification.","title":"howpublished"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.institution","text":"Meaning of property matches the BiBTeX specification.","title":"institution"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.journal","text":"Meaning of property matches the BiBTeX specification.","title":"journal"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.key","text":"Meaning of property matches the BiBTeX specification.","title":"key"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.month","text":"Meaning of property matches the BiBTeX specification.","title":"month"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.note","text":"Meaning of property matches the BiBTeX specification.","title":"note"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.number","text":"Meaning of property matches the BiBTeX specification.","title":"number"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.organization","text":"Meaning of property matches the BiBTeX specification.","title":"organization"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.pages","text":"Meaning of property matches the BiBTeX specification.","title":"pages"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.publisher","text":"Meaning of property matches the BiBTeX specification.","title":"publisher"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.school","text":"Meaning of property matches the BiBTeX specification.","title":"school"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.series","text":"Meaning of property matches the BiBTeX specification.","title":"series"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.title","text":"Meaning of property matches the BiBTeX specification.","title":"title"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.url","text":"The URL of the reference.","title":"url"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.volume","text":"Meaning of property matches the BiBTeX specification.","title":"volume"},{"location":"reference/models/references/#optimade.models.references.ReferenceResourceAttributes.year","text":"Meaning of property matches the BiBTeX specification.","title":"year"},{"location":"reference/models/responses/","text":"EntryInfoResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. EntryResponseMany ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. EntryResponseOne ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ErrorResponse ( Response ) pydantic-model \u00b6 errors MUST be present and data MUST be skipped __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. IndexInfoResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. InfoResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. LinksResponse ( EntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ReferenceResponseMany ( EntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ReferenceResponseOne ( EntryResponseOne ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. StructureResponseMany ( EntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. StructureResponseOne ( EntryResponseOne ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"Responses"},{"location":"reference/models/responses/#optimade.models.responses.EntryInfoResponse","text":"","title":"EntryInfoResponse"},{"location":"reference/models/responses/#optimade.models.responses.EntryInfoResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.EntryResponseMany","text":"","title":"EntryResponseMany"},{"location":"reference/models/responses/#optimade.models.responses.EntryResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.EntryResponseOne","text":"","title":"EntryResponseOne"},{"location":"reference/models/responses/#optimade.models.responses.EntryResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.ErrorResponse","text":"errors MUST be present and data MUST be skipped","title":"ErrorResponse"},{"location":"reference/models/responses/#optimade.models.responses.ErrorResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.IndexInfoResponse","text":"","title":"IndexInfoResponse"},{"location":"reference/models/responses/#optimade.models.responses.IndexInfoResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.InfoResponse","text":"","title":"InfoResponse"},{"location":"reference/models/responses/#optimade.models.responses.InfoResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.LinksResponse","text":"","title":"LinksResponse"},{"location":"reference/models/responses/#optimade.models.responses.LinksResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.ReferenceResponseMany","text":"","title":"ReferenceResponseMany"},{"location":"reference/models/responses/#optimade.models.responses.ReferenceResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.ReferenceResponseOne","text":"","title":"ReferenceResponseOne"},{"location":"reference/models/responses/#optimade.models.responses.ReferenceResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.StructureResponseMany","text":"","title":"StructureResponseMany"},{"location":"reference/models/responses/#optimade.models.responses.StructureResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/responses/#optimade.models.responses.StructureResponseOne","text":"","title":"StructureResponseOne"},{"location":"reference/models/responses/#optimade.models.responses.StructureResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/models/structures/","text":"Assembly ( BaseModel ) pydantic-model \u00b6 A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). group_probabilities : List [ float ] pydantic-field required \u00b6 Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _. sites_in_groups : List [ List [ int ]] pydantic-field required \u00b6 Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth. Periodicity ( IntEnum ) \u00b6 An enumeration. Species ( BaseModel ) pydantic-model \u00b6 A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13. chemical_symbols : List [ str ] pydantic-field required \u00b6 MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). concentration : List [ float ] pydantic-field required \u00b6 MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : float pydantic-field \u00b6 If present MUST be a float expressed in a.m.u. original_name : str pydantic-field \u00b6 Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _). StructureResource ( EntryResource ) pydantic-model \u00b6 Representing a structure. StructureResourceAttributes ( EntryResourceAttributes ) pydantic-model \u00b6 This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions. assemblies : List [ optimade . models . structures . Assembly ] pydantic-field \u00b6 A description of groups of sites that are statistically correlated. - Type : list of dictionary with keys: :property: sites_in_groups : list of list of integers (REQUIRED) :property: group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. If present, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _. If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: .. code:: jsonc { \"cartesian_site_positions\": [[0,0,0]], \"species_at_sites\": [\"SiGe-vac\"], \"species\": [ { \"name\": \"SiGe-vac\", \"chemical_symbols\": [\"Si\", \"Ge\", \"vacancy\"], \"concentration\": [0.3, 0.5, 0.2] } ] // ... } Using multiple species and the assemblies: .. code:: jsonc { \"cartesian_site_positions\": [ [0,0,0], [0,0,0], [0,0,0] ], \"species_at_sites\": [\"Si\", \"Ge\", \"vac\"], \"species\": { \"Si\": { \"chemical_symbols\": [\"Si\"], \"concentration\": [1.0] }, \"Ge\": { \"chemical_symbols\": [\"Ge\"], \"concentration\": [1.0] }, \"vac\": { \"chemical_symbols\": [\"vacancy\"], \"concentration\": [1.0] } }, \"assemblies\": [ { \"sites_in_groups\": [ [0], [1], [2] ], \"group_probabilities\": [0.3, 0.5, 0.2] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: .. code:: jsonc { \"assemblies\": [ { \"sites_in_groups\": [ [0], [1] ], \"group_probabilities\": [0.2, 0.8], }, { \"sites_in_groups\": [ [2], [3] ], \"group_probabilities\": [0.3, 0.7] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability). cartesian_site_positions : List [ Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float ]]] pydantic-field required \u00b6 Cartesian positions of each site. A site is an atom, a site potentially occupied by an atom, or a placeholder for a virtual mixture of atoms (e.g., in a virtual crystal approximation). - Type : list of list of floats and/or unknown values - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length N times 3, where N is the number of sites in the structure. An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies _). If a component of the position is unknown, the :val: null value should be provided instead (see section Properties with unknown value ). Otherwise, it should be a float value, expressed in angstrom (\u00c5). If at least one of the coordinates is unknown, the correct flag in the list property structure_features MUST be set. Notes : (for implementers) While this is unrelated to this OPTIMADE specification: If you decide to store internally the :property: cartesian_site_positions as a float array, you might want to represent :val: null values with :field-val: NaN values. The latter being valid float numbers in the IEEE 754 standard in IEEE 754-1985 <https://doi.org/10.1109/IEEESTD.1985.82928> and in the updated version IEEE 754-2008 <https://doi.org/10.1109/IEEESTD.2008.4610935> . Examples : :val: [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin. chemical_formula_anonymous : str pydantic-field required \u00b6 The anonymous formula is the :property: chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : :val: \"A2B\" :val: \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is :filter: chemical_formula_anonymous=\"A2B\" . chemical_formula_descriptive : str pydantic-field required \u00b6 The chemical formula for a structure as a string in a form chosen by the API implementation. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the :property: chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry <https://www.qmul.ac.uk/sbcs/iupac/bibliog/blue.html> __. Examples : :val: \"(H2O)2 Na\" :val: \"NaCl\" :val: \"CaCO3\" :val: \"CCaO3\" :val: \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: :filter: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: :filter: chemical_formula_descriptive CONTAINS \"H2O\" . chemical_formula_hill : str pydantic-field \u00b6 The chemical formula for a structure in Hill form <https://dx.doi.org/10.1021/ja02046a005> __ with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : Support for queries on these properties are OPTIONAL. If supported, only a subset of filter operators MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, :property: chemical_formula_hill is :val: \"H2O2\" (i.e., not :val: \"HO\" , nor :val: \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in Hill order <https://dx.doi.org/10.1021/ja02046a005> __, followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : :val: \"H2O2\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_hill=\"H2O2\" . chemical_formula_reduced : str pydantic-field required \u00b6 The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate querying on formula components are instead recommended to be formulated using set-type filter operators on the multi valued :property: elements and :property: elements_proportions properties. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : :val: \"H2NaO\" :val: \"ClNa\" :val: \"CCaO3\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_reduced=\"H2NaO\" . dimension_types : Tuple [ optimade . models . structures . Periodicity , optimade . models . structures . Periodicity , optimade . models . structures . Periodicity ] pydantic-field required \u00b6 List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ). This list indicates if the direction is periodic (value :val: 1 ) or non-periodic (value :val: 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in property lattice_vectors and not the Cartesian x, y, z directions. - Type : list of integers. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. Support for equality comparison is REQUIRED, support for other comparison operators are OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: :val: [0, 0, 0] For a wire along the direction specified by the third lattice vector: :val: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: :val: [1, 0, 1] For a bulk 3D system: :val: [1, 1, 1] elements : List [ str ] pydantic-field required \u00b6 Names of the different elements present in the structure. - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The strings are the chemical symbols, written as uppercase letter plus optional lowercase letters. The order MUST be alphabetical. Note: This may not contain the \"x\" that is suggested in chemical_symbols for the :property: species property. Examples : :val: [\"Si\"] :val: [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: :filter: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use :filter: elements HAS ALL \"Si\", \"Al\", \"O\" AND LENGTH elements = 3 . elements_ratios : List [ float ] pydantic-field required \u00b6 Relative proportions of different elements in the structure. - Type : list of floats - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : :val: [1.0] :val: [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally not recommended. A filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: :filter: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 . lattice_vectors : Tuple [ Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float , NoneType ]], Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float , NoneType ]], Tuple [ Union [ float , NoneType ], Union [ float , NoneType ], Union [ float ]]] pydantic-field \u00b6 The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). - Type : list of list of floats. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. This property MUST be an array of dimensions 3 times 3 regardless of the elements of :property: dimension_types . The vectors SHOULD by convention be chosen so the determinant of the :property: lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. All three elements of the inner lists of floats MAY be :val: null for non-periodic dimensions, i.e., those dimensions for which :property: dimension_types is :val: 0 . Examples : :val: [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is :val: (4, 0, 0) , i.e., a vector aligned along the :val: x axis of length 4 \u00c5; the second vector is :val: (0, 4, 0) ; and the third vector is :val: (0, 1, 4) . nelements : int pydantic-field required \u00b6 Number of different elements in the structure as an integer. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Example : :val: 3 Querying : Note: queries on this property can equivalently be formulated using :filter-fragment: LENGTH elements . A filter that matches structures that have exactly 4 elements: :filter: nelements=4 . A filter that matches structures that have between 2 and 7 elements: :filter: nelements>=2 AND nelements<=7 . nsites : int pydantic-field required \u00b6 An integer specifying the length of the :property: cartesian_site_positions property. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Examples : :val: 42 Query examples : Match only structures with exactly 4 sites: :filter: nsites=4 Match structures that have between 2 and 7 sites: :filter: nsites>=2 AND nsites<=7 species : List [ optimade . models . structures . Species ] pydantic-field required \u00b6 A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. - Type : list of dictionary with keys: :property: name : string (REQUIRED) :property: chemical_symbols : list of strings (REQUIRED) :property: concentration : list of float (REQUIRED) :property: mass : float (OPTIONAL) :property: original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the :property: species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). concentration : REQUIRED; MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : OPTIONAL. If present MUST be a float expressed in a.m.u. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., :val: \"Ti\" for titanium, :val: \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species :val: {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13. species_at_sites : List [ str ] pydantic-field required \u00b6 Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions _). Each species MUST have a unique name. Each species name mentioned in the :property: species_at_sites list MUST be described in the list property species _ (i.e. for each value in the :property: species_at_sites list there MUST exist exactly one dictionary in the :property: species list with the :property: name attribute equal to the corresponding :property: species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : :val: [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled :val: \"Ti\" and the second a species labeled :val: \"O2\" . structure_features : List [ str ] pydantic-field required \u00b6 A list of strings that flag which special features are used by the structure. - Type : list of strings - Requirements/Conventions : Support : REQUIRED, MUST NOT be :val: null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : :val: disorder : This flag MUST be present if any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element. :val: unknown_positions : This flag MUST be present if at least one component of the :property: cartesian_site_positions list of lists has value :val: null . :val: assemblies : This flag MUST be present if the property assemblies _ is present. Examples : A structure having unknown positions and using assemblies: :val: [\"assemblies\", \"unknown_positions\"]","title":"Structures"},{"location":"reference/models/structures/#optimade.models.structures.Assembly","text":"A description of groups of sites that are statistically correlated. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent).","title":"Assembly"},{"location":"reference/models/structures/#optimade.models.structures.Assembly.group_probabilities","text":"Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _.","title":"group_probabilities"},{"location":"reference/models/structures/#optimade.models.structures.Assembly.sites_in_groups","text":"Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth.","title":"sites_in_groups"},{"location":"reference/models/structures/#optimade.models.structures.Periodicity","text":"An enumeration.","title":"Periodicity"},{"location":"reference/models/structures/#optimade.models.structures.Species","text":"A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13.","title":"Species"},{"location":"reference/models/structures/#optimade.models.structures.Species.chemical_symbols","text":"MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _).","title":"chemical_symbols"},{"location":"reference/models/structures/#optimade.models.structures.Species.concentration","text":"MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species).","title":"concentration"},{"location":"reference/models/structures/#optimade.models.structures.Species.mass","text":"If present MUST be a float expressed in a.m.u.","title":"mass"},{"location":"reference/models/structures/#optimade.models.structures.Species.original_name","text":"Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. Note: With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _).","title":"original_name"},{"location":"reference/models/structures/#optimade.models.structures.StructureResource","text":"Representing a structure.","title":"StructureResource"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes","text":"This class contains the Field for the attributes used to represent a structure, e.g. unit cell, atoms, positions.","title":"StructureResourceAttributes"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.assemblies","text":"A description of groups of sites that are statistically correlated. - Type : list of dictionary with keys: :property: sites_in_groups : list of list of integers (REQUIRED) :property: group_probabilities : list of floats (REQUIRED) Requirements/Conventions : Support : OPTIONAL support in implementations, i.e., MAY be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. If present, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). Client implementations MUST check its presence (as its presence changes the interpretation of the structure). If present, it MUST be a list of dictionaries, each of which represents an assembly and MUST have the following two keys: sites_in_groups : Index of the sites (0-based) that belong to each group for each assembly. Example: :val: [[1], [2]] : two groups, one with the second site, one with the third. Example: :val: [[1,2], [3]] : one group with the second and third site, one with the fourth. group_probabilities : Statistical probability of each group. It MUST have the same length as :property: sites_in_groups . It SHOULD sum to one. See below for examples of how to specify the probability of the occurrence of a vacancy. The possible reasons for the values not to sum to one are the same as already specified above for the :property: concentration of each :property: species , see property species _. If a site is not present in any group, it means that it is present with 100 % probability (as if no assembly was specified). A site MUST NOT appear in more than one group. Examples (for each entry of the assemblies list): :val: {\"sites_in_groups\": [[0], [1]], \"group_probabilities: [0.3, 0.7]} : the first site and the second site never occur at the same time in the unit cell. Statistically, 30 % of the times the first site is present, while 70 % of the times the second site is present. :val: {\"sites_in_groups\": [[1,2], [3]], \"group_probabilities: [0.3, 0.7]} : the second and third site are either present together or not present; they form the first group of atoms for this assembly. The second group is formed by the fourth site. Sites of the first group (the second and the third) are never present at the same time as the fourth site. 30 % of times sites 1 and 2 are present (and site 3 is absent); 70 % of times site 3 is present (and sites 1 and 2 are absent). Notes : Assemblies are essential to represent, for instance, the situation where an atom can statistically occupy two different positions (sites). By defining groups, it is possible to represent, e.g., the case where a functional molecule (and not just one atom) is either present or absent (or the case where it it is present in two conformations) Considerations on virtual alloys and on vacancies: In the special case of a virtual alloy, these specifications allow two different, equivalent ways of specifying them. For instance, for a site at the origin with 30 % probability of being occupied by Si, 50 % probability of being occupied by Ge, and 20 % of being a vacancy, the following two representations are possible: Using a single species: .. code:: jsonc { \"cartesian_site_positions\": [[0,0,0]], \"species_at_sites\": [\"SiGe-vac\"], \"species\": [ { \"name\": \"SiGe-vac\", \"chemical_symbols\": [\"Si\", \"Ge\", \"vacancy\"], \"concentration\": [0.3, 0.5, 0.2] } ] // ... } Using multiple species and the assemblies: .. code:: jsonc { \"cartesian_site_positions\": [ [0,0,0], [0,0,0], [0,0,0] ], \"species_at_sites\": [\"Si\", \"Ge\", \"vac\"], \"species\": { \"Si\": { \"chemical_symbols\": [\"Si\"], \"concentration\": [1.0] }, \"Ge\": { \"chemical_symbols\": [\"Ge\"], \"concentration\": [1.0] }, \"vac\": { \"chemical_symbols\": [\"vacancy\"], \"concentration\": [1.0] } }, \"assemblies\": [ { \"sites_in_groups\": [ [0], [1], [2] ], \"group_probabilities\": [0.3, 0.5, 0.2] } ] // ... } It is up to the database provider to decide which representation to use, typically depending on the internal format in which the structure is stored. However, given a structure identified by a unique ID, the API implementation MUST always provide the same representation for it. The probabilities of occurrence of different assemblies are uncorrelated. So, for instance in the following case with two assemblies: .. code:: jsonc { \"assemblies\": [ { \"sites_in_groups\": [ [0], [1] ], \"group_probabilities\": [0.2, 0.8], }, { \"sites_in_groups\": [ [2], [3] ], \"group_probabilities\": [0.3, 0.7] } ] } Site 0 is present with a probability of 20 % and site 1 with a probability of 80 %. These two sites are correlated (either site 0 or 1 is present). Similarly, site 2 is present with a probability of 30 % and site 3 with a probability of 70 %. These two sites are correlated (either site 2 or 3 is present). However, the presence or absence of sites 0 and 1 is not correlated with the presence or absence of sites 2 and 3 (in the specific example, the pair of sites (0, 2) can occur with 0.2 0.3 = 6 % probability; the pair (0, 3) with 0.2 0.7 = 14 % probability; the pair (1, 2) with 0.8 0.3 = 24 % probability; and the pair (1, 3) with 0.8 0.7 = 56 % probability).","title":"assemblies"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.cartesian_site_positions","text":"Cartesian positions of each site. A site is an atom, a site potentially occupied by an atom, or a placeholder for a virtual mixture of atoms (e.g., in a virtual crystal approximation). - Type : list of list of floats and/or unknown values - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. It MUST be a list of length N times 3, where N is the number of sites in the structure. An entry MAY have multiple sites at the same Cartesian position (for a relevant use of this, see e.g., the property assemblies _). If a component of the position is unknown, the :val: null value should be provided instead (see section Properties with unknown value ). Otherwise, it should be a float value, expressed in angstrom (\u00c5). If at least one of the coordinates is unknown, the correct flag in the list property structure_features MUST be set. Notes : (for implementers) While this is unrelated to this OPTIMADE specification: If you decide to store internally the :property: cartesian_site_positions as a float array, you might want to represent :val: null values with :field-val: NaN values. The latter being valid float numbers in the IEEE 754 standard in IEEE 754-1985 <https://doi.org/10.1109/IEEESTD.1985.82928> and in the updated version IEEE 754-2008 <https://doi.org/10.1109/IEEESTD.2008.4610935> . Examples : :val: [[0,0,0],[0,0,2]] indicates a structure with two sites, one sitting at the origin and one along the (positive) z -axis, 2 \u00c5 away from the origin.","title":"cartesian_site_positions"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_anonymous","text":"The anonymous formula is the :property: chemical_formula_reduced , but where the elements are instead first ordered by their chemical proportion number, and then, in order left to right, replaced by anonymous symbols A, B, C, ..., Z, Aa, Ba, ..., Za, Ab, Bb, ... and so on. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Examples : :val: \"A2B\" :val: \"A42B42C16D12E10F9G5\" Querying : A filter that matches an exactly given formula is :filter: chemical_formula_anonymous=\"A2B\" .","title":"chemical_formula_anonymous"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_descriptive","text":"The chemical formula for a structure as a string in a form chosen by the API implementation. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The chemical formula is given as a string consisting of properly capitalized element symbols followed by integers or decimal numbers, balanced parentheses, square, and curly brackets ( , ) , [ , ] , { , } , commas, the + , - , : and = symbols. The parentheses are allowed to be followed by a number. Spaces are allowed anywhere except within chemical symbols. The order of elements and any groupings indicated by parentheses or brackets are chosen freely by the API implementation. The string SHOULD be arithmetically consistent with the element ratios in the :property: chemical_formula_reduced property. It is RECOMMENDED, but not mandatory, that symbols, parentheses and brackets, if used, are used with the meanings prescribed by IUPAC's Nomenclature of Organic Chemistry <https://www.qmul.ac.uk/sbcs/iupac/bibliog/blue.html> __. Examples : :val: \"(H2O)2 Na\" :val: \"NaCl\" :val: \"CaCO3\" :val: \"CCaO3\" :val: \"(CH3)3N+ - [CH2]2-OH = Me3N+ - CH2 - CH2OH\" Query examples : Note: the free-form nature of this property is likely to make queries on it across different databases inconsistent. A filter that matches an exactly given formula: :filter: chemical_formula_descriptive=\"(H2O)2 Na\" . A filter that does a partial match: :filter: chemical_formula_descriptive CONTAINS \"H2O\" .","title":"chemical_formula_descriptive"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_hill","text":"The chemical formula for a structure in Hill form <https://dx.doi.org/10.1021/ja02046a005> __ with element symbols followed by integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : OPTIONAL, i.e., MAY be :val: null . Query : Support for queries on these properties are OPTIONAL. If supported, only a subset of filter operators MAY be supported. The overall scale factor of the chemical proportions is chosen such that the resulting values are integers that indicate the most chemically relevant unit of which the system is composed. For example, if the structure is a repeating unit cell with four hydrogens and four oxygens that represents two hydroperoxide molecules, :property: chemical_formula_hill is :val: \"H2O2\" (i.e., not :val: \"HO\" , nor :val: \"H4O4\" ). If the chemical insight needed to ascribe a Hill formula to the system is not present, the property MUST be handled as unset. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in Hill order <https://dx.doi.org/10.1021/ja02046a005> __, followed by their integer chemical proportion number. Hill order means: if carbon is present, it is placed first, and if also present, hydrogen is placed second. After that, all other elements are ordered alphabetically. If carbon is not present, all elements are ordered alphabetically. If the system has sites with partial occupation and the total occupations of each element do not all sum up to integers, then the Hill formula SHOULD be handled as unset. No spaces or separators are allowed. Examples : :val: \"H2O2\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_hill=\"H2O2\" .","title":"chemical_formula_hill"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.chemical_formula_reduced","text":"The reduced chemical formula for a structure as a string with element symbols and integer chemical proportion numbers. The proportion number MUST be omitted if it is 1. - Type : string - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. However, support for filters using partial string matching with this property is OPTIONAL (i.e., BEGINS WITH, ENDS WITH, and CONTAINS). Intricate querying on formula components are instead recommended to be formulated using set-type filter operators on the multi valued :property: elements and :property: elements_proportions properties. Element names MUST have proper capitalization (e.g., :val: \"Si\" , not :VAL: \"SI\" for \"silicon\"). Elements MUST be placed in alphabetical order, followed by their integer chemical proportion number. For structures with no partial occupation, the chemical proportion numbers are the smallest integers for which the chemical proportion is exactly correct. For structures with partial occupation, the chemical proportion numbers are integers that within reasonable approximation indicate the correct chemical proportions. The precise details of how to perform the rounding is chosen by the API implementation. No spaces or separators are allowed. Examples : :val: \"H2NaO\" :val: \"ClNa\" :val: \"CCaO3\" Query examples : A filter that matches an exactly given formula is :filter: chemical_formula_reduced=\"H2NaO\" .","title":"chemical_formula_reduced"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.dimension_types","text":"List of three integers. For each of the three directions indicated by the three lattice vectors (see property lattice_vectors ). This list indicates if the direction is periodic (value :val: 1 ) or non-periodic (value :val: 0 ). Note: the elements in this list each refer to the direction of the corresponding entry in property lattice_vectors and not the Cartesian x, y, z directions. - Type : list of integers. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property. Support for equality comparison is REQUIRED, support for other comparison operators are OPTIONAL. MUST be a list of length 3. Each integer element MUST assume only the value 0 or 1. Examples : For a molecule: :val: [0, 0, 0] For a wire along the direction specified by the third lattice vector: :val: [0, 0, 1] For a 2D surface/slab, periodic on the plane defined by the first and third lattice vectors: :val: [1, 0, 1] For a bulk 3D system: :val: [1, 1, 1]","title":"dimension_types"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.elements","text":"Names of the different elements present in the structure. - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. The strings are the chemical symbols, written as uppercase letter plus optional lowercase letters. The order MUST be alphabetical. Note: This may not contain the \"x\" that is suggested in chemical_symbols for the :property: species property. Examples : :val: [\"Si\"] :val: [\"Al\",\"O\",\"Si\"] Query examples : A filter that matches all records of structures that contain Si, Al and O, and possibly other elements: :filter: elements HAS ALL \"Si\", \"Al\", \"O\" . To match structures with exactly these three elements, use :filter: elements HAS ALL \"Si\", \"Al\", \"O\" AND LENGTH elements = 3 .","title":"elements"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.elements_ratios","text":"Relative proportions of different elements in the structure. - Type : list of floats - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Composed by the proportions of elements in the structure as a list of floating point numbers. The sum of the numbers MUST be 1.0 (within floating point accuracy) Examples : :val: [1.0] :val: [0.3333333333333333, 0.2222222222222222, 0.4444444444444444] Query examples : Note: useful filters can be formulated using the set operator syntax for correlated values. However, since the values are floating point values, the use of equality comparisons is generally not recommended. A filter that matches structures where approximately 1/3 of the atoms in the structure are the element Al is: :filter: elements:elements_ratios HAS ALL \"Al\":>0.3333, \"Al\":<0.3334 .","title":"elements_ratios"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.lattice_vectors","text":"The three lattice vectors in Cartesian coordinates, in \u00e5ngstr\u00f6m (\u00c5). - Type : list of list of floats. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST be a list of three vectors a , b , and c , where each of the vectors MUST BE a list of the vector's coordinates along the x, y, and z Cartesian coordinates. (Therefore, the first index runs over the three lattice vectors and the second index runs over the x, y, z Cartesian coordinates). For databases that do not define an absolute Cartesian system (e.g., only defining the length and angles between vectors), the first lattice vector SHOULD be set along x and the second on the xy -plane. This property MUST be an array of dimensions 3 times 3 regardless of the elements of :property: dimension_types . The vectors SHOULD by convention be chosen so the determinant of the :property: lattice_vectors matrix is different from zero. The vectors in the non-periodic directions have no significance beyond fulfilling these requirements. All three elements of the inner lists of floats MAY be :val: null for non-periodic dimensions, i.e., those dimensions for which :property: dimension_types is :val: 0 . Examples : :val: [[4.0,0.0,0.0],[0.0,4.0,0.0],[0.0,1.0,4.0]] represents a cell, where the first vector is :val: (4, 0, 0) , i.e., a vector aligned along the :val: x axis of length 4 \u00c5; the second vector is :val: (0, 4, 0) ; and the third vector is :val: (0, 1, 4) .","title":"lattice_vectors"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.nelements","text":"Number of different elements in the structure as an integer. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Example : :val: 3 Querying : Note: queries on this property can equivalently be formulated using :filter-fragment: LENGTH elements . A filter that matches structures that have exactly 4 elements: :filter: nelements=4 . A filter that matches structures that have between 2 and 7 elements: :filter: nelements>=2 AND nelements<=7 .","title":"nelements"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.nsites","text":"An integer specifying the length of the :property: cartesian_site_positions property. - Type : integer - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : MUST be a queryable property with support for all mandatory filter operators. Examples : :val: 42 Query examples : Match only structures with exactly 4 sites: :filter: nsites=4 Match structures that have between 2 and 7 sites: :filter: nsites>=2 AND nsites<=7","title":"nsites"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.species","text":"A list describing the species of the sites of this structure. Species can be pure chemical elements, or virtual-crystal atoms representing a statistical occupation of a given site by multiple chemical elements. - Type : list of dictionary with keys: :property: name : string (REQUIRED) :property: chemical_symbols : list of strings (REQUIRED) :property: concentration : list of float (REQUIRED) :property: mass : float (OPTIONAL) :property: original_name : string (OPTIONAL). Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. Each list member MUST be a dictionary with the following keys: name : REQUIRED; gives the name of the species; the name value MUST be unique in the :property: species list; chemical_symbols : REQUIRED; MUST be a list of strings of all chemical elements composing this species. It MUST be one of the following: a valid chemical-element name, or the special value :val: \"X\" to represent a non-chemical element, or the special value :val: \"vacancy\" to represent that this site has a non-zero probability of having a vacancy (the respective probability is indicated in the :property: concentration list, see below). If any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element, the correct flag MUST be set in the list :property: structure_features (see property structure_features _). concentration : REQUIRED; MUST be a list of floats, with same length as :property: chemical_symbols . The numbers represent the relative concentration of the corresponding chemical symbol in this species. The numbers SHOULD sum to one. Cases in which the numbers do not sum to one typically fall only in the following two categories: Numerical errors when representing float numbers in fixed precision, e.g. for two chemical symbols with concentrations :val: 1/3 and :val: 2/3 , the concentration might look something like :val: [0.33333333333, 0.66666666666] . If the client is aware that the sum is not one because of numerical precision, it can renormalize the values so that the sum is exactly one. Experimental errors in the data present in the database. In this case, it is the responsibility of the client to decide how to process the data. Note that concentrations are uncorrelated between different site (even of the same species). mass : OPTIONAL. If present MUST be a float expressed in a.m.u. original_name : OPTIONAL. Can be any valid Unicode string, and SHOULD contain (if specified) the name of the species that is used internally in the source database. With regards to \"source database\", we refer to the immediate source being queried via the OPTIMADE API implementation. The main use of this field is for source databases that use species names, containing characters that are not allowed (see description of the list property species_at_sites _). For systems that have only species formed by a single chemical symbol, and that have at most one species per chemical symbol, SHOULD use the chemical symbol as species name (e.g., :val: \"Ti\" for titanium, :val: \"O\" for oxygen, etc.) However, note that this is OPTIONAL, and client implementations MUST NOT assume that the key corresponds to a chemical symbol, nor assume that if the species name is a valid chemical symbol, that it represents a species with that chemical symbol. This means that a species :val: {\"name\": \"C\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} is valid and represents a titanium species (and not a carbon species). It is NOT RECOMMENDED that a structure includes species that do not have at least one corresponding site. Examples : :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\"], \"concentration\": [1.0]} ] : any site with this species is occupied by a Ti atom. :val: [ {\"name\": \"Ti\", \"chemical_symbols\": [\"Ti\", \"vacancy\"], \"concentration\": [0.9, 0.1]} ] : any site with this species is occupied by a Ti atom with 90 % probability, and has a vacancy with 10 % probability. :val: [ {\"name\": \"BaCa\", \"chemical_symbols\": [\"vacancy\", \"Ba\", \"Ca\"], \"concentration\": [0.05, 0.45, 0.5], \"mass\": 88.5} ] : any site with this species is occupied by a Ba atom with 45 % probability, a Ca atom with 50 % probability, and by a vacancy with 5 % probability. The mass of this site is (on average) 88.5 a.m.u. :val: [ {\"name\": \"C12\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 12.0} ] : any site with this species is occupied by a carbon isotope with mass 12. :val: [ {\"name\": \"C13\", \"chemical_symbols\": [\"C\"], \"concentration\": [1.0], \"mass\": 13.0} ] : any site with this species is occupied by a carbon isotope with mass 13.","title":"species"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.species_at_sites","text":"Name of the species at each site (where values for sites are specified with the same order of the property cartesian_site_positions ). The properties of the species are found in the property species . - Type : list of strings. - Requirements/Conventions : Support : SHOULD be supported, i.e., SHOULD NOT be :val: null . Is REQUIRED in this implementation, i.e., MUST NOT be :val: null . Query : Support for queries on this property is OPTIONAL. If supported, filters MAY support only a subset of comparison operators. MUST have length equal to the number of sites in the structure (first dimension of the list property cartesian_site_positions _). Each species MUST have a unique name. Each species name mentioned in the :property: species_at_sites list MUST be described in the list property species _ (i.e. for each value in the :property: species_at_sites list there MUST exist exactly one dictionary in the :property: species list with the :property: name attribute equal to the corresponding :property: species_at_sites value). Each site MUST be associated only to a single species. Note : However, species can represent mixtures of atoms, and multiple species MAY be defined for the same chemical element. This latter case is useful when different atoms of the same type need to be grouped or distinguished, for instance in simulation codes to assign different initial spin states. Examples : :val: [\"Ti\",\"O2\"] indicates that the first site is hosting a species labeled :val: \"Ti\" and the second a species labeled :val: \"O2\" .","title":"species_at_sites"},{"location":"reference/models/structures/#optimade.models.structures.StructureResourceAttributes.structure_features","text":"A list of strings that flag which special features are used by the structure. - Type : list of strings - Requirements/Conventions : Support : REQUIRED, MUST NOT be :val: null . Query : MUST be a queryable property. Filters on the list MUST support all mandatory HAS-type queries. Filter operators for comparisons on the string components MUST support equality, support for other comparison operators are OPTIONAL. MUST be an empty list if no special features are used. MUST be sorted alphabetically. If a special feature listed below is used, the list MUST contain the corresponding string. If a special feature listed below is not used, the list MUST NOT contain the corresponding string. List of strings used to indicate special structure features : :val: disorder : This flag MUST be present if any one entry in the :property: species list has a :property: chemical_symbols list that is longer than 1 element. :val: unknown_positions : This flag MUST be present if at least one component of the :property: cartesian_site_positions list of lists has value :val: null . :val: assemblies : This flag MUST be present if the property assemblies _ is present. Examples : A structure having unknown positions and using assemblies: :val: [\"assemblies\", \"unknown_positions\"]","title":"structure_features"},{"location":"reference/models/utils/","text":"","title":"Utils"},{"location":"reference/server/config/","text":"NoFallback ( Exception ) \u00b6 No fallback value can be found. ServerConfig ( BaseSettings ) pydantic-model \u00b6 This class stores server config parameters in a way that can be easily extended for new config file types. aliases : Dict [ Literal [ 'links' , 'references' , 'structures' ], Dict [ str , str ]] pydantic-field \u00b6 A mapping between field names in the database with their corresponding OPTIMADE field names, broken down by endpoint. base_url : str pydantic-field \u00b6 Base URL for this implementation config_file : str pydantic-field \u00b6 File to load alternative defaults from debug : bool pydantic-field \u00b6 Turns on Debug Mode for the OPTIMADE Server implementation default_db : str pydantic-field \u00b6 ID of /links endpoint resource for the chosen default OPTIMADE implementation (only relevant for the index meta-database) implementation : Implementation pydantic-field \u00b6 Introspective information about this OPTIMADE implementation index_links_path : Path pydantic-field \u00b6 Absolute path to a JSON file containing the MongoDB collection of /links resources for the index meta-database length_aliases : Dict [ Literal [ 'links' , 'references' , 'structures' ], Dict [ str , str ]] pydantic-field \u00b6 A mapping between a list property (or otherwise) and an integer property that defines the length of that list, for example elements -> nelements. The standard aliases are applied first, so this dictionary must refer to the API fields, not the database fields. links_collection : str pydantic-field \u00b6 Mongo collection name for /links endpoint resources mongo_database : str pydantic-field \u00b6 Mongo database for collection data mongo_uri : str pydantic-field \u00b6 URI for the Mongo server page_limit : int pydantic-field \u00b6 Default number of resources per page page_limit_max : int pydantic-field \u00b6 Max allowed number of resources per page provider : Provider pydantic-field \u00b6 General information about the provider of this OPTIMADE implementation provider_fields : Dict [ Literal [ 'links' , 'references' , 'structures' ], List [ str ]] pydantic-field \u00b6 A list of additional fields to be served with the provider's prefix attached, broken down by endpoint. references_collection : str pydantic-field \u00b6 Mongo collection name for /references endpoint resources structures_collection : str pydantic-field \u00b6 Mongo collection name for /structures endpoint resources use_real_mongo : bool pydantic-field \u00b6 Use a real Mongo server rather than MongoMock load_default_settings ( values ) classmethod \u00b6 Loads settings from a root file if available and uses that as defaults in place of built in defaults Source code in optimade/server/config.py @root_validator ( pre = True ) def load_default_settings ( cls , values ): # pylint: disable=no-self-argument \"\"\" Loads settings from a root file if available and uses that as defaults in place of built in defaults \"\"\" config_file_path = Path ( values . get ( \"config_file\" , DEFAULT_CONFIG_FILE_PATH )) new_values = {} if config_file_path . exists () and config_file_path . is_file (): logger . debug ( \"Found config file at: %s \" , config_file_path ) with open ( config_file_path ) as f : new_values = json . load ( f ) else : logger . debug ( # pragma: no cover \"Did not find config file at: %s \" , config_file_path ) new_values . update ( values ) return new_values","title":"Config"},{"location":"reference/server/config/#optimade.server.config.NoFallback","text":"No fallback value can be found.","title":"NoFallback"},{"location":"reference/server/config/#optimade.server.config.ServerConfig","text":"This class stores server config parameters in a way that can be easily extended for new config file types.","title":"ServerConfig"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.aliases","text":"A mapping between field names in the database with their corresponding OPTIMADE field names, broken down by endpoint.","title":"aliases"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.base_url","text":"Base URL for this implementation","title":"base_url"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.config_file","text":"File to load alternative defaults from","title":"config_file"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.debug","text":"Turns on Debug Mode for the OPTIMADE Server implementation","title":"debug"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.default_db","text":"ID of /links endpoint resource for the chosen default OPTIMADE implementation (only relevant for the index meta-database)","title":"default_db"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.implementation","text":"Introspective information about this OPTIMADE implementation","title":"implementation"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.index_links_path","text":"Absolute path to a JSON file containing the MongoDB collection of /links resources for the index meta-database","title":"index_links_path"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.length_aliases","text":"A mapping between a list property (or otherwise) and an integer property that defines the length of that list, for example elements -> nelements. The standard aliases are applied first, so this dictionary must refer to the API fields, not the database fields.","title":"length_aliases"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.links_collection","text":"Mongo collection name for /links endpoint resources","title":"links_collection"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.mongo_database","text":"Mongo database for collection data","title":"mongo_database"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.mongo_uri","text":"URI for the Mongo server","title":"mongo_uri"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.page_limit","text":"Default number of resources per page","title":"page_limit"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.page_limit_max","text":"Max allowed number of resources per page","title":"page_limit_max"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.provider","text":"General information about the provider of this OPTIMADE implementation","title":"provider"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.provider_fields","text":"A list of additional fields to be served with the provider's prefix attached, broken down by endpoint.","title":"provider_fields"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.references_collection","text":"Mongo collection name for /references endpoint resources","title":"references_collection"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.structures_collection","text":"Mongo collection name for /structures endpoint resources","title":"structures_collection"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.use_real_mongo","text":"Use a real Mongo server rather than MongoMock","title":"use_real_mongo"},{"location":"reference/server/config/#optimade.server.config.ServerConfig.load_default_settings","text":"Loads settings from a root file if available and uses that as defaults in place of built in defaults Source code in optimade/server/config.py @root_validator ( pre = True ) def load_default_settings ( cls , values ): # pylint: disable=no-self-argument \"\"\" Loads settings from a root file if available and uses that as defaults in place of built in defaults \"\"\" config_file_path = Path ( values . get ( \"config_file\" , DEFAULT_CONFIG_FILE_PATH )) new_values = {} if config_file_path . exists () and config_file_path . is_file (): logger . debug ( \"Found config file at: %s \" , config_file_path ) with open ( config_file_path ) as f : new_values = json . load ( f ) else : logger . debug ( # pragma: no cover \"Did not find config file at: %s \" , config_file_path ) new_values . update ( values ) return new_values","title":"load_default_settings()"},{"location":"reference/server/exception_handlers/","text":"","title":"Exception handlers"},{"location":"reference/server/exceptions/","text":"BadRequest ( HTTPException ) \u00b6 400 Bad Request","title":"Exceptions"},{"location":"reference/server/exceptions/#optimade.server.exceptions.BadRequest","text":"400 Bad Request","title":"BadRequest"},{"location":"reference/server/main/","text":"add_optional_versioned_base_urls ( app ) \u00b6 Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): app . include_router ( info . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( links . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( references . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( structures . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( landing . router , prefix = BASE_URL_PREFIXES [ version ])","title":"Main"},{"location":"reference/server/main/#optimade.server.main.add_optional_versioned_base_urls","text":"Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): app . include_router ( info . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( links . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( references . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( structures . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( landing . router , prefix = BASE_URL_PREFIXES [ version ])","title":"add_optional_versioned_base_urls()"},{"location":"reference/server/main_index/","text":"add_optional_versioned_base_urls ( app ) \u00b6 Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main_index.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): app . include_router ( index_info . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( links . router , prefix = BASE_URL_PREFIXES [ version ])","title":"Main index"},{"location":"reference/server/main_index/#optimade.server.main_index.add_optional_versioned_base_urls","text":"Add the following OPTIONAL prefixes/base URLs to server: /vMajor.Minor /vMajor.Minor.Patch Source code in optimade/server/main_index.py def add_optional_versioned_base_urls ( app : FastAPI ): \"\"\"Add the following OPTIONAL prefixes/base URLs to server: ``` /vMajor.Minor /vMajor.Minor.Patch ``` \"\"\" for version in ( \"minor\" , \"patch\" ): app . include_router ( index_info . router , prefix = BASE_URL_PREFIXES [ version ]) app . include_router ( links . router , prefix = BASE_URL_PREFIXES [ version ])","title":"add_optional_versioned_base_urls()"},{"location":"reference/server/middleware/","text":"EnsureQueryParamIntegrity ( BaseHTTPMiddleware ) \u00b6 Ensure all query parameters are followed by an equal sign ( = ) check_url ( url_query ) staticmethod \u00b6 Check parsed URL query part for parameters not followed by = Source code in optimade/server/middleware.py @staticmethod def check_url ( url_query : str ): \"\"\"Check parsed URL query part for parameters not followed by `=`\"\"\" queries_amp = set ( url_query . split ( \"&\" )) queries = set () for query in queries_amp : queries . update ( set ( query . split ( \";\" ))) for query in queries : if \"=\" not in query and query != \"\" : raise BadRequest ( detail = \"A query parameter without an equal sign (=) is not supported by this server\" ) return queries # Useful for testing","title":"Middleware"},{"location":"reference/server/middleware/#optimade.server.middleware.EnsureQueryParamIntegrity","text":"Ensure all query parameters are followed by an equal sign ( = )","title":"EnsureQueryParamIntegrity"},{"location":"reference/server/middleware/#optimade.server.middleware.EnsureQueryParamIntegrity.check_url","text":"Check parsed URL query part for parameters not followed by = Source code in optimade/server/middleware.py @staticmethod def check_url ( url_query : str ): \"\"\"Check parsed URL query part for parameters not followed by `=`\"\"\" queries_amp = set ( url_query . split ( \"&\" )) queries = set () for query in queries_amp : queries . update ( set ( query . split ( \";\" ))) for query in queries : if \"=\" not in query and query != \"\" : raise BadRequest ( detail = \"A query parameter without an equal sign (=) is not supported by this server\" ) return queries # Useful for testing","title":"check_url()"},{"location":"reference/server/query_params/","text":"EntryListingQueryParams \u00b6 Common query params for all Entry listing endpoints. SingleEntryQueryParams \u00b6 Common query params for single entry endpoints.","title":"Query params"},{"location":"reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams","text":"Common query params for all Entry listing endpoints.","title":"EntryListingQueryParams"},{"location":"reference/server/query_params/#optimade.server.query_params.SingleEntryQueryParams","text":"Common query params for single entry endpoints.","title":"SingleEntryQueryParams"},{"location":"reference/server/entry_collections/entry_collections/","text":"EntryCollection ( Collection , Generic ) \u00b6 find ( self , params ) \u00b6 Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit. Parameters: Name Type Description Default params EntryListingQueryParams entry listing URL query params required Returns: Type Description Tuple[List[Entry], int, bool, set] (results, data_returned, more_data_available, fields) Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def find ( self , params : EntryListingQueryParams ) -> Tuple [ List [ EntryResource ], int , bool , set ]: \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit. Args: params (EntryListingQueryParams): entry listing URL query params Returns: Tuple[List[Entry], int, bool, set]: (results, data_returned, more_data_available, fields) \"\"\"","title":"Entry collections"},{"location":"reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection","text":"","title":"EntryCollection"},{"location":"reference/server/entry_collections/entry_collections/#optimade.server.entry_collections.entry_collections.EntryCollection.find","text":"Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit. Parameters: Name Type Description Default params EntryListingQueryParams entry listing URL query params required Returns: Type Description Tuple[List[Entry], int, bool, set] (results, data_returned, more_data_available, fields) Source code in optimade/server/entry_collections/entry_collections.py @abstractmethod def find ( self , params : EntryListingQueryParams ) -> Tuple [ List [ EntryResource ], int , bool , set ]: \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit. Args: params (EntryListingQueryParams): entry listing URL query params Returns: Tuple[List[Entry], int, bool, set]: (results, data_returned, more_data_available, fields) \"\"\"","title":"find()"},{"location":"reference/server/entry_collections/mongo/","text":"MongoCollection ( EntryCollection ) \u00b6 find ( self , params ) \u00b6 Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit. Parameters: Name Type Description Default params EntryListingQueryParams entry listing URL query params required Returns: Type Description Tuple[List[Entry], int, bool, set] (results, data_returned, more_data_available, fields) Source code in optimade/server/entry_collections/mongo.py def find ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> Tuple [ List [ EntryResource ], int , bool , set ]: criteria = self . _parse_params ( params ) all_fields = criteria . pop ( \"fields\" ) if getattr ( params , \"response_fields\" , False ): fields = set ( params . response_fields . split ( \",\" )) fields |= self . resource_mapper . get_required_fields () else : fields = all_fields . copy () results = [] for doc in self . collection . find ( ** criteria ): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( doc ))) nresults_now = len ( results ) if isinstance ( params , EntryListingQueryParams ): criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) data_returned = self . count ( ** criteria_nolimit ) more_data_available = nresults_now < data_returned else : # SingleEntryQueryParams, e.g., /structures/{entry_id} data_returned = nresults_now more_data_available = False if nresults_now > 1 : raise HTTPException ( status_code = 404 , detail = f \"Instead of a single entry, { nresults_now } entries were found\" , ) results = results [ 0 ] if results else None return results , data_returned , more_data_available , all_fields - fields","title":"Mongo"},{"location":"reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection","text":"","title":"MongoCollection"},{"location":"reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection.find","text":"Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit. Parameters: Name Type Description Default params EntryListingQueryParams entry listing URL query params required Returns: Type Description Tuple[List[Entry], int, bool, set] (results, data_returned, more_data_available, fields) Source code in optimade/server/entry_collections/mongo.py def find ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> Tuple [ List [ EntryResource ], int , bool , set ]: criteria = self . _parse_params ( params ) all_fields = criteria . pop ( \"fields\" ) if getattr ( params , \"response_fields\" , False ): fields = set ( params . response_fields . split ( \",\" )) fields |= self . resource_mapper . get_required_fields () else : fields = all_fields . copy () results = [] for doc in self . collection . find ( ** criteria ): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( doc ))) nresults_now = len ( results ) if isinstance ( params , EntryListingQueryParams ): criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) data_returned = self . count ( ** criteria_nolimit ) more_data_available = nresults_now < data_returned else : # SingleEntryQueryParams, e.g., /structures/{entry_id} data_returned = nresults_now more_data_available = False if nresults_now > 1 : raise HTTPException ( status_code = 404 , detail = f \"Instead of a single entry, { nresults_now } entries were found\" , ) results = results [ 0 ] if results else None return results , data_returned , more_data_available , all_fields - fields","title":"find()"},{"location":"reference/server/mappers/entries/","text":"BaseResourceMapper \u00b6 Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Attributes: Name Type Description ENDPOINT str defines the endpoint for which to apply this mapper. ALIASES Tuple[Tuple[str, str]] a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. ((\"elements\", \"custom_elements_field\")) . LENGTH_ALIASES Tuple[Tuple[str, str]] a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. ((\"elements\", \"nelements\")) . e.g. ((\"elements\", \"custom_elements_field\")) . PROVIDER_FIELDS Tuple[str] a tuple of extra field names that this mapper should support when querying with the database prefix. REQUIRED_FIELDS set[str] the set of fieldnames to return when mapping to the OPTIMADE format. TOP_LEVEL_NON_ATTRIBUTES_FIELDS set[str] the set of top-level field names common to all endpoints. alias_for ( field ) classmethod \u00b6 Return aliased field name. :param field: OPTIMADE field name :type field: str :return: Aliased field as found in PROVIDER_ALIASES + ALIASES :rtype: str Source code in optimade/server/mappers/entries.py @classmethod def alias_for ( cls , field : str ) -> str : \"\"\"Return aliased field name. :param field: OPTIMADE field name :type field: str :return: Aliased field as found in PROVIDER_ALIASES + ALIASES :rtype: str \"\"\" split = field . split ( \".\" ) alias = dict ( cls . all_aliases ()) . get ( split [ 0 ], None ) if alias is not None : return alias + ( \".\" + \".\" . join ( split [ 1 :]) if len ( split ) > 1 else \"\" ) return field all_aliases () classmethod \u00b6 Returns all of the associated aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] a tuple of alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\" Returns all of the associated aliases for this class, including those defined by the server config. Returns: Tuple[Tuple[str, str]]: a tuple of alias tuples. \"\"\" return ( tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in CONFIG . provider_fields . get ( cls . ENDPOINT , []) ) + tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in cls . PROVIDER_FIELDS ) + tuple ( CONFIG . aliases . get ( cls . ENDPOINT , {}) . items ()) + cls . ALIASES ) all_length_aliases () classmethod \u00b6 Returns all of the associated length aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] a tuple of length alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_length_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\" Returns all of the associated length aliases for this class, including those defined by the server config. Returns: Tuple[Tuple[str, str]]: a tuple of length alias tuples. \"\"\" return cls . LENGTH_ALIASES + tuple ( CONFIG . length_aliases . get ( cls . ENDPOINT , {}) . items () ) get_required_fields () classmethod \u00b6 Return set REQUIRED response fields Source code in optimade/server/mappers/entries.py @classmethod def get_required_fields ( cls ) -> set : \"\"\"Return set REQUIRED response fields\"\"\" res = cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS . copy () res . update ( cls . REQUIRED_FIELDS ) return res length_alias_for ( field ) classmethod \u00b6 Returns the length alias for the particular field, or None if no such alias is found. Source code in optimade/server/mappers/entries.py @classmethod def length_alias_for ( cls , field : str ) -> str : \"\"\" Returns the length alias for the particular field, or `None` if no such alias is found. \"\"\" return dict ( cls . all_length_aliases ()) . get ( field , None ) map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade/server/mappers/entries.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE Starting from a MongoDB document ``doc``, map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in ``cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS``. All fields not in ``cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS`` + \"attributes\" will be removed. Finally, the ``type`` is given the value of the specified ``cls.ENDPOINT``. :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict \"\"\" if \"_id\" in doc : del doc [ \"_id\" ] mapping = (( real , alias ) for alias , real in cls . all_aliases ()) newdoc = {} reals = { real for alias , real in cls . all_aliases ()} for key in doc : if key not in reals : newdoc [ key ] = doc [ key ] for real , alias in mapping : if real in doc : newdoc [ alias ] = doc [ real ] if \"attributes\" in newdoc : raise Exception ( \"Will overwrite doc field!\" ) attributes = newdoc . copy () for field in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : value = attributes . pop ( field , None ) if value is not None : newdoc [ field ] = value for field in list ( newdoc . keys ()): if field not in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : del newdoc [ field ] newdoc [ \"type\" ] = cls . ENDPOINT newdoc [ \"attributes\" ] = attributes return newdoc","title":"Entries"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper","text":"Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Attributes: Name Type Description ENDPOINT str defines the endpoint for which to apply this mapper. ALIASES Tuple[Tuple[str, str]] a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. ((\"elements\", \"custom_elements_field\")) . LENGTH_ALIASES Tuple[Tuple[str, str]] a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. ((\"elements\", \"nelements\")) . e.g. ((\"elements\", \"custom_elements_field\")) . PROVIDER_FIELDS Tuple[str] a tuple of extra field names that this mapper should support when querying with the database prefix. REQUIRED_FIELDS set[str] the set of fieldnames to return when mapping to the OPTIMADE format. TOP_LEVEL_NON_ATTRIBUTES_FIELDS set[str] the set of top-level field names common to all endpoints.","title":"BaseResourceMapper"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.alias_for","text":"Return aliased field name. :param field: OPTIMADE field name :type field: str :return: Aliased field as found in PROVIDER_ALIASES + ALIASES :rtype: str Source code in optimade/server/mappers/entries.py @classmethod def alias_for ( cls , field : str ) -> str : \"\"\"Return aliased field name. :param field: OPTIMADE field name :type field: str :return: Aliased field as found in PROVIDER_ALIASES + ALIASES :rtype: str \"\"\" split = field . split ( \".\" ) alias = dict ( cls . all_aliases ()) . get ( split [ 0 ], None ) if alias is not None : return alias + ( \".\" + \".\" . join ( split [ 1 :]) if len ( split ) > 1 else \"\" ) return field","title":"alias_for()"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.all_aliases","text":"Returns all of the associated aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] a tuple of alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\" Returns all of the associated aliases for this class, including those defined by the server config. Returns: Tuple[Tuple[str, str]]: a tuple of alias tuples. \"\"\" return ( tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in CONFIG . provider_fields . get ( cls . ENDPOINT , []) ) + tuple ( ( f \"_ { CONFIG . provider . prefix } _ { field } \" , field ) for field in cls . PROVIDER_FIELDS ) + tuple ( CONFIG . aliases . get ( cls . ENDPOINT , {}) . items ()) + cls . ALIASES )","title":"all_aliases()"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.all_length_aliases","text":"Returns all of the associated length aliases for this class, including those defined by the server config. Returns: Type Description Tuple[Tuple[str, str]] a tuple of length alias tuples. Source code in optimade/server/mappers/entries.py @classmethod def all_length_aliases ( cls ) -> Tuple [ Tuple [ str , str ]]: \"\"\" Returns all of the associated length aliases for this class, including those defined by the server config. Returns: Tuple[Tuple[str, str]]: a tuple of length alias tuples. \"\"\" return cls . LENGTH_ALIASES + tuple ( CONFIG . length_aliases . get ( cls . ENDPOINT , {}) . items () )","title":"all_length_aliases()"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.get_required_fields","text":"Return set REQUIRED response fields Source code in optimade/server/mappers/entries.py @classmethod def get_required_fields ( cls ) -> set : \"\"\"Return set REQUIRED response fields\"\"\" res = cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS . copy () res . update ( cls . REQUIRED_FIELDS ) return res","title":"get_required_fields()"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.length_alias_for","text":"Returns the length alias for the particular field, or None if no such alias is found. Source code in optimade/server/mappers/entries.py @classmethod def length_alias_for ( cls , field : str ) -> str : \"\"\" Returns the length alias for the particular field, or `None` if no such alias is found. \"\"\" return dict ( cls . all_length_aliases ()) . get ( field , None )","title":"length_alias_for()"},{"location":"reference/server/mappers/entries/#optimade.server.mappers.entries.BaseResourceMapper.map_back","text":"Map properties from MongoDB to OPTIMADE Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade/server/mappers/entries.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE Starting from a MongoDB document ``doc``, map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in ``cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS``. All fields not in ``cls.TOPLEVEL_NON_ATTRIBUTES_FIELDS`` + \"attributes\" will be removed. Finally, the ``type`` is given the value of the specified ``cls.ENDPOINT``. :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict \"\"\" if \"_id\" in doc : del doc [ \"_id\" ] mapping = (( real , alias ) for alias , real in cls . all_aliases ()) newdoc = {} reals = { real for alias , real in cls . all_aliases ()} for key in doc : if key not in reals : newdoc [ key ] = doc [ key ] for real , alias in mapping : if real in doc : newdoc [ alias ] = doc [ real ] if \"attributes\" in newdoc : raise Exception ( \"Will overwrite doc field!\" ) attributes = newdoc . copy () for field in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : value = attributes . pop ( field , None ) if value is not None : newdoc [ field ] = value for field in list ( newdoc . keys ()): if field not in cls . TOP_LEVEL_NON_ATTRIBUTES_FIELDS : del newdoc [ field ] newdoc [ \"type\" ] = cls . ENDPOINT newdoc [ \"attributes\" ] = attributes return newdoc","title":"map_back()"},{"location":"reference/server/mappers/links/","text":"LinksMapper ( BaseResourceMapper ) \u00b6 map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade/server/mappers/links.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict \"\"\" type_ = doc [ \"type\" ] newdoc = super () . map_back ( doc ) newdoc [ \"type\" ] = type_ return newdoc","title":"Links"},{"location":"reference/server/mappers/links/#optimade.server.mappers.links.LinksMapper","text":"","title":"LinksMapper"},{"location":"reference/server/mappers/links/#optimade.server.mappers.links.LinksMapper.map_back","text":"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade/server/mappers/links.py @classmethod def map_back ( cls , doc : dict ) -> dict : \"\"\"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict \"\"\" type_ = doc [ \"type\" ] newdoc = super () . map_back ( doc ) newdoc [ \"type\" ] = type_ return newdoc","title":"map_back()"},{"location":"reference/server/mappers/references/","text":"","title":"References"},{"location":"reference/server/mappers/structures/","text":"","title":"Structures"},{"location":"reference/server/routers/index_info/","text":"","title":"Index info"},{"location":"reference/server/routers/info/","text":"","title":"Info"},{"location":"reference/server/routers/landing/","text":"OPTIMADE landing page, rendered as a Jinja2 template. landing ( request ) async \u00b6 Show a human-readable landing page when the base URL is accessed. Source code in optimade/server/routers/landing.py async def landing ( request ): \"\"\" Show a human-readable landing page when the base URL is accessed. \"\"\" meta = meta_values ( str ( request . url ), 1 , 1 , more_data_available = False ) major_version = __api_version__ . split ( \".\" )[ 0 ] versioned_url = ( f \" { request . url } \" if f \"v { major_version } \" in f \" { request . url . path } \" else f \" { request . url } v { major_version } /\" ) context = { \"request\" : request , \"request_url\" : request . url , \"api_version\" : __api_version__ , \"implementation\" : meta . implementation , \"versioned_url\" : versioned_url , \"provider\" : meta . provider , \"endpoints\" : list ( ENTRY_COLLECTIONS . keys ()) + [ \"info\" ], } return TEMPLATES . TemplateResponse ( \"landing_page.html\" , context )","title":"Landing"},{"location":"reference/server/routers/landing/#optimade.server.routers.landing.landing","text":"Show a human-readable landing page when the base URL is accessed. Source code in optimade/server/routers/landing.py async def landing ( request ): \"\"\" Show a human-readable landing page when the base URL is accessed. \"\"\" meta = meta_values ( str ( request . url ), 1 , 1 , more_data_available = False ) major_version = __api_version__ . split ( \".\" )[ 0 ] versioned_url = ( f \" { request . url } \" if f \"v { major_version } \" in f \" { request . url . path } \" else f \" { request . url } v { major_version } /\" ) context = { \"request\" : request , \"request_url\" : request . url , \"api_version\" : __api_version__ , \"implementation\" : meta . implementation , \"versioned_url\" : versioned_url , \"provider\" : meta . provider , \"endpoints\" : list ( ENTRY_COLLECTIONS . keys ()) + [ \"info\" ], } return TEMPLATES . TemplateResponse ( \"landing_page.html\" , context )","title":"landing()"},{"location":"reference/server/routers/links/","text":"","title":"Links"},{"location":"reference/server/routers/references/","text":"","title":"References"},{"location":"reference/server/routers/structures/","text":"","title":"Structures"},{"location":"reference/server/routers/utils/","text":"get_base_url ( parsed_url_request ) \u00b6 Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. Source code in optimade/server/routers/utils.py def get_base_url ( parsed_url_request : urllib . parse . ParseResult ) -> str : \"\"\"Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. \"\"\" return ( CONFIG . base_url if CONFIG . base_url else f \" { parsed_url_request . scheme } :// { parsed_url_request . netloc } \" ) get_entries ( collection , response , request , params ) \u00b6 Generalized /{entry} endpoint getter Source code in optimade/server/routers/utils.py def get_entries ( collection : EntryCollection , response : EntryResponseMany , request : Request , params : EntryListingQueryParams , ) -> EntryResponseMany : \"\"\"Generalized /{entry} endpoint getter\"\"\" from optimade.server.routers import ENTRY_COLLECTIONS results , data_returned , more_data_available , fields = collection . find ( params ) include = [] if getattr ( params , \"include\" , False ): include . extend ( params . include . split ( \",\" )) included = get_included_relationships ( results , ENTRY_COLLECTIONS , include ) if more_data_available : # Deduce the `next` link from the current request parse_result = urllib . parse . urlparse ( str ( request . url )) query = urllib . parse . parse_qs ( parse_result . query ) query [ \"page_offset\" ] = int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results ) urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( parse_result ) links = ToplevelLinks ( next = f \" { base_url }{ parse_result . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields : results = handle_response_fields ( results , fields ) return response ( links = links , data = results , meta = meta_values ( url = str ( request . url ), data_returned = data_returned , data_available = len ( collection ), more_data_available = more_data_available , ), included = included , ) get_included_relationships ( results , ENTRY_COLLECTIONS , include_param ) \u00b6 Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: Name Type Description Default results Union[optimade.models.entries.EntryResource, List[optimade.models.entries.EntryResource]] list of returned documents. required ENTRY_COLLECTIONS Dict[str, optimade.server.entry_collections.entry_collections.EntryCollection] dictionary containing collections to query, with key based on endpoint type. required include_param List[str] list of queried related resources that should be included in included . required Returns: Type Description Dict[str, List[optimade.models.entries.EntryResource]] Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. Source code in optimade/server/routers/utils.py def get_included_relationships ( results : Union [ EntryResource , List [ EntryResource ]], ENTRY_COLLECTIONS : Dict [ str , EntryCollection ], include_param : List [ str ], ) -> Dict [ str , List [ EntryResource ]]: \"\"\"Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: results: list of returned documents. ENTRY_COLLECTIONS: dictionary containing collections to query, with key based on endpoint type. include_param: list of queried related resources that should be included in `included`. Returns: Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. \"\"\" from collections import defaultdict if not isinstance ( results , list ): results = [ results ] for entry_type in include_param : if entry_type not in ENTRY_COLLECTIONS and entry_type != \"\" : raise BadRequest ( detail = f \"' { entry_type } ' cannot be identified as a valid relationship type. \" f \"Known relationship types: { sorted ( ENTRY_COLLECTIONS . keys ()) } \" ) endpoint_includes = defaultdict ( dict ) for doc in results : # convert list of references into dict by ID to only included unique IDs if doc is None : continue relationships = doc . relationships if relationships is None : continue relationships = relationships . dict () for entry_type in ENTRY_COLLECTIONS : # Skip entry type if it is not in `include_param` if entry_type not in include_param : continue entry_relationship = relationships . get ( entry_type , {}) if entry_relationship is not None : refs = entry_relationship . get ( \"data\" , []) for ref in refs : # could check here and raise a warning if any IDs clash endpoint_includes [ entry_type ][ ref [ \"id\" ]] = ref included = {} for entry_type in endpoint_includes : compound_filter = \" OR \" . join ( [ 'id=\" {} \"' . format ( ref_id ) for ref_id in endpoint_includes [ entry_type ]] ) params = EntryListingQueryParams ( filter = compound_filter , response_format = \"json\" , response_fields = None , sort = None , page_limit = 0 , page_offset = 0 , ) # still need to handle pagination ref_results , _ , _ , _ = ENTRY_COLLECTIONS [ entry_type ] . find ( params ) included [ entry_type ] = ref_results # flatten dict by endpoint to list return [ obj for endp in included . values () for obj in endp ] get_providers () \u00b6 Retrieve Materials-Consortia providers (from https://providers.optimade.org/providers.json) Source code in optimade/server/routers/utils.py def get_providers (): \"\"\"Retrieve Materials-Consortia providers (from https://providers.optimade.org/providers.json)\"\"\" import requests mat_consortia_providers = requests . get ( \"https://providers.optimade.org/providers.json\" ) . json () providers_list = [] for provider in mat_consortia_providers . get ( \"data\" , []): # Remove/skip \"exmpl\" if provider [ \"id\" ] == \"exmpl\" : continue provider . update ( provider . pop ( \"attributes\" )) # Add MongoDB ObjectId provider [ \"_id\" ] = { \"$oid\" : mongo_id_for_database ( provider [ \"id\" ], provider [ \"type\" ]) } providers_list . append ( provider ) return providers_list handle_response_fields ( results , exclude_fields ) \u00b6 Handle query parameter response_fields It is assumed that all fields are under attributes . This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under attributes to be excluded from the response. Source code in optimade/server/routers/utils.py def handle_response_fields ( results : Union [ List [ EntryResource ], EntryResource ], exclude_fields : set ) -> dict : \"\"\"Handle query parameter ``response_fields`` It is assumed that all fields are under ``attributes``. This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under ``attributes`` to be excluded from the response. \"\"\" if not isinstance ( results , list ): results = [ results ] new_results = [] while results : entry = results . pop ( 0 ) new_entry = entry . dict ( exclude_unset = True ) for field in exclude_fields : if field in new_entry [ \"attributes\" ]: del new_entry [ \"attributes\" ][ field ] new_results . append ( new_entry ) return new_results meta_values ( url , data_returned , data_available , more_data_available , ** kwargs ) \u00b6 Helper to initialize the meta values Source code in optimade/server/routers/utils.py def meta_values ( url : str , data_returned : int , data_available : int , more_data_available : bool , ** kwargs , ) -> ResponseMeta : \"\"\"Helper to initialize the meta values\"\"\" from optimade.models import ResponseMetaQuery parse_result = urllib . parse . urlparse ( url ) # To catch all (valid) variations of the version part of the URL, a regex is used if re . match ( r \"/v[0-9]+(\\.[0-9]+){,2}/.*\" , parse_result . path ) is not None : url_path = re . sub ( r \"/v[0-9]+(\\.[0-9]+){,2}/\" , \"/\" , parse_result . path ) else : url_path = parse_result . path return ResponseMeta ( query = ResponseMetaQuery ( representation = f \" { url_path } ? { parse_result . query } \" ), api_version = f \"v { __api_version__ } \" , time_stamp = datetime . now (), data_returned = data_returned , more_data_available = more_data_available , provider = CONFIG . provider , data_available = data_available , implementation = CONFIG . implementation , ** kwargs , ) mongo_id_for_database ( database_id , database_type ) \u00b6 Produce a MondoDB ObjectId for a database Source code in optimade/server/routers/utils.py def mongo_id_for_database ( database_id : str , database_type : str ) -> str : \"\"\"Produce a MondoDB ObjectId for a database\"\"\" from bson.objectid import ObjectId oid = f \" { database_id }{ database_type } \" if len ( oid ) > 12 : oid = oid [: 12 ] elif len ( oid ) < 12 : oid = f \" { oid }{ '0' * ( 12 - len ( oid )) } \" return str ( ObjectId ( oid . encode ( \"UTF-8\" )))","title":"Utils"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.get_base_url","text":"Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. Source code in optimade/server/routers/utils.py def get_base_url ( parsed_url_request : urllib . parse . ParseResult ) -> str : \"\"\"Get base URL for current server Take the base URL from the config file, if it exists, otherwise use the request. \"\"\" return ( CONFIG . base_url if CONFIG . base_url else f \" { parsed_url_request . scheme } :// { parsed_url_request . netloc } \" )","title":"get_base_url()"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.get_entries","text":"Generalized /{entry} endpoint getter Source code in optimade/server/routers/utils.py def get_entries ( collection : EntryCollection , response : EntryResponseMany , request : Request , params : EntryListingQueryParams , ) -> EntryResponseMany : \"\"\"Generalized /{entry} endpoint getter\"\"\" from optimade.server.routers import ENTRY_COLLECTIONS results , data_returned , more_data_available , fields = collection . find ( params ) include = [] if getattr ( params , \"include\" , False ): include . extend ( params . include . split ( \",\" )) included = get_included_relationships ( results , ENTRY_COLLECTIONS , include ) if more_data_available : # Deduce the `next` link from the current request parse_result = urllib . parse . urlparse ( str ( request . url )) query = urllib . parse . parse_qs ( parse_result . query ) query [ \"page_offset\" ] = int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results ) urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( parse_result ) links = ToplevelLinks ( next = f \" { base_url }{ parse_result . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields : results = handle_response_fields ( results , fields ) return response ( links = links , data = results , meta = meta_values ( url = str ( request . url ), data_returned = data_returned , data_available = len ( collection ), more_data_available = more_data_available , ), included = included , )","title":"get_entries()"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.get_included_relationships","text":"Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: Name Type Description Default results Union[optimade.models.entries.EntryResource, List[optimade.models.entries.EntryResource]] list of returned documents. required ENTRY_COLLECTIONS Dict[str, optimade.server.entry_collections.entry_collections.EntryCollection] dictionary containing collections to query, with key based on endpoint type. required include_param List[str] list of queried related resources that should be included in included . required Returns: Type Description Dict[str, List[optimade.models.entries.EntryResource]] Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. Source code in optimade/server/routers/utils.py def get_included_relationships ( results : Union [ EntryResource , List [ EntryResource ]], ENTRY_COLLECTIONS : Dict [ str , EntryCollection ], include_param : List [ str ], ) -> Dict [ str , List [ EntryResource ]]: \"\"\"Filters the included relationships and makes the appropriate compound request to include them in the response. Parameters: results: list of returned documents. ENTRY_COLLECTIONS: dictionary containing collections to query, with key based on endpoint type. include_param: list of queried related resources that should be included in `included`. Returns: Dictionary with the same keys as ENTRY_COLLECTIONS, each containing the list of resource objects for that entry type. \"\"\" from collections import defaultdict if not isinstance ( results , list ): results = [ results ] for entry_type in include_param : if entry_type not in ENTRY_COLLECTIONS and entry_type != \"\" : raise BadRequest ( detail = f \"' { entry_type } ' cannot be identified as a valid relationship type. \" f \"Known relationship types: { sorted ( ENTRY_COLLECTIONS . keys ()) } \" ) endpoint_includes = defaultdict ( dict ) for doc in results : # convert list of references into dict by ID to only included unique IDs if doc is None : continue relationships = doc . relationships if relationships is None : continue relationships = relationships . dict () for entry_type in ENTRY_COLLECTIONS : # Skip entry type if it is not in `include_param` if entry_type not in include_param : continue entry_relationship = relationships . get ( entry_type , {}) if entry_relationship is not None : refs = entry_relationship . get ( \"data\" , []) for ref in refs : # could check here and raise a warning if any IDs clash endpoint_includes [ entry_type ][ ref [ \"id\" ]] = ref included = {} for entry_type in endpoint_includes : compound_filter = \" OR \" . join ( [ 'id=\" {} \"' . format ( ref_id ) for ref_id in endpoint_includes [ entry_type ]] ) params = EntryListingQueryParams ( filter = compound_filter , response_format = \"json\" , response_fields = None , sort = None , page_limit = 0 , page_offset = 0 , ) # still need to handle pagination ref_results , _ , _ , _ = ENTRY_COLLECTIONS [ entry_type ] . find ( params ) included [ entry_type ] = ref_results # flatten dict by endpoint to list return [ obj for endp in included . values () for obj in endp ]","title":"get_included_relationships()"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.get_providers","text":"Retrieve Materials-Consortia providers (from https://providers.optimade.org/providers.json) Source code in optimade/server/routers/utils.py def get_providers (): \"\"\"Retrieve Materials-Consortia providers (from https://providers.optimade.org/providers.json)\"\"\" import requests mat_consortia_providers = requests . get ( \"https://providers.optimade.org/providers.json\" ) . json () providers_list = [] for provider in mat_consortia_providers . get ( \"data\" , []): # Remove/skip \"exmpl\" if provider [ \"id\" ] == \"exmpl\" : continue provider . update ( provider . pop ( \"attributes\" )) # Add MongoDB ObjectId provider [ \"_id\" ] = { \"$oid\" : mongo_id_for_database ( provider [ \"id\" ], provider [ \"type\" ]) } providers_list . append ( provider ) return providers_list","title":"get_providers()"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.handle_response_fields","text":"Handle query parameter response_fields It is assumed that all fields are under attributes . This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under attributes to be excluded from the response. Source code in optimade/server/routers/utils.py def handle_response_fields ( results : Union [ List [ EntryResource ], EntryResource ], exclude_fields : set ) -> dict : \"\"\"Handle query parameter ``response_fields`` It is assumed that all fields are under ``attributes``. This is due to all other top-level fields are REQUIRED in the response. :param exclude_fields: Fields under ``attributes`` to be excluded from the response. \"\"\" if not isinstance ( results , list ): results = [ results ] new_results = [] while results : entry = results . pop ( 0 ) new_entry = entry . dict ( exclude_unset = True ) for field in exclude_fields : if field in new_entry [ \"attributes\" ]: del new_entry [ \"attributes\" ][ field ] new_results . append ( new_entry ) return new_results","title":"handle_response_fields()"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.meta_values","text":"Helper to initialize the meta values Source code in optimade/server/routers/utils.py def meta_values ( url : str , data_returned : int , data_available : int , more_data_available : bool , ** kwargs , ) -> ResponseMeta : \"\"\"Helper to initialize the meta values\"\"\" from optimade.models import ResponseMetaQuery parse_result = urllib . parse . urlparse ( url ) # To catch all (valid) variations of the version part of the URL, a regex is used if re . match ( r \"/v[0-9]+(\\.[0-9]+){,2}/.*\" , parse_result . path ) is not None : url_path = re . sub ( r \"/v[0-9]+(\\.[0-9]+){,2}/\" , \"/\" , parse_result . path ) else : url_path = parse_result . path return ResponseMeta ( query = ResponseMetaQuery ( representation = f \" { url_path } ? { parse_result . query } \" ), api_version = f \"v { __api_version__ } \" , time_stamp = datetime . now (), data_returned = data_returned , more_data_available = more_data_available , provider = CONFIG . provider , data_available = data_available , implementation = CONFIG . implementation , ** kwargs , )","title":"meta_values()"},{"location":"reference/server/routers/utils/#optimade.server.routers.utils.mongo_id_for_database","text":"Produce a MondoDB ObjectId for a database Source code in optimade/server/routers/utils.py def mongo_id_for_database ( database_id : str , database_type : str ) -> str : \"\"\"Produce a MondoDB ObjectId for a database\"\"\" from bson.objectid import ObjectId oid = f \" { database_id }{ database_type } \" if len ( oid ) > 12 : oid = oid [: 12 ] elif len ( oid ) < 12 : oid = f \" { oid }{ '0' * ( 12 - len ( oid )) } \" return str ( ObjectId ( oid . encode ( \"UTF-8\" )))","title":"mongo_id_for_database()"},{"location":"reference/validator/validator/","text":"This module contains a validator class that can be pointed at an OPTIMADE implementation and validated against the pydantic models in this package. Client \u00b6 __init__ ( self , base_url , max_retries = 5 ) special \u00b6 Initialises the Client with the given base_url without testing if it is valid. Parameters: Name Type Description Default base_url str the base URL of the optimade implementation, including required request protocol (e.g. `'http //'`) and API version number if necessary. required Examples 'http://example.org/optimade/v1' , 'www.crystallography.net/cod-test/optimade/v0.10.0/' required Note A maximum of one slash (\"/\") is allowed as the last character. required Source code in optimade/validator/validator.py def __init__ ( self , base_url : str , max_retries = 5 ): \"\"\" Initialises the Client with the given `base_url` without testing if it is valid. Parameters: base_url (str): the base URL of the optimade implementation, including request protocol (e.g. `'http://'`) and API version number if necessary. Examples: - `'http://example.org/optimade/v1'`, - `'www.crystallography.net/cod-test/optimade/v0.10.0/'` Note: A maximum of one slash (\"/\") is allowed as the last character. \"\"\" self . base_url = base_url self . last_request = None self . response = None self . max_retries = max_retries get ( self , request ) \u00b6 Makes the given request, with a number of retries if being rate limited. The request will be prepended with the base_url unless the request appears to be an absolute URL (i.e. starts with http:// or https:// ). Parameters: Name Type Description Default request str the request to make against the base URL of this client. required Returns: Type Description response (requests.models.Response) the response from the server. Exceptions: Type Description SystemExit if there is no response from the server, or if the URL is invalid. ResponseError if the server does not respond with a non-429 status code within the MAX_RETRIES attempts. Source code in optimade/validator/validator.py def get ( self , request : str ): \"\"\" Makes the given request, with a number of retries if being rate limited. The request will be prepended with the `base_url` unless the request appears to be an absolute URL (i.e. starts with `http://` or `https://`). Parameters: request (str): the request to make against the base URL of this client. Returns: response (requests.models.Response): the response from the server. Raises: SystemExit: if there is no response from the server, or if the URL is invalid. ResponseError: if the server does not respond with a non-429 status code within the `MAX_RETRIES` attempts. \"\"\" if urllib . parse . urlparse ( request , allow_fragments = True ) . scheme : self . last_request = request else : if request and not request . startswith ( \"/\" ): request = f \"/ { request } \" self . last_request = f \" { self . base_url }{ request } \" status_code = None retries = 0 # probably a smarter way to do this with requests, but their documentation 404's... while retries < self . max_retries : retries += 1 try : self . response = requests . get ( self . last_request ) except requests . exceptions . ConnectionError : sys . exit ( f \"No response from server at { self . last_request } \" ) except requests . exceptions . MissingSchema : sys . exit ( f \"Unable to make request on { self . last_request } , did you mean http:// { self . last_request } ?\" ) status_code = self . response . status_code if status_code != 429 : break print ( \"Hit rate limit, sleeping for 1 s...\" ) time . sleep ( 1 ) else : raise ResponseError ( \"Hit max (manual) retries on request.\" ) return self . response ImplementationValidator \u00b6 Class to call test functions on a particular OPTIMADE implementation. Uses the pydantic models in optimade.models to validate the response from the server and crawl through the available endpoints. Drawbacks only works for current version of the specification as defined by optimade.models . __init__ ( self , client = None , base_url = None , verbosity = 0 , page_limit = 5 , max_retries = 5 , as_type = None , index = False ) special \u00b6 Set up the tests to run, based on constants in this module for required endpoints. Source code in optimade/validator/validator.py def __init__ ( # pylint: disable=too-many-arguments self , client : Union [ Client , TestClient ] = None , base_url : str = None , verbosity : int = 0 , page_limit : int = 5 , max_retries : int = 5 , as_type : str = None , index : bool = False , ): \"\"\" Set up the tests to run, based on constants in this module for required endpoints. \"\"\" self . verbosity = verbosity self . max_retries = max_retries self . page_limit = page_limit self . index = index if as_type is None : self . as_type_cls = None elif self . index : if as_type not in RESPONSE_CLASSES_INDEX . keys (): raise RuntimeError ( f \"Provided as_type=' { as_type } ' not allowed for an Index meta-database.\" ) self . as_type_cls = RESPONSE_CLASSES_INDEX [ as_type ] elif as_type in ( \"structure\" , \"reference\" ): self . as_type_cls = RESPONSE_CLASSES [ f \" { as_type } s/\" ] else : self . as_type_cls = RESPONSE_CLASSES [ as_type ] if client is None and base_url is None : raise RuntimeError ( \"Need at least a URL or a client to initialize validator.\" ) if base_url and client : raise RuntimeError ( \"Please specify at most one of base_url or client.\" ) if client : self . client = client self . base_url = self . client . base_url else : while base_url . endswith ( \"/\" ): base_url = base_url [: - 1 ] self . base_url = base_url self . client = Client ( base_url , max_retries = self . max_retries ) self . test_id_by_type = {} self . _setup_log () self . expected_entry_endpoints = ( REQUIRED_ENTRY_ENDPOINTS_INDEX if self . index else REQUIRED_ENTRY_ENDPOINTS ) self . test_entry_endpoints = set ( self . expected_entry_endpoints ) self . endpoint_mandatory_queries = ( {} if self . index else ENDPOINT_MANDATORY_QUERIES ) self . endpoint_optional_queries = {} if self . index else ENDPOINT_OPTIONAL_QUERIES self . response_classes = ( RESPONSE_CLASSES_INDEX if self . index else RESPONSE_CLASSES ) # some simple checks on base_url base_url = urllib . parse . urlparse ( self . base_url ) # only allow filters/endpoints if we are working in \"as_type\" mode if self . as_type_cls is None and ( base_url . query or any ( endp in base_url . path for endp in self . expected_entry_endpoints ) ): raise SystemExit ( \"Base URL not appropriate: should not contain an endpoint or filter.\" ) # if valid is True on exit, script returns 0 to shell # if valid is False on exit, script returns 1 to shell # if valid is None on exit, script returns 2 to shell, indicating an internal failure self . valid = None self . success_count = 0 self . failure_count = 0 self . optional_success_count = 0 self . optional_failure_count = 0 self . failure_messages = [] deserialize_response ( self , response , response_cls ) \u00b6 Try to create the appropriate pydantic model from the response. Source code in optimade/validator/validator.py @test_case def deserialize_response ( self , response : requests . models . Response , response_cls ): \"\"\" Try to create the appropriate pydantic model from the response. \"\"\" if not response : raise ResponseError ( \"Request failed\" ) return ( response_cls ( ** response . json ()), \"deserialized correctly as object of type {} \" . format ( response_cls ), ) get_available_endpoints ( self , base_info ) \u00b6 Try to get entry_types_by_format even if base info response could not be validated. Source code in optimade/validator/validator.py @test_case def get_available_endpoints ( self , base_info ): \"\"\" Try to get `entry_types_by_format` even if base info response could not be validated. \"\"\" for _ in [ 0 ]: available_json_entry_endpoints = [] try : available_json_entry_endpoints = base_info . data . attributes . entry_types_by_format . get ( \"json\" ) break except Exception : self . _log . warning ( \"Info endpoint failed serialization, trying to manually extract entry_types_by_format.\" ) if not base_info . json (): raise ResponseError ( \"Unable to get entry types from base info endpoint. \" f \"This may most likely be attributed to a wrong request to the ' { BASE_INFO_ENDPOINT } ' endpoint.\" ) try : available_json_entry_endpoints = base_info . json ()[ \"data\" ][ \"attributes\" ][ \"entry_types_by_format\" ][ \"json\" ] break except ( KeyError , TypeError ): raise ResponseError ( \"Unable to get entry_types_by_format from unserializable base info response {} .\" . format ( base_info ) ) else : raise ResponseError ( \"Unable to find any JSON entry types in entry_types_by_format\" ) if self . index and available_json_entry_endpoints != []: raise ResponseError ( \"No entry endpoint are allowed for an Index meta-database\" ) self . test_entry_endpoints |= set ( available_json_entry_endpoints ) for non_entry_endpoint in ( \"info\" , \"links\" ): if non_entry_endpoint in self . test_entry_endpoints : raise ResponseError ( f 'Illegal entry \" { non_entry_endpoint } \" was found in entry_types_by_format\"' ) return ( available_json_entry_endpoints , \"successfully found available entry types in baseinfo\" , ) get_endpoint ( self , request_str , optional = False ) \u00b6 Gets the response from the endpoint specified by request_str . Source code in optimade/validator/validator.py @test_case def get_endpoint ( self , request_str , optional = False ): \"\"\" Gets the response from the endpoint specified by `request_str`. \"\"\" request_str = request_str . replace ( \" \\n \" , \"\" ) response = self . client . get ( request_str ) if response . status_code != 200 : message = ( f \"Request to ' { request_str } ' returned HTTP code { response . status_code } .\" ) message += \" \\n Error(s):\" for error in response . json () . get ( \"errors\" , []): message += f ' \\n { error . get ( \"title\" , \"N/A\" ) } : { error . get ( \"detail\" , \"N/A\" ) } ( { error . get ( \"source\" , {}) . get ( \"pointer\" , \"N/A\" ) } )' raise ResponseError ( message ) return response , \"request successful.\" get_single_id_from_multi_endpoint ( self , deserialized ) \u00b6 Scrape an ID from the multi-entry endpoint to use as query for single entry endpoint. Source code in optimade/validator/validator.py @test_case def get_single_id_from_multi_endpoint ( self , deserialized ): \"\"\" Scrape an ID from the multi-entry endpoint to use as query for single entry endpoint. \"\"\" if deserialized and deserialized . data : self . test_id_by_type [ deserialized . data [ 0 ] . type ] = deserialized . data [ 0 ] . id self . _log . debug ( \"Set type %s test ID to %s \" , deserialized . data [ 0 ] . type , deserialized . data [ 0 ] . id , ) else : raise ResponseError ( \"No entries found under endpoint to scrape ID from.\" ) return ( self . test_id_by_type [ deserialized . data [ 0 ] . type ], f \"successfully scraped test ID from { deserialized . data [ 0 ] . type } endpoint\" , ) main ( self ) \u00b6 Run all the test cases of the implementation, or the single type test. Source code in optimade/validator/validator.py def main ( self ): \"\"\" Run all the test cases of the implementation, or the single type test. \"\"\" # if single type has been set, only run that test if self . as_type_cls is not None : self . _log . info ( \"Validating response of %s with model %s \" , self . base_url , self . as_type_cls , ) self . test_as_type () self . valid = not bool ( self . failure_count ) return # test entire implementation print ( f \"Testing entire implementation at { self . base_url } ...\" ) print ( \" \\n Mandatory tests:\" ) self . _log . debug ( \"Testing base info endpoint of %s \" , BASE_INFO_ENDPOINT ) base_info = self . test_info_or_links_endpoints ( BASE_INFO_ENDPOINT ) self . get_available_endpoints ( base_info ) for endp in self . test_entry_endpoints : entry_info_endpoint = f \" { BASE_INFO_ENDPOINT } / { endp } \" self . _log . debug ( \"Testing expected info endpoint %s \" , entry_info_endpoint ) self . test_info_or_links_endpoints ( entry_info_endpoint ) for endp in self . test_entry_endpoints : self . _log . debug ( \"Testing multiple entry endpoint of %s \" , endp ) self . test_multi_entry_endpoint ( f \" { endp } ?page_limit= { self . page_limit } \" ) for endp in self . test_entry_endpoints : self . _log . debug ( \"Testing single entry request of type %s \" , endp ) self . test_single_entry_endpoint ( endp ) for endp in self . endpoint_mandatory_queries : # skip empty endpoint query lists if self . endpoint_mandatory_queries [ endp ]: self . _log . debug ( \"Testing mandatory query syntax on endpoint %s \" , endp ) self . test_query_syntax ( endp , self . endpoint_mandatory_queries [ endp ]) self . _log . debug ( \"Testing %s endpoint\" , LINKS_ENDPOINT ) self . test_info_or_links_endpoints ( LINKS_ENDPOINT ) self . valid = not bool ( self . failure_count ) print ( \" \\n Optional tests:\" ) for endp in self . endpoint_optional_queries : # skip empty endpoint query lists if self . endpoint_mandatory_queries [ endp ]: self . _log . debug ( \"Testing optional query syntax on endpoint %s \" , endp ) self . test_query_syntax ( endp , self . endpoint_optional_queries [ endp ], optional = True ) if not self . valid : print ( \" \\n\\n FAILURES \\n \" ) for message in self . failure_messages : print_failure ( message [ 0 ]) for line in message [ 1 ]: print_warning ( \" \\t \" + line ) final_message = f \" \\n\\n Passed { self . success_count } out of { self . success_count + self . failure_count } tests.\" if not self . valid : print_failure ( final_message ) else : print_success ( final_message ) print ( f \"Additionally passed { self . optional_success_count } out of \" f \" { self . optional_success_count + self . optional_failure_count } optional tests.\" ) test_info_or_links_endpoints ( self , request_str ) \u00b6 Runs the test cases for the info endpoints. Source code in optimade/validator/validator.py def test_info_or_links_endpoints ( self , request_str ): \"\"\" Runs the test cases for the info endpoints. \"\"\" response = self . get_endpoint ( request_str ) if response : deserialized = self . deserialize_response ( response , self . response_classes [ request_str ] ) if not deserialized : return response return deserialized return False test_multi_entry_endpoint ( self , request_str ) \u00b6 Runs the test cases for the multi entry endpoints. Source code in optimade/validator/validator.py def test_multi_entry_endpoint ( self , request_str ): \"\"\" Runs the test cases for the multi entry endpoints. \"\"\" response = self . get_endpoint ( request_str ) _type = request_str . split ( \"?\" )[ 0 ] if _type in self . response_classes : response_cls = self . response_classes [ _type ] else : self . _log . warning ( \"Deserializing multi entry response from %s with generic response rather than defined endpoint.\" , _type , ) response_cls = ValidatorEntryResponseMany deserialized = self . deserialize_response ( response , response_cls ) self . test_page_limit ( response ) self . get_single_id_from_multi_endpoint ( deserialized ) test_page_limit ( self , response , check_next_link = True ) \u00b6 Test that a multi-entry endpoint obeys the page limit. Parameters: Name Type Description Default response requests.Response the response to test for page limit compliance. required Exceptions: Type Description ResponseError if test fails in a predictable way. Returns: Type Description bool, str True if the test was successful, with a string describing the success. Source code in optimade/validator/validator.py @test_case def test_page_limit ( self , response , check_next_link = True ): \"\"\" Test that a multi-entry endpoint obeys the page limit. Parameters: response (requests.Response): the response to test for page limit compliance. Keyword arguments: check_next (bool): whether or not to recursively follow and test any pagination links provided under `links->next`. Raises: ResponseError: if test fails in a predictable way. Returns: bool, str: True if the test was successful, with a string describing the success. \"\"\" try : response = response . json () except ( AttributeError , json . JSONDecodeError ): raise ResponseError ( \"Unable to test endpoint page limit.\" ) try : num_entries = len ( response [ \"data\" ]) except ( KeyError , TypeError ): raise ResponseError ( \"Response under `data` field was missing or had wrong type.\" ) if num_entries > self . page_limit : raise ResponseError ( f \"Endpoint did not obey page limit: { num_entries } entries vs { self . page_limit } limit\" ) try : more_data_available = response [ \"meta\" ][ \"more_data_available\" ] except KeyError : raise ResponseError ( \"Field `meta->more_data_available` was missing.\" ) if more_data_available : try : next_link = response [ \"links\" ][ \"next\" ] except KeyError : raise ResponseError ( \"Endpoint suggested more data was available but provided no links->next link.\" ) next_response = self . get_endpoint ( next_link ) self . test_page_limit ( next_response , check_next_link = False ) return ( True , f \"Endpoint obeyed page limit of { self . page_limit } by returning { num_entries } entries.\" , ) test_query_syntax ( self , endpoint , endpoint_queries , optional = False ) \u00b6 Execute a list of valid queries agains the endpoint and assert that no errors are raised. Parameters: Name Type Description Default endpoint str the endpoint to query (e.g. \"structures\"). required endpoint_queries list the list of valid mandatory queries for that endpoint, where the queries do not include the \"?filter=\" prefix, e.g. ['elements HAS \"Na\"']. required Source code in optimade/validator/validator.py def test_query_syntax ( self , endpoint , endpoint_queries , optional = False ): \"\"\" Execute a list of valid queries agains the endpoint and assert that no errors are raised. Parameters: endpoint (str): the endpoint to query (e.g. \"structures\"). endpoint_queries (list): the list of valid mandatory queries for that endpoint, where the queries do not include the \"?filter=\" prefix, e.g. ['elements HAS \"Na\"']. Keyword arguments: optional (bool): treat the success of the queries as optional. \"\"\" valid_queries = [ f \" { endpoint } ?filter= { query } \" for query in endpoint_queries ] for query in valid_queries : self . get_endpoint ( query , optional = optional ) test_single_entry_endpoint ( self , request_str ) \u00b6 Runs the test cases for the single entry endpoints. Source code in optimade/validator/validator.py def test_single_entry_endpoint ( self , request_str ): \"\"\" Runs the test cases for the single entry endpoints. \"\"\" _type = request_str . split ( \"?\" )[ 0 ] response_cls_name = _type + \"/\" if response_cls_name in self . response_classes : response_cls = self . response_classes [ response_cls_name ] else : self . _log . warning ( \"Deserializing single entry response %s with generic response rather than defined endpoint.\" , _type , ) response_cls = ValidatorEntryResponseOne if _type in self . test_id_by_type : test_id = self . test_id_by_type [ _type ] response = self . get_endpoint ( f \" { _type } / { test_id } \" ) if response : self . deserialize_response ( response , response_cls ) ResponseError ( Exception ) \u00b6 This exception should be raised for a manual hardcoded test failure. print_failure ( string , ** kwargs ) \u00b6 Print but sad. Source code in optimade/validator/validator.py def print_failure ( string , ** kwargs ): \"\"\" Print but sad. \"\"\" print ( f \" \\033 [91m \\033 [4m { string } \\033 [0m\" , ** kwargs ) print_success ( string , ** kwargs ) \u00b6 Print but happy. Source code in optimade/validator/validator.py def print_success ( string , ** kwargs ): \"\"\" Print but happy. \"\"\" print ( f \" \\033 [92m \\033 [1m { string } \\033 [0m\" , ** kwargs ) print_warning ( string , ** kwargs ) \u00b6 Print but angry. Source code in optimade/validator/validator.py def print_warning ( string , ** kwargs ): \"\"\" Print but angry. \"\"\" print ( f \" \\033 [93m { string } \\033 [0m\" , ** kwargs ) test_case ( test_fn ) \u00b6 Wrapper for test case functions, which pretty_prints any errors depending on verbosity level and returns only the response to the caller. Parameters: Name Type Description Default test_fn callable function that returns a response to pass to caller, and a message to print upon success. Should raise ResponseError , ValidationError or ManualValidationError if the test case has failed. required Source code in optimade/validator/validator.py def test_case ( test_fn ): \"\"\" Wrapper for test case functions, which pretty_prints any errors depending on verbosity level and returns only the response to the caller. Parameters: test_fn (callable): function that returns a response to pass to caller, and a message to print upon success. Should raise `ResponseError`, `ValidationError` or `ManualValidationError` if the test case has failed. Keyword arguments: optional (bool): whether or not to treat the test as optional. \"\"\" from functools import wraps @wraps ( test_fn ) def wrapper ( validator , * args , optional = False , ** kwargs ): try : result , msg = test_fn ( validator , * args , ** kwargs ) except json . JSONDecodeError as exc : result = None msg = ( \"Critical: unable to parse server response as JSON. \" f \"Error: { type ( exc ) . __name__ } : { exc } \" ) except ( ResponseError , ValidationError ) as exc : result = None msg = f \" { type ( exc ) . __name__ } : { exc } \" try : request = validator . client . last_request except AttributeError : request = validator . base_url if result is not None : if not optional : validator . success_count += 1 else : validator . optional_success_count += 1 message = f \"\u2714: { request } - { msg } \" if validator . verbosity > 0 : if optional : print ( message ) else : print_success ( message ) else : if optional : print ( \".\" , end = \"\" , flush = True ) else : print_success ( \".\" , end = \"\" , flush = True ) else : if not optional : validator . failure_count += 1 else : validator . optional_failure_count += 1 request = request . replace ( \" \\n \" , \"\" ) message = f \" { msg } \" . split ( \" \\n \" ) summary = f \"\u2716: { request } - { test_fn . __name__ } - failed with error\" validator . failure_messages . append (( summary , message )) if validator . verbosity > 0 : if optional : print ( summary ) for line in message : print ( f \" \\t { line } \" ) else : print_failure ( summary ) for line in message : print_warning ( f \" \\t { line } \" ) else : if optional : print ( \"\u2716\" , end = \"\" , flush = True ) else : print_failure ( \"\u2716\" , end = \"\" , flush = True ) return result return wrapper","title":"Validator"},{"location":"reference/validator/validator/#optimade.validator.validator.Client","text":"","title":"Client"},{"location":"reference/validator/validator/#optimade.validator.validator.Client.__init__","text":"Initialises the Client with the given base_url without testing if it is valid. Parameters: Name Type Description Default base_url str the base URL of the optimade implementation, including required request protocol (e.g. `'http //'`) and API version number if necessary. required Examples 'http://example.org/optimade/v1' , 'www.crystallography.net/cod-test/optimade/v0.10.0/' required Note A maximum of one slash (\"/\") is allowed as the last character. required Source code in optimade/validator/validator.py def __init__ ( self , base_url : str , max_retries = 5 ): \"\"\" Initialises the Client with the given `base_url` without testing if it is valid. Parameters: base_url (str): the base URL of the optimade implementation, including request protocol (e.g. `'http://'`) and API version number if necessary. Examples: - `'http://example.org/optimade/v1'`, - `'www.crystallography.net/cod-test/optimade/v0.10.0/'` Note: A maximum of one slash (\"/\") is allowed as the last character. \"\"\" self . base_url = base_url self . last_request = None self . response = None self . max_retries = max_retries","title":"__init__()"},{"location":"reference/validator/validator/#optimade.validator.validator.Client.get","text":"Makes the given request, with a number of retries if being rate limited. The request will be prepended with the base_url unless the request appears to be an absolute URL (i.e. starts with http:// or https:// ). Parameters: Name Type Description Default request str the request to make against the base URL of this client. required Returns: Type Description response (requests.models.Response) the response from the server. Exceptions: Type Description SystemExit if there is no response from the server, or if the URL is invalid. ResponseError if the server does not respond with a non-429 status code within the MAX_RETRIES attempts. Source code in optimade/validator/validator.py def get ( self , request : str ): \"\"\" Makes the given request, with a number of retries if being rate limited. The request will be prepended with the `base_url` unless the request appears to be an absolute URL (i.e. starts with `http://` or `https://`). Parameters: request (str): the request to make against the base URL of this client. Returns: response (requests.models.Response): the response from the server. Raises: SystemExit: if there is no response from the server, or if the URL is invalid. ResponseError: if the server does not respond with a non-429 status code within the `MAX_RETRIES` attempts. \"\"\" if urllib . parse . urlparse ( request , allow_fragments = True ) . scheme : self . last_request = request else : if request and not request . startswith ( \"/\" ): request = f \"/ { request } \" self . last_request = f \" { self . base_url }{ request } \" status_code = None retries = 0 # probably a smarter way to do this with requests, but their documentation 404's... while retries < self . max_retries : retries += 1 try : self . response = requests . get ( self . last_request ) except requests . exceptions . ConnectionError : sys . exit ( f \"No response from server at { self . last_request } \" ) except requests . exceptions . MissingSchema : sys . exit ( f \"Unable to make request on { self . last_request } , did you mean http:// { self . last_request } ?\" ) status_code = self . response . status_code if status_code != 429 : break print ( \"Hit rate limit, sleeping for 1 s...\" ) time . sleep ( 1 ) else : raise ResponseError ( \"Hit max (manual) retries on request.\" ) return self . response","title":"get()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator","text":"Class to call test functions on a particular OPTIMADE implementation. Uses the pydantic models in optimade.models to validate the response from the server and crawl through the available endpoints. Drawbacks only works for current version of the specification as defined by optimade.models .","title":"ImplementationValidator"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.__init__","text":"Set up the tests to run, based on constants in this module for required endpoints. Source code in optimade/validator/validator.py def __init__ ( # pylint: disable=too-many-arguments self , client : Union [ Client , TestClient ] = None , base_url : str = None , verbosity : int = 0 , page_limit : int = 5 , max_retries : int = 5 , as_type : str = None , index : bool = False , ): \"\"\" Set up the tests to run, based on constants in this module for required endpoints. \"\"\" self . verbosity = verbosity self . max_retries = max_retries self . page_limit = page_limit self . index = index if as_type is None : self . as_type_cls = None elif self . index : if as_type not in RESPONSE_CLASSES_INDEX . keys (): raise RuntimeError ( f \"Provided as_type=' { as_type } ' not allowed for an Index meta-database.\" ) self . as_type_cls = RESPONSE_CLASSES_INDEX [ as_type ] elif as_type in ( \"structure\" , \"reference\" ): self . as_type_cls = RESPONSE_CLASSES [ f \" { as_type } s/\" ] else : self . as_type_cls = RESPONSE_CLASSES [ as_type ] if client is None and base_url is None : raise RuntimeError ( \"Need at least a URL or a client to initialize validator.\" ) if base_url and client : raise RuntimeError ( \"Please specify at most one of base_url or client.\" ) if client : self . client = client self . base_url = self . client . base_url else : while base_url . endswith ( \"/\" ): base_url = base_url [: - 1 ] self . base_url = base_url self . client = Client ( base_url , max_retries = self . max_retries ) self . test_id_by_type = {} self . _setup_log () self . expected_entry_endpoints = ( REQUIRED_ENTRY_ENDPOINTS_INDEX if self . index else REQUIRED_ENTRY_ENDPOINTS ) self . test_entry_endpoints = set ( self . expected_entry_endpoints ) self . endpoint_mandatory_queries = ( {} if self . index else ENDPOINT_MANDATORY_QUERIES ) self . endpoint_optional_queries = {} if self . index else ENDPOINT_OPTIONAL_QUERIES self . response_classes = ( RESPONSE_CLASSES_INDEX if self . index else RESPONSE_CLASSES ) # some simple checks on base_url base_url = urllib . parse . urlparse ( self . base_url ) # only allow filters/endpoints if we are working in \"as_type\" mode if self . as_type_cls is None and ( base_url . query or any ( endp in base_url . path for endp in self . expected_entry_endpoints ) ): raise SystemExit ( \"Base URL not appropriate: should not contain an endpoint or filter.\" ) # if valid is True on exit, script returns 0 to shell # if valid is False on exit, script returns 1 to shell # if valid is None on exit, script returns 2 to shell, indicating an internal failure self . valid = None self . success_count = 0 self . failure_count = 0 self . optional_success_count = 0 self . optional_failure_count = 0 self . failure_messages = []","title":"__init__()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.deserialize_response","text":"Try to create the appropriate pydantic model from the response. Source code in optimade/validator/validator.py @test_case def deserialize_response ( self , response : requests . models . Response , response_cls ): \"\"\" Try to create the appropriate pydantic model from the response. \"\"\" if not response : raise ResponseError ( \"Request failed\" ) return ( response_cls ( ** response . json ()), \"deserialized correctly as object of type {} \" . format ( response_cls ), )","title":"deserialize_response()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.get_available_endpoints","text":"Try to get entry_types_by_format even if base info response could not be validated. Source code in optimade/validator/validator.py @test_case def get_available_endpoints ( self , base_info ): \"\"\" Try to get `entry_types_by_format` even if base info response could not be validated. \"\"\" for _ in [ 0 ]: available_json_entry_endpoints = [] try : available_json_entry_endpoints = base_info . data . attributes . entry_types_by_format . get ( \"json\" ) break except Exception : self . _log . warning ( \"Info endpoint failed serialization, trying to manually extract entry_types_by_format.\" ) if not base_info . json (): raise ResponseError ( \"Unable to get entry types from base info endpoint. \" f \"This may most likely be attributed to a wrong request to the ' { BASE_INFO_ENDPOINT } ' endpoint.\" ) try : available_json_entry_endpoints = base_info . json ()[ \"data\" ][ \"attributes\" ][ \"entry_types_by_format\" ][ \"json\" ] break except ( KeyError , TypeError ): raise ResponseError ( \"Unable to get entry_types_by_format from unserializable base info response {} .\" . format ( base_info ) ) else : raise ResponseError ( \"Unable to find any JSON entry types in entry_types_by_format\" ) if self . index and available_json_entry_endpoints != []: raise ResponseError ( \"No entry endpoint are allowed for an Index meta-database\" ) self . test_entry_endpoints |= set ( available_json_entry_endpoints ) for non_entry_endpoint in ( \"info\" , \"links\" ): if non_entry_endpoint in self . test_entry_endpoints : raise ResponseError ( f 'Illegal entry \" { non_entry_endpoint } \" was found in entry_types_by_format\"' ) return ( available_json_entry_endpoints , \"successfully found available entry types in baseinfo\" , )","title":"get_available_endpoints()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.get_endpoint","text":"Gets the response from the endpoint specified by request_str . Source code in optimade/validator/validator.py @test_case def get_endpoint ( self , request_str , optional = False ): \"\"\" Gets the response from the endpoint specified by `request_str`. \"\"\" request_str = request_str . replace ( \" \\n \" , \"\" ) response = self . client . get ( request_str ) if response . status_code != 200 : message = ( f \"Request to ' { request_str } ' returned HTTP code { response . status_code } .\" ) message += \" \\n Error(s):\" for error in response . json () . get ( \"errors\" , []): message += f ' \\n { error . get ( \"title\" , \"N/A\" ) } : { error . get ( \"detail\" , \"N/A\" ) } ( { error . get ( \"source\" , {}) . get ( \"pointer\" , \"N/A\" ) } )' raise ResponseError ( message ) return response , \"request successful.\"","title":"get_endpoint()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.get_single_id_from_multi_endpoint","text":"Scrape an ID from the multi-entry endpoint to use as query for single entry endpoint. Source code in optimade/validator/validator.py @test_case def get_single_id_from_multi_endpoint ( self , deserialized ): \"\"\" Scrape an ID from the multi-entry endpoint to use as query for single entry endpoint. \"\"\" if deserialized and deserialized . data : self . test_id_by_type [ deserialized . data [ 0 ] . type ] = deserialized . data [ 0 ] . id self . _log . debug ( \"Set type %s test ID to %s \" , deserialized . data [ 0 ] . type , deserialized . data [ 0 ] . id , ) else : raise ResponseError ( \"No entries found under endpoint to scrape ID from.\" ) return ( self . test_id_by_type [ deserialized . data [ 0 ] . type ], f \"successfully scraped test ID from { deserialized . data [ 0 ] . type } endpoint\" , )","title":"get_single_id_from_multi_endpoint()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.main","text":"Run all the test cases of the implementation, or the single type test. Source code in optimade/validator/validator.py def main ( self ): \"\"\" Run all the test cases of the implementation, or the single type test. \"\"\" # if single type has been set, only run that test if self . as_type_cls is not None : self . _log . info ( \"Validating response of %s with model %s \" , self . base_url , self . as_type_cls , ) self . test_as_type () self . valid = not bool ( self . failure_count ) return # test entire implementation print ( f \"Testing entire implementation at { self . base_url } ...\" ) print ( \" \\n Mandatory tests:\" ) self . _log . debug ( \"Testing base info endpoint of %s \" , BASE_INFO_ENDPOINT ) base_info = self . test_info_or_links_endpoints ( BASE_INFO_ENDPOINT ) self . get_available_endpoints ( base_info ) for endp in self . test_entry_endpoints : entry_info_endpoint = f \" { BASE_INFO_ENDPOINT } / { endp } \" self . _log . debug ( \"Testing expected info endpoint %s \" , entry_info_endpoint ) self . test_info_or_links_endpoints ( entry_info_endpoint ) for endp in self . test_entry_endpoints : self . _log . debug ( \"Testing multiple entry endpoint of %s \" , endp ) self . test_multi_entry_endpoint ( f \" { endp } ?page_limit= { self . page_limit } \" ) for endp in self . test_entry_endpoints : self . _log . debug ( \"Testing single entry request of type %s \" , endp ) self . test_single_entry_endpoint ( endp ) for endp in self . endpoint_mandatory_queries : # skip empty endpoint query lists if self . endpoint_mandatory_queries [ endp ]: self . _log . debug ( \"Testing mandatory query syntax on endpoint %s \" , endp ) self . test_query_syntax ( endp , self . endpoint_mandatory_queries [ endp ]) self . _log . debug ( \"Testing %s endpoint\" , LINKS_ENDPOINT ) self . test_info_or_links_endpoints ( LINKS_ENDPOINT ) self . valid = not bool ( self . failure_count ) print ( \" \\n Optional tests:\" ) for endp in self . endpoint_optional_queries : # skip empty endpoint query lists if self . endpoint_mandatory_queries [ endp ]: self . _log . debug ( \"Testing optional query syntax on endpoint %s \" , endp ) self . test_query_syntax ( endp , self . endpoint_optional_queries [ endp ], optional = True ) if not self . valid : print ( \" \\n\\n FAILURES \\n \" ) for message in self . failure_messages : print_failure ( message [ 0 ]) for line in message [ 1 ]: print_warning ( \" \\t \" + line ) final_message = f \" \\n\\n Passed { self . success_count } out of { self . success_count + self . failure_count } tests.\" if not self . valid : print_failure ( final_message ) else : print_success ( final_message ) print ( f \"Additionally passed { self . optional_success_count } out of \" f \" { self . optional_success_count + self . optional_failure_count } optional tests.\" )","title":"main()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.test_info_or_links_endpoints","text":"Runs the test cases for the info endpoints. Source code in optimade/validator/validator.py def test_info_or_links_endpoints ( self , request_str ): \"\"\" Runs the test cases for the info endpoints. \"\"\" response = self . get_endpoint ( request_str ) if response : deserialized = self . deserialize_response ( response , self . response_classes [ request_str ] ) if not deserialized : return response return deserialized return False","title":"test_info_or_links_endpoints()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.test_multi_entry_endpoint","text":"Runs the test cases for the multi entry endpoints. Source code in optimade/validator/validator.py def test_multi_entry_endpoint ( self , request_str ): \"\"\" Runs the test cases for the multi entry endpoints. \"\"\" response = self . get_endpoint ( request_str ) _type = request_str . split ( \"?\" )[ 0 ] if _type in self . response_classes : response_cls = self . response_classes [ _type ] else : self . _log . warning ( \"Deserializing multi entry response from %s with generic response rather than defined endpoint.\" , _type , ) response_cls = ValidatorEntryResponseMany deserialized = self . deserialize_response ( response , response_cls ) self . test_page_limit ( response ) self . get_single_id_from_multi_endpoint ( deserialized )","title":"test_multi_entry_endpoint()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.test_page_limit","text":"Test that a multi-entry endpoint obeys the page limit. Parameters: Name Type Description Default response requests.Response the response to test for page limit compliance. required Exceptions: Type Description ResponseError if test fails in a predictable way. Returns: Type Description bool, str True if the test was successful, with a string describing the success. Source code in optimade/validator/validator.py @test_case def test_page_limit ( self , response , check_next_link = True ): \"\"\" Test that a multi-entry endpoint obeys the page limit. Parameters: response (requests.Response): the response to test for page limit compliance. Keyword arguments: check_next (bool): whether or not to recursively follow and test any pagination links provided under `links->next`. Raises: ResponseError: if test fails in a predictable way. Returns: bool, str: True if the test was successful, with a string describing the success. \"\"\" try : response = response . json () except ( AttributeError , json . JSONDecodeError ): raise ResponseError ( \"Unable to test endpoint page limit.\" ) try : num_entries = len ( response [ \"data\" ]) except ( KeyError , TypeError ): raise ResponseError ( \"Response under `data` field was missing or had wrong type.\" ) if num_entries > self . page_limit : raise ResponseError ( f \"Endpoint did not obey page limit: { num_entries } entries vs { self . page_limit } limit\" ) try : more_data_available = response [ \"meta\" ][ \"more_data_available\" ] except KeyError : raise ResponseError ( \"Field `meta->more_data_available` was missing.\" ) if more_data_available : try : next_link = response [ \"links\" ][ \"next\" ] except KeyError : raise ResponseError ( \"Endpoint suggested more data was available but provided no links->next link.\" ) next_response = self . get_endpoint ( next_link ) self . test_page_limit ( next_response , check_next_link = False ) return ( True , f \"Endpoint obeyed page limit of { self . page_limit } by returning { num_entries } entries.\" , )","title":"test_page_limit()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.test_query_syntax","text":"Execute a list of valid queries agains the endpoint and assert that no errors are raised. Parameters: Name Type Description Default endpoint str the endpoint to query (e.g. \"structures\"). required endpoint_queries list the list of valid mandatory queries for that endpoint, where the queries do not include the \"?filter=\" prefix, e.g. ['elements HAS \"Na\"']. required Source code in optimade/validator/validator.py def test_query_syntax ( self , endpoint , endpoint_queries , optional = False ): \"\"\" Execute a list of valid queries agains the endpoint and assert that no errors are raised. Parameters: endpoint (str): the endpoint to query (e.g. \"structures\"). endpoint_queries (list): the list of valid mandatory queries for that endpoint, where the queries do not include the \"?filter=\" prefix, e.g. ['elements HAS \"Na\"']. Keyword arguments: optional (bool): treat the success of the queries as optional. \"\"\" valid_queries = [ f \" { endpoint } ?filter= { query } \" for query in endpoint_queries ] for query in valid_queries : self . get_endpoint ( query , optional = optional )","title":"test_query_syntax()"},{"location":"reference/validator/validator/#optimade.validator.validator.ImplementationValidator.test_single_entry_endpoint","text":"Runs the test cases for the single entry endpoints. Source code in optimade/validator/validator.py def test_single_entry_endpoint ( self , request_str ): \"\"\" Runs the test cases for the single entry endpoints. \"\"\" _type = request_str . split ( \"?\" )[ 0 ] response_cls_name = _type + \"/\" if response_cls_name in self . response_classes : response_cls = self . response_classes [ response_cls_name ] else : self . _log . warning ( \"Deserializing single entry response %s with generic response rather than defined endpoint.\" , _type , ) response_cls = ValidatorEntryResponseOne if _type in self . test_id_by_type : test_id = self . test_id_by_type [ _type ] response = self . get_endpoint ( f \" { _type } / { test_id } \" ) if response : self . deserialize_response ( response , response_cls )","title":"test_single_entry_endpoint()"},{"location":"reference/validator/validator/#optimade.validator.validator.ResponseError","text":"This exception should be raised for a manual hardcoded test failure.","title":"ResponseError"},{"location":"reference/validator/validator/#optimade.validator.validator.print_failure","text":"Print but sad. Source code in optimade/validator/validator.py def print_failure ( string , ** kwargs ): \"\"\" Print but sad. \"\"\" print ( f \" \\033 [91m \\033 [4m { string } \\033 [0m\" , ** kwargs )","title":"print_failure()"},{"location":"reference/validator/validator/#optimade.validator.validator.print_success","text":"Print but happy. Source code in optimade/validator/validator.py def print_success ( string , ** kwargs ): \"\"\" Print but happy. \"\"\" print ( f \" \\033 [92m \\033 [1m { string } \\033 [0m\" , ** kwargs )","title":"print_success()"},{"location":"reference/validator/validator/#optimade.validator.validator.print_warning","text":"Print but angry. Source code in optimade/validator/validator.py def print_warning ( string , ** kwargs ): \"\"\" Print but angry. \"\"\" print ( f \" \\033 [93m { string } \\033 [0m\" , ** kwargs )","title":"print_warning()"},{"location":"reference/validator/validator/#optimade.validator.validator.test_case","text":"Wrapper for test case functions, which pretty_prints any errors depending on verbosity level and returns only the response to the caller. Parameters: Name Type Description Default test_fn callable function that returns a response to pass to caller, and a message to print upon success. Should raise ResponseError , ValidationError or ManualValidationError if the test case has failed. required Source code in optimade/validator/validator.py def test_case ( test_fn ): \"\"\" Wrapper for test case functions, which pretty_prints any errors depending on verbosity level and returns only the response to the caller. Parameters: test_fn (callable): function that returns a response to pass to caller, and a message to print upon success. Should raise `ResponseError`, `ValidationError` or `ManualValidationError` if the test case has failed. Keyword arguments: optional (bool): whether or not to treat the test as optional. \"\"\" from functools import wraps @wraps ( test_fn ) def wrapper ( validator , * args , optional = False , ** kwargs ): try : result , msg = test_fn ( validator , * args , ** kwargs ) except json . JSONDecodeError as exc : result = None msg = ( \"Critical: unable to parse server response as JSON. \" f \"Error: { type ( exc ) . __name__ } : { exc } \" ) except ( ResponseError , ValidationError ) as exc : result = None msg = f \" { type ( exc ) . __name__ } : { exc } \" try : request = validator . client . last_request except AttributeError : request = validator . base_url if result is not None : if not optional : validator . success_count += 1 else : validator . optional_success_count += 1 message = f \"\u2714: { request } - { msg } \" if validator . verbosity > 0 : if optional : print ( message ) else : print_success ( message ) else : if optional : print ( \".\" , end = \"\" , flush = True ) else : print_success ( \".\" , end = \"\" , flush = True ) else : if not optional : validator . failure_count += 1 else : validator . optional_failure_count += 1 request = request . replace ( \" \\n \" , \"\" ) message = f \" { msg } \" . split ( \" \\n \" ) summary = f \"\u2716: { request } - { test_fn . __name__ } - failed with error\" validator . failure_messages . append (( summary , message )) if validator . verbosity > 0 : if optional : print ( summary ) for line in message : print ( f \" \\t { line } \" ) else : print_failure ( summary ) for line in message : print_warning ( f \" \\t { line } \" ) else : if optional : print ( \"\u2716\" , end = \"\" , flush = True ) else : print_failure ( \"\u2716\" , end = \"\" , flush = True ) return result return wrapper","title":"test_case()"},{"location":"reference/validator/validator_model_patches/","text":"This class contains patched versions of the OPTIMADE models as a workaround for the response field workaround of allowing responses to contain bare dictionaries. These allow the validator to print detailed validation responses. ValidatorEntryResponseMany ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ValidatorEntryResponseOne ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ValidatorLinksResponse ( Success ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ValidatorReferenceResponseMany ( ValidatorEntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ValidatorReferenceResponseOne ( ValidatorEntryResponseOne ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ValidatorStructureResponseMany ( ValidatorEntryResponseMany ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords. ValidatorStructureResponseOne ( ValidatorEntryResponseOne ) pydantic-model \u00b6 __json_encoder__ ( obj ) special staticmethod \u00b6 partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"Validator model patches"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorEntryResponseMany","text":"","title":"ValidatorEntryResponseMany"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorEntryResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorEntryResponseOne","text":"","title":"ValidatorEntryResponseOne"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorEntryResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorLinksResponse","text":"","title":"ValidatorLinksResponse"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorLinksResponse.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorReferenceResponseMany","text":"","title":"ValidatorReferenceResponseMany"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorReferenceResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorReferenceResponseOne","text":"","title":"ValidatorReferenceResponseOne"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorReferenceResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorStructureResponseMany","text":"","title":"ValidatorStructureResponseMany"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorStructureResponseMany.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorStructureResponseOne","text":"","title":"ValidatorStructureResponseOne"},{"location":"reference/validator/validator_model_patches/#optimade.validator.validator_model_patches.ValidatorStructureResponseOne.__json_encoder__","text":"partial(func, args, *keywords) - new function with partial application of the given arguments and keywords.","title":"__json_encoder__()"},{"location":"use_cases/dynamic_db/","text":"OPTIMADE API for dynamic databases \u00b6","title":"OPTIMADE API for dynamic databases"},{"location":"use_cases/dynamic_db/#optimade-api-for-dynamic-databases","text":"","title":"OPTIMADE API for dynamic databases"},{"location":"use_cases/multi_db/","text":"OPTIMADE API for multiple databases \u00b6","title":"OPTIMADE API for multiple databases"},{"location":"use_cases/multi_db/#optimade-api-for-multiple-databases","text":"","title":"OPTIMADE API for multiple databases"},{"location":"use_cases/single_db/","text":"OPTIMADE API for a single database \u00b6","title":"OPTIMADE API for a single database"},{"location":"use_cases/single_db/#optimade-api-for-a-single-database","text":"","title":"OPTIMADE API for a single database"}]}